# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PflipUav3
                                 A QGIS plugin
 Photogrammetric and Remote Sensing Flight Planning for unmanned aerial vehicle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-23
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernández López, PAFYC-UCLM
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# import PyQt5 classes
# import PyQGIS classes
from qgis.core import (Qgis)

# import self classes
from .. import config as c
from ..classes.model_db_manager_definitions import ModelDbManagerDefinitions as modeldb

# imports other classes
from qgis.utils import spatialite_connect
import sqlite3
import os

class DbOperations():
    SQL_TYPE_SELECT = "SELECT"
    SQL_TYPE_INSERT = "INSERT"
    SQL_TYPE_UPDATE = "UPDATE"
    SQL_TYPE_DELETE = "DELETE"
    SQL_TYPE_CREATE_TABLE = "CREATE"

    def __init__(self,
                 iface):
        """
        Initialize method
        :param iface: iface
        :type iface: QgsInterface
        """
        self.iface = iface

    def add_geometry_output_tables(self,
                                   path_db,
                                   name_table_spatial,
                                   geom_fieldname,
                                   str_cod_crs_epsg,
                                   geom_type, str_dimensions,
                                   is_trigger_axis_layer=False):
        """
        Brief: añade un campo de geometría a la estructura de tablas de salida preexistentes en la BD plantilla
                que se copia al abrir un nuevo proyecto. Esta acción se lleva a cabo cuando se crea un nuevo proyecto
                PLIPUAV, pues es necesario conocer el CRS del proyecto.
        :param path_db_target: path de la BD del proyecto PLIPUAV
        :type path_db_target: str
        :param name_table_spatial: nombre de la tabla espacial a la que se le quiere añadir un campo espacial
        :type name_table_spatial: str
        :param geom_fieldname: nombre del campo geom
        :type geom_fieldname: str
        :param str_cod_crs_epsg: código epsg de la tabla espacial a crear
        :type str_cod_crs_epsg: str
        :param geom_type: tipo de geometría
        :type geom_type: str
        :param str_dimensions: número de dimensiones
        :type str_dimensions: str
        """
        connection_spatialite = spatialite_connect(path_db)  # connection spatialite
        cursor = connection_spatialite.cursor()

        # query addGeometryColumn
        str_sql = "SELECT AddGeometryColumn('%s', '%s', %s, '%s', %s);" % (name_table_spatial,
                                                                           geom_fieldname,
                                                                           str_cod_crs_epsg,
                                                                           geom_type,
                                                                           str_dimensions)
        cursor.execute(str_sql)

        # creación índice espacial
        str_sql = "SELECT CreateSpatialIndex('%s', '%s');" % (name_table_spatial,
                                                              geom_fieldname)
        cursor.execute(str_sql)

        if is_trigger_axis_layer:
            str_sql = "CREATE TRIGGER update_length_after_insert AFTER INSERT ON %s\n" \
                      % modeldb.TABLE_SPATIAL_LAYER_AXIS_TABLE_NAME
            str_sql += "BEGIN" + "\n"
            str_sql += "update %s SET %s = round(ST_Length(\"%s\"), 2) WHERE rowid = new.rowid;\n" \
                       % (modeldb.TABLE_SPATIAL_LAYER_AXIS_TABLE_NAME,
                          modeldb.TBL_SPATIAL_LAYER_AXIS_FIELD_LENGTH,
                          modeldb.GEOMETRY_FIELDNAME)
            str_sql += "END"
            cursor.execute(str_sql)
            str_sql = "CREATE TRIGGER update_length_after_update AFTER UPDATE ON %s\n" \
                      % modeldb.TABLE_SPATIAL_LAYER_AXIS_TABLE_NAME
            str_sql += "BEGIN" + "\n"
            str_sql += "update %s SET %s = round(ST_Length(\"%s\"), 2) WHERE rowid = new.rowid;\n" \
                       % (modeldb.TABLE_SPATIAL_LAYER_AXIS_TABLE_NAME,
                          modeldb.TBL_SPATIAL_LAYER_AXIS_FIELD_LENGTH,
                          modeldb.GEOMETRY_FIELDNAME)
            str_sql += "END"
            cursor.execute(str_sql)


    def connection_sqlite(self,
                          path):
        if not os.path.exists(path):
            str_msg = "Spatialite file [%s] doesn't exist" % path
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            return None
        connection_sqlite = spatialite_connect(path)
        return connection_sqlite

    def create_spatial_table(self,
                             path_db_target,
                             name_table_spatial,
                             str_cod_crs_epsg,
                             geom_type):
        """
        Brief: crea una tabla espacial en spatiaLite
        :param path_db_target: ruta de la base de datos destino
        :type path_db_target: str
        :param name_table_spatial: nombre de la tabla espacial a crear
        :type name_table_spatial: str
        :param str_cod_crs_epsg: crs de la capa a crear
        :type str_cod_crs_epsg: str
        :param geom_type: tipo de geometría
        :type geom_type: str
        """
        con_db_project = self.connection_sqlite(path_db_target)

        name_field_id = "id_%s" % name_table_spatial

        # crea la tabla (de momento no espacial)
        if name_table_spatial == c.CONST_PFLIPUAV_LAYER_AXIS:
            str_sql = "CREATE TABLE IF NOT EXISTS %s (%s %s PRIMARY KEY, %s %s, %s %s, %s %s UNIQUE);" \
                      % (name_table_spatial,
                         name_field_id, modeldb.SPATIALITE_FIELD_TYPE_INTEGER,
                         modeldb.TBL_SPATIAL_FIELD_NOTES, modeldb.SPATIALITE_FIELD_TYPE_TEXT,
                         modeldb.TBL_SPATIAL_LAYER_AXIS_FIELD_LENGTH, modeldb.SPATIALITE_FIELD_TYPE_REAL,
                         modeldb.TBL_SPATIAL_LAYER_AXIS_FIELD_COD_SEGMENT, modeldb.SPATIALITE_FIELD_TYPE_TEXT)
        else:
            str_sql = "CREATE TABLE %s (%s %s PRIMARY KEY, %s %s);" % (name_table_spatial,
                                                                       name_field_id,
                                                                       modeldb.SPATIALITE_FIELD_TYPE_INTEGER,
                                                                       modeldb.TBL_SPATIAL_FIELD_NOTES,
                                                                       modeldb.SPATIALITE_FIELD_TYPE_TEXT)

        self.execute_query(con_db_project, str_sql, self.SQL_TYPE_CREATE_TABLE)

        # añade los campos de geometría
        if name_table_spatial == c.CONST_PFLIPUAV_LAYER_AXIS:
            self.add_geometry_output_tables(path_db_target,
                                            name_table_spatial,
                                            modeldb.GEOMETRY_FIELDNAME,
                                            str_cod_crs_epsg,
                                            geom_type,
                                            '2',
                                            is_trigger_axis_layer=True)
        else:
            self.add_geometry_output_tables(path_db_target,
                                            name_table_spatial,
                                            modeldb.GEOMETRY_FIELDNAME,
                                            str_cod_crs_epsg,
                                            geom_type,
                                            '2')
        con_db_project.close()

    def execute_query(self,
                      connection,
                      str_sql,
                      str_type_query):
        """
        Brief: Ejecuta una consulta de tipo SELECT, INSERT, DELETE
        :param connection: Objeto conexión a la base de datos
        :type connection: SQLite database connection
        :param str_query: Cadena de texto con la consulta a ejecutar
        :type str_query: str
        :param str_type_query: Cadena de texto con el tipo de consulta a ejecutar definida en archivo config.py
        :type str_type_query: str
        :return: Para el caso de consultas tipo SELECT devuelve un objeto cursor
        """
        try:
            cursor = connection.cursor()
            cursor.execute(str_sql)
            if str_type_query == self.SQL_TYPE_SELECT:
                data = cursor.fetchall()
                if not data:
                    connection.commit()
                return data
            if str_type_query == self.SQL_TYPE_INSERT or self.SQL_TYPE_UPDATE or self.SQL_TYPE_DELETE or self.SQL_TYPE_CREATE_TABLE:
                connection.commit()  # commits the current transaction
        except sqlite3.Error as e:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Database error: %s" % e,
                                                Qgis.Critical,
                                                10)
        except Exception as e:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Exception in execute_query: %s" % e,
                                                Qgis.Critical,
                                                10)

    def execute_query_old(self,
                          path_db,
                          str_query):
        """
        Brief: ejecuta y commit una consulta dada de tipo no SELECT
        :param path_db: path de la BD sqlite
        :type path_db: str
        :param str_query: cadena con la consulta a ejecutar
        :type str_query: str
        """

        conexion = self.connection_sqlite(path_db)
        cursor = conexion.cursor()

        cursor.execute(str_query)
        conexion.commit()
        conexion.close()  # se cierra la base de datos

    def execute_sqls(self,
                     connection,
                     sqls):
        str_error = ''
        cursor = connection.cursor()
        for sql in sqls:
            try:
                cursor.execute(sql)
            except sqlite3.OperationalError as str_msg_error:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Database error: %s" % str_msg_error,
                                                    Qgis.Critical,
                                                    10)
                str_error = ("Database error:\n{}").format(str_msg_error)
        connection.commit()
        return str_error

    def execute_scripts_from_file(self,
                                  connection,
                                  path_sql_file):
        cursor = connection.cursor()
        # Open and read the file as a single buffer
        fd = open(path_sql_file, 'r')
        sql_file = fd.read()
        fd.close()

        sql_commands = sql_file.split(';')  # all SQL commands (split on ';')

        for command in sql_commands:
            try:
                cursor.execute(command)
            except sqlite3.OperationalError as str_msg_error:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Database error: %s" % str_msg_error,
                                                    Qgis.Critical,
                                                    10)
        connection.commit()

    def get_index_combo(self,
                        path_db_project,
                        str_sql,
                        value_compare):
        """
        Brief: obtiene el índice de un valor dado a partir de una consulta y un valor a comparar
        :param path_db_project: path de la BD del proyecto PLIPUAV
        :type path_db_project: str
        :param str_sql: consulta sql de la tabla maestra
        :type str_sql: str
        :param value_compare: valor con el que se compara
        :type value_compare: str
        :return: Índice del combobox
        :rtype: int
        """

        conexion = self.connection_sqlite(path_db_project)
        cursor = conexion.cursor()

        indice = 1  # porque el 0 es select ...

        cursor.execute(str_sql)
        for row in cursor.fetchall():
            value_in_database = row[0]
            if (value_in_database == value_compare):
                return indice
            else:
                indice = indice + 1
        conexion.close()  # se cierra la base de datos
        return -1

    def get_max_value_field_from_table_db(self,
                                          path_db_project,
                                          fieldname,
                                          tablename):
        """
        Brief: obtiene el valor máximo de un campo dado de tabla de base de datos
        :param path_db_project: path de la base de datos del proyecto PLIPUAV
        :type path_db_project: str
        :param fieldname: nombre del campo a consultar
        :type fieldname: str
        :param tablename: nombre de la tabla a consultar
        :type tablename: str
        :return: valor máximo de un campo. Si hay alguna excepción devuelve un -1
        :rtype: int
        """

        conexion = self.connection_sqlite(path_db_project)
        cursor = conexion.cursor()

        str_sql = "SELECT MAX("
        str_sql += fieldname
        str_sql += ") FROM "
        str_sql += tablename

        cursor.execute(str_sql)
        for row in cursor.fetchall():
            max_value = row[0]  # max
        if (max_value == None):
            max_value = 0
        conexion.close()  # se cierra la base de datos
        return max_value

    def get_parameter_db_flight_block(self,
                                      path_db_project,
                                      str_code_flight_block):
        """
        Brief: obtiene parámetros ordenados almacenados en la bd del proyecto PLIPUAV, tabla [flight_block]
        :param path_db_project: path de la BD PLIPUAV
        :type path_db_project: str
        :param str_code_flight_block: código de bloque de vuelo
        :type str_code_flight_block: str
        :return: lista con los parámetros de un bloque de vuelo solicitado
        :rtype: list
        """

        list_parameter_db_flight_block = [] # se inicializa la lista

        # conexión con la base de datos
        con_db_project = self.connection_sqlite(path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT * FROM flight_block WHERE cod_flight_block = '" + str_code_flight_block + "'"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            list_parameter_db_flight_block.append(row[0])  # código de bloque de vuelo
            list_parameter_db_flight_block.append(row[1])  # str_cod_camera
            list_parameter_db_flight_block.append(row[2])  # str_dtm_path
            list_parameter_db_flight_block.append(row[3])  # id_tof
            list_parameter_db_flight_block.append(row[4])  # landing type (-1 - toff point; 0 - end point; > 0 - id del punto digitalizado)
            list_parameter_db_flight_block.append(row[5])  # id_firmware
            list_parameter_db_flight_block.append(row[6])  # str_id_fb_type
            list_parameter_db_flight_block.append(row[7])  # gsd
            list_parameter_db_flight_block.append(row[8])  # gsd_tolerance
            list_parameter_db_flight_block.append(row[9])  # overlap_fwd
            list_parameter_db_flight_block.append(row[10])  # overlap_side
            list_parameter_db_flight_block.append(row[11])  # gps_precision
            list_parameter_db_flight_block.append(row[12])  # omega_precision
            list_parameter_db_flight_block.append(row[13])  # phi_precision
            list_parameter_db_flight_block.append(row[14])  # kappa_precision
            list_parameter_db_flight_block.append(row[15])  # id_trajectory_type
            list_parameter_db_flight_block.append(row[16])  # cruising_speed
            list_parameter_db_flight_block.append(row[17])  # ascent_speed
            list_parameter_db_flight_block.append(row[18])  # decrease_speed
            list_parameter_db_flight_block.append(row[19])  # zone_lineal_magnification
            list_parameter_db_flight_block.append(row[20])  # takeoff_height
            list_parameter_db_flight_block.append(row[21])  # id_nbk
            list_parameter_db_flight_block.append(row[22])  # landing_height
            list_parameter_db_flight_block.append(row[23])  # wpb
            list_parameter_db_flight_block.append(row[24])  # images_item
            list_parameter_db_flight_block.append(row[25])  # shot_interval (waiting time by image)
            list_parameter_db_flight_block.append(row[26])  # omega_angle
            list_parameter_db_flight_block.append(row[27])  # phi_angle
            list_parameter_db_flight_block.append(row[28])  # id_erc
            list_parameter_db_flight_block.append(row[29])  # id_eal
            list_parameter_db_flight_block.append(row[30])  # id_egi
            list_parameter_db_flight_block.append(row[31])  # id_shp
            list_parameter_db_flight_block.append(row[32])  # ssh
            list_parameter_db_flight_block.append(row[33])  # gpa
            list_parameter_db_flight_block.append(row[34])  # id_wae
            list_parameter_db_flight_block.append(row[35])  # wal
            list_parameter_db_flight_block.append(row[36])  # was
            list_parameter_db_flight_block.append(row[37])  # id_process_st
            list_parameter_db_flight_block.append(row[38])  # points by footprint side
            list_parameter_db_flight_block.append(row[39])  # id_mounting_type
            list_parameter_db_flight_block.append(row[40])  # id_type_gimbel_mount
            list_parameter_db_flight_block.append(row[41])  # offset_omega
            list_parameter_db_flight_block.append(row[42])  # offset_phi
            list_parameter_db_flight_block.append(row[43])  # offset_kappa
            list_parameter_db_flight_block.append(row[54])  # av_height_obj
        con_db_project.close()  # cierra la base de datos
        return list_parameter_db_flight_block

    def get_project_header_data(self,
                                path_db_project):
        """
        Brief: obtiene los valores de cabecera de un proyecto almacenados en la base de datos
        :param path_db_project: path de la BD del proyecto
        :type path_db_project: str
        """

        conexion = self.connection_sqlite(path_db_project)
        cursor = conexion.cursor()

        str_sql = "SELECT * FROM project;"

        cursor.execute(str_sql)
        for row in cursor.fetchall():
            path_project_db = row[1]
            nemo = row[2]
            title = row[3]
            author = row[4]
            path_db_project_db = row[5]
            str_id_internal_crs_project = str(row[6])
            company = row[7]
            path_logo = row[8]
            path_logo_2 = row[9]

        conexion.close()  # se cierra la base de datos
        return path_project_db,\
               nemo,\
               title,\
               author,\
               path_db_project_db,\
               str_id_internal_crs_project,\
               company,\
               path_logo,\
               path_logo_2