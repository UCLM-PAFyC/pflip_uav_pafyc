# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PflipUav3
                                 A QGIS plugin
 Photogrammetric and Remote Sensing Flight Planning for unmanned aerial vehicle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-23
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernández López, PAFYC-UCLM
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# import PyQt5 libraries

# import QGIS libraries
from qgis.core import (Qgis, QgsGeometry, QgsCoordinateReferenceSystem, QgsDataSourceUri, QgsVectorLayer,
                       QgsProject, QgsFeature, QgsCoordinateTransform, QgsRectangle, QgsRasterBandStats, QgsPointXY,
                       QgsRaster)

# import self classes
from .. import config as c  # constants

# others imports
from math import *


class Qgis3ApiOperations():
    """
    Frecuent qgis API operations
    """
    def __init__(self,
                 iface):
        """
        Constructor class method
        :param iface: user interface QGIS
        :type iface: QgsInterface
        """
        self.iface = iface
        self.canvas = self.iface.mapCanvas()

    def buffer_to_entity(self,
                         path_db_sqlite,
                         name_table,
                         name_geom_column,
                         name_display_table,
                         id_entity_to_buffering,
                         distance,
                         segments,
                         end_cap_style,
                         join_style,
                         mitre_limit,
                         path_symbol_buffer_layer,
                         str_idinternal_crs_proyect):

        """
        Brief:
        segments: For round joins, number of segments to approximate quarter-circle
        end_cap_style: Round (1) / Flat (2) / Square (3) end cap style
        join_style = Round (1) / Mitre (inglete) (2) / Bevel (bisel) (3) join style
        mitre_limit = Limit on the mitre ratio used for very sharp corners
        """

        # 1.- obtiene geometría a partir de la cual se generará el buffer
        schema = ""
        uri = QgsDataSourceUri()
        uri.setDatabase(path_db_sqlite)
        uri.setDataSource(schema, name_table, name_geom_column)
        vlayer_source = QgsVectorLayer(uri.uri(),
                                       '%s' % name_display_table,
                                       'spatialite')

        entity_selected = vlayer_source.select(id_entity_to_buffering)  # genera geometría buffer

        for f in vlayer_source.selectedFeatures():
            geom_entity_selected = f.geometry()

        # 2.- Create a memory layer to store the result
        name_layer = c.CONST_PFLIPUAV_LAYER_BUFFER + " - " + str(distance) + " m"

        int_id_internal_crs_project = int(str_idinternal_crs_proyect)
        qgs_coordinate_crs_project = QgsCoordinateReferenceSystem(int_id_internal_crs_project,
                                                                  QgsCoordinateReferenceSystem.InternalCrsId)
        str_epsg_code_project = qgs_coordinate_crs_project.authid()
        type_geom_with_epsg_code = "Polygon?crs=" + str_epsg_code_project

        vlayer_target_mem_layer = QgsVectorLayer(type_geom_with_epsg_code,
                                                 name_layer,
                                                 "memory")
        # vlayer_target_mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", "temp_layer", "memory")

        if not vlayer_target_mem_layer.isValid():
            raise Exception("Failed to create memory layer")
            return

        vlayer_target_mem_layer_provider = vlayer_target_mem_layer.dataProvider()
        QgsProject.instance().addMapLayer(vlayer_target_mem_layer)

        # 3.- Obtiene geometría buffer

        # Returns a buffer region around this geometry having the given width and with a specified number of segments used to approximate curves.
        # geom_buffer_to_entity_selected = geom_entity_selected.buffer(distance,segments)

        # Returns a buffer region around the geometry, with additional style options. needs GEOS >= 3.3 - otherwise always returns 0
        geom_buffer_to_entity_selected = geom_entity_selected.buffer(distance,
                                                                     segments,
                                                                     end_cap_style,
                                                                     join_style,
                                                                     mitre_limit)
        feature_buffer = QgsFeature()
        feature_buffer.setGeometry(geom_buffer_to_entity_selected)

        # 4.- Carga la capa en QGIS
        """
        vlayer_target_mem_layer_provider.addFeatures([feature_buffer])
        vlayer_target_mem_layer.loadNamedStyle(path_symbol_buffer_layer)
        vlayer_target_mem_layer.updateExtents()
        #self.vlayer.setCacheImage(None)
        self.iface.layerTreeView().refreshLayerSymbology(vlayer_target_mem_layer.id())
        #zoom a la entidad seleccionada
        #box = feature_buffer.boundingBoxOfSelected()
        #box.scale(1.05)
        #self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        """

        #TODO: cargar capa at the top
        vlayer_target_mem_layer_provider.addFeatures([feature_buffer])

        root = QgsProject.instance().layerTreeRoot()
        QgsProject.instance().addMapLayer(vlayer_target_mem_layer, False)
        root.insertLayer(0,vlayer_target_mem_layer) # carga la capa at the top

        # añade simbología
        vlayer_target_mem_layer.loadNamedStyle(path_symbol_buffer_layer)
        self.iface.layerTreeView().refreshLayerSymbology(vlayer_target_mem_layer.id())

        # zoom factor 1.2
        vlayer_target_mem_layer.updateExtents()
        box = vlayer_target_mem_layer.extent()
        box.scale(1.2)
        self.canvas.setExtent(box)
        self.canvas.refresh()

    def check_rlayer_contains_vector_zone(self,
                                          qgsrlayer,
                                          geom_vector_zone,
                                          scale_factor_bb_zone=1.0):
        bool_rlayer_contains_vector_zone = False
        qgsrect_rlayer = qgsrlayer.extent()
        qgsrect_bb_vector_zone = geom_vector_zone.boundingBox()
        if scale_factor_bb_zone > 1.0:
            qgsrect_bb_vector_zone.scale(scale_factor_bb_zone)
        if qgsrect_rlayer.contains(qgsrect_bb_vector_zone):
            bool_rlayer_contains_vector_zone = True
        return bool_rlayer_contains_vector_zone

    def control_dtm(self,
                    qgs_raster_layer,
                    str_epsg_crs_project):
        """
        Brief: realiza una serie de controles sobre el DTM
                + Comprueba la validez del QgsRasterLayer
                + Comprueba que el número de bandas sea 1
                + Obtiene los metadatos del CRS del DTM
                + carga en el lineEdit el path normalizado
        """
        # Check validate QgsRasterLayer
        if not qgs_raster_layer.isValid():
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Raster layer %s is not valid " % qgs_raster_layer.source(),
                                                Qgis.Critical,
                                                20)
            return False

        # Check monoband
        number_of_bands = qgs_raster_layer.bandCount()
        if number_of_bands > 1:
            str_msg = "DTM raster layer is not monoband"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            return False

        # Check CRS project = CRS qgs raster layer
        str_postgisSrid_crs_dtm = str(qgs_raster_layer.crs().postgisSrid())

        if str_epsg_crs_project != str_postgisSrid_crs_dtm:
            str_msg = "CRS project [%s] and CRS DTM raster layer [%s] are different" % (str_epsg_crs_project,
                                                                                       str_postgisSrid_crs_dtm)
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            return False

        # check exist no data value
        qgsrect_rlayer = qgs_raster_layer.extent()
        qgsrlayer_dataprovider = qgs_raster_layer.dataProvider()
        rows = qgs_raster_layer.rasterUnitsPerPixelY()
        cols = qgs_raster_layer.rasterUnitsPerPixelX()

        qgsraster_block = qgsrlayer_dataprovider.block(number_of_bands,
                                                       qgsrect_rlayer,
                                                       round(rows),
                                                       round(cols))
        bool_has_no_data_value = qgsraster_block.hasNoDataValue()
        if not bool_has_no_data_value:
            str_msg = "DTM raster layer hasn`t no data value"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            return False
        return True

    def get_crs_vector_layer(self,
                             path_db_sqlite,
                             name_table,
                             name_geom_column,
                             name_display_table):
        """
        Brief: Obtiene el CRS interno de una capa vectorial. Utilizado en la función del planificación.
        :param path_db_sqlite: path de la BD sqlite
        :type path_db_sqlite: str
        :param name_table: nombre de la tabla espacial sobre la que se realiza la consulta
        :type name_table: str
        :param name_geom_column: nombre de la columna de geometría
        :type name_geom_column: str
        :param name_display_table: nombre de la visualización de la tabla en la toc
        :type name_display_table: str
        :return: CRS interno en formato InternalCrsId de la capa vectorial consultada
        :rtype: str
        """

        schema = ""
        uri = QgsDataSourceUri()
        uri.setDatabase(path_db_sqlite)
        uri.setDataSource(schema, name_table, name_geom_column)

        vlayer = QgsVectorLayer(uri.uri(),
                                '%s' % name_display_table,
                                'spatialite')
        qgs_crs = vlayer.crs()  # Returns layer's spatial reference system. QgsCoordinateReferenceSystem
        int_InternalCrsId_code = qgs_crs.srsid()  # Get the SrsId - if possible. Devuelve un tipo long
        str_InternalCrsId_code = str(int_InternalCrsId_code)
        return str_InternalCrsId_code

    def get_domain_values_from_rlayer_zone(self,
                                           rlayer,
                                           min_x_dtm,
                                           min_y_dtm,
                                           max_x_dtm,
                                           max_y_dtm,
                                           int_crs_postgisSrid_source,
                                           int_crs_postgisSrid_target):
        """
        Brief: Obtiene los estadísticos min_value y max_value de una zona de una banda de una raster layer
                (con transformación de coordenadas) (Antigua función get_statistics_from_rlayer_zone)
        :param rlayer: Capa raster entera
        :type: QgsRasterLayer
        :param min_x_dtm: coordenada x_min del zona
        :type: float
        :param max_x_dtm: coordenada x_max del zona
        :type: float
        :param min_y_dtm: coordenada y_min del zona
        :type: float
        :param max_y_dtm: coordenada y_max del zona
        :type: float
        :param int_crs_postgisSrid_source: código EPSG del CRS origen
        :type: int
        :param int_crs_postgisSrid_target: código EPSG del CRS destino
        :type: int
        :return: valor mínimo y valor máximo de la zona delimitada por (x_min, y_min) y (x_max,y_max)
        :rtype: float
        """
        # definición del objeto QgsRectangle
        rectangle = QgsRectangle()

        qgs_point_min_coodinates = self.transform_point_coordinates(min_x_dtm,
                                                                    min_y_dtm,
                                                                    int_crs_postgisSrid_source,
                                                                    int_crs_postgisSrid_target)

        if qgs_point_min_coodinates == -1.0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Error transform coordinates qgs_point_min_coodinates",
                                                Qgis.Critical,
                                                10)
            return -1.0

        qgs_point_max_coodinates = self.transform_point_coordinates(max_x_dtm,
                                                                    max_y_dtm,
                                                                    int_crs_postgisSrid_source,
                                                                    int_crs_postgisSrid_target)

        if qgs_point_max_coodinates == -1.0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Error transform coordinates qgs_point_max_coodinates",
                                                Qgis.Critical,
                                                10)
            return -1.0

        min_x_dtm_transform = qgs_point_min_coodinates.x()
        min_y_dtm_transform = qgs_point_min_coodinates.y()
        max_x_dtm_transform = qgs_point_max_coodinates.x()
        max_y_dtm_transform = qgs_point_max_coodinates.y()

        #TODO: comprobar que (x_min, y_min) y (x_max,y_max) están dentro de la zona

        rectangle.setXMinimum(min_x_dtm_transform)
        rectangle.setXMaximum(max_x_dtm_transform)
        rectangle.setYMinimum(min_y_dtm_transform)
        rectangle.setYMaximum(max_y_dtm_transform)

        band_statistics = rlayer.dataProvider().bandStatistics(1,
                                                               QgsRasterBandStats.All,
                                                               rectangle,
                                                               0)
        min_value = band_statistics.minimumValue
        max_value = band_statistics.maximumValue

        return min_value, max_value

    def get_list_vertex_by_id_entity(self,
                                     path_db_sqlite,
                                     name_table,
                                     name_geom_column,
                                     name_display_table,
                                     str_id_entity):
        """
        Brief: obtiene una lista de vertices de una geometría de una entidad por su identificador interno en la base
                de datos sqlite.
        :param path_db_sqlite: path de la BD del proyecto PLIPUAV
        :type path_db_sqlite: str
        :param name_table: nombre de la tabla
        :type name_table: str
        :param name_geom_column: nombre de la columna de geometría
        :type name_geom_column: str
        :param name_display_table: nombre a visualizar en la toc
        :type name_display_table: str
        :param str_id_entity: identificador de la entidad a consultar
        :type str_id_entity: str
        :return: lista del tipo [(576060,4.32267e+06), (576268,4.32277e+06), (576248,4.32283e+06), (576115,4.32288e+06), (576418,4.32289e+06)]
        :rtype: list
        """
        # conexión a la capa SpatiaLite
        schema = ""
        uri = QgsDataSourceUri()
        uri.setDatabase(path_db_sqlite)
        uri.setDataSource(schema, name_table, name_geom_column)
        vlayer = QgsVectorLayer(uri.uri(),
                                '%s' % name_display_table,
                                'spatialite')

        # selección de la entidad con código interno de QGIS pasado en la función
        int_id_entity = int(str_id_entity)
        entity_selected = vlayer.select(int_id_entity)

        for feature in vlayer.getFeatures():
            id_current = feature.id()
            if id_current == int_id_entity:
                geom = feature.geometry()  # obtención de la geometría del elemento seleccionado

                # En función del tipo de geometría devolver la lista correspondiente
                if (name_table == c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT):
                    list_vertex = geom.asPoint()
                if (name_table == c.CONST_PFLIPUAV_LAYER_LANDING_POINT):
                    list_vertex = geom.asPoint()
                if (name_table == c.CONST_PFLIPUAV_LAYER_VECTOR):
                    list_vertex = geom.asPolyline()
                if (name_table == c.CONST_PFLIPUAV_LAYER_ZONE):
                    list_vertex = geom.asPolygon()
                if (name_table == c.CONST_PFLIPUAV_LAYER_AXIS):
                    list_vertex = geom.asPolyline()
                break

        return list_vertex

    def get_strcrscode_InternalCrsId2authid(self,
                                            str_InternalCrsId_code):
        """
        Brief: obtiene cadena de texto del código CRS a partir de cadena de texto del código InternalCrsId
        :param str_InternalCrsId_code: cadena de texto con el código CRS en formato InternalCrsId
        :type str_InternalCrsId_code: str
        :return: cadena de texto con el código CRS en formato authid del tipo "EPSG:23839" incluyendo el EPSG
        :rtype: str
        """
        int_InternalCrsId_code = int(str_InternalCrsId_code)
        qgs_crs = QgsCoordinateReferenceSystem(int_InternalCrsId_code,
                                               QgsCoordinateReferenceSystem.InternalCrsId)
        str_authid_code = qgs_crs.authid()
        return str_authid_code

    def get_strcrscode_InternalCrsId2PostgisCrsId(self,
                                                  str_InternalCrsId_code):
        """
        brief: obtiene cadena de texto del código CRS EPSG a partir de cadena de texto del código InternalCrsId
        :param str_InternalCrsId_code: código CRS en formato InternalCrsId
        :type str_InternalCrsId_code: str
        :return: cadena de texto con el código CRS en formato postgisSrid
        :rtype: str
        """
        int_InternalCrsId_code = int(str_InternalCrsId_code)
        qgs_crs = QgsCoordinateReferenceSystem(int_InternalCrsId_code, QgsCoordinateReferenceSystem.InternalCrsId)
        int_PostgisCrsId_code = qgs_crs.postgisSrid()  # Get the postgis srid for this srs
        str_PostgisCrsId_code = str(int_PostgisCrsId_code)
        return str_PostgisCrsId_code

    def get_value_from_raster_file(self,
                                   rlayer,
                                   x,
                                   y):
        """
        Brief:  obtiene el valor de un píxel a partir de las coordenadas de un punto dado (especificando su CRS)
                sobre capa raster (sin interpolar).
        :param rlayer:  capa raster con el DTM o geoide. Nota: el CRS de esta capa siempre será 4326
        :type rlayer:   QgsRasterLayer
        :param x:       coordenada X del punto a interpolar
        :type x:        float
        :param y:       coordenada Y del punto a interpolar
        :type y:        float
        :return:        valor del punto sobre el DTM o geoide. Si hay algún problema devuelve -1.0
        :rtype:         float
        """
        q_point_4326 = QgsPointXY(x,y)
        # comprueba si el punto está dentro de la rlayer
        if rlayer.extent().contains(q_point_4326):
            ident = rlayer.dataProvider().identify(q_point_4326,
                                                   QgsRaster.IdentifyFormatValue)
            if ident.isValid():
                values = ident.results()
                elevation = values[1]
                return elevation
            else:
                self.iface.messageBar().pushMessage(c.CONST_GEOFLIP_TITLE,
                                                    "Invalid identification",
                                                    Qgis.Critical,
                                                    10)
                return -1.0
        else:
            str_msg = "Error in function get_value_from_raster_file. Point "
            str_msg += "(" + str(q_point_4326.x()) + "," + str(q_point_4326.y()) + ") "
            str_msg += "out extents of raster layer"
            self.iface.messageBar().pushMessage(c.CONST_GEOFLIP_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            #TODO: zoom al punto donde falla
            return -1.0

    def get_value_from_raster_file_interpolation(self,
                                                 rlayer,
                                                 x,
                                                 y,
                                                 int_point_crs_postgisSrid):
        """
        Brief: obtiene el valor de un píxel a partir de las coordenadas de un punto dado (especificando su CRS)
                sobre capa raster (interpolando).
        :param rlayer: capa raster con el DTM o geoide. Nota: el CRS de esta capa siempre será 4326
        :type rlayer: QgsRasterLayer
        :param x: coordenada X del punto a interpolar
        :type x: float
        :param y: coordenada Y del punto a interpolar
        :type y: float
        :param int_point_crs_postgisSrid: Código postgisSrid del CRS del punto
        :type int_point_crs_postgisSrid: int
        :return: valor interpolado del punto sobre el DTM o geoide. Si hay algún problema devuelve -1.0
        :rtype: float
        """
        # si el no data value es 0 y en el punto no hay valor se toma 0

        no_data_value_is_0 = False
        # check exist no data value
        qgsrect_rlayer = rlayer.extent()
        qgsrlayer_dataprovider = rlayer.dataProvider()
        rows = rlayer.rasterUnitsPerPixelY()
        cols = rlayer.rasterUnitsPerPixelX()

        qgsraster_block = qgsrlayer_dataprovider.block(1, # number_of_bands
                                                       qgsrect_rlayer,
                                                       round(rows),
                                                       round(cols))
        bool_has_no_data_value = qgsraster_block.hasNoDataValue()
        if bool_has_no_data_value:
            no_data_value = qgsraster_block.noDataValue()
            if abs(no_data_value) < 0.5:
                no_data_value_is_0 = True

        #int_rlayer_crs_postgisSrid = 4326
        int_rlayer_crs_postgisSrid = rlayer.crs().postgisSrid()

        if int_rlayer_crs_postgisSrid == int_point_crs_postgisSrid: # no se realiza transformación de coordenadas
            x_point_in_crs_rlayer = x
            y_point_in_crs_rlayer = y
        else: #se realiza la transformación
            qpoint_transformado = self.transform_point_coordinates(x,
                                                                   y,
                                                                   int_point_crs_postgisSrid,
                                                                   int_rlayer_crs_postgisSrid)

            if qpoint_transformado == -1.0:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Error transform coordinates",
                                                    Qgis.Critical,
                                                    10)
                #TODO: zoom al punto donde falla?
                return -1.0

            x_point_in_crs_rlayer = qpoint_transformado.x()
            y_point_in_crs_rlayer = qpoint_transformado.y()

        step_x_rlayer = rlayer.rasterUnitsPerPixelX()  # debe ser positivo
        step_y_rlayer = - rlayer.rasterUnitsPerPixelY()  # debe ser negativo
        #rows = rlayer.height()
        #columns = rlayer.width()
        rectagle_extent_rlayer = rlayer.dataProvider().extent()
        x_minimum_rlayer = rectagle_extent_rlayer.xMinimum()
        #y_minimum_dtm = rectagle_extent_rlayer.yMinimum()
        #x_maximum_dtm = rectagle_extent_rlayer.xMaximum()
        y_maximum_rlayer = rectagle_extent_rlayer.yMaximum()

        dbl_column = (x_point_in_crs_rlayer - x_minimum_rlayer) / step_x_rlayer
        dbl_row = (y_point_in_crs_rlayer - y_maximum_rlayer) / step_y_rlayer
        inc_column = dbl_column - floor(dbl_column)
        inc_row = dbl_row - floor(dbl_row)

        f00 = self.get_value_from_raster_file(rlayer, x_point_in_crs_rlayer, y_point_in_crs_rlayer)
        f10 = self.get_value_from_raster_file(rlayer, x_point_in_crs_rlayer + step_x_rlayer, y_point_in_crs_rlayer)
        f01 = self.get_value_from_raster_file(rlayer, x_point_in_crs_rlayer, y_point_in_crs_rlayer + step_y_rlayer)
        f11 = self.get_value_from_raster_file(rlayer, x_point_in_crs_rlayer + step_x_rlayer, y_point_in_crs_rlayer + step_y_rlayer)

        if not f00 and no_data_value_is_0:
            f00 = 0.0
        if not f10 and no_data_value_is_0:
            f10 = 0.0
        if not f01 and no_data_value_is_0:
            f01 = 0.0
        if not f11 and no_data_value_is_0:
            f11 = 0.0

        result = (1.0 - inc_row) * (1.0 - inc_column) * f00
        result += inc_column * (1.0 - inc_row) * f10
        result += (1.0 - inc_column) * inc_row * f01
        result += inc_column * inc_row * f11

        return result

    def get_wkt_geom_by_feature_id(self,
                                   path_db_sqlite,
                                   name_table,
                                   name_geom_column,
                                   name_display_table,
                                   id_entity):
        """
        Brief: obtiene la cadena wkt de una geometría filtrada por su identificador interno dado
        :param path_db_sqlite: path de la base de datos sqlite
        :type path_db_sqlite: str
        :param name_table: nombre de la tabla
        :type name_table: str
        :param name_geom_column: nombre de la columna de geometría
        :type name_geom_column: str
        :param name_display_table: nombre de la tabla a visualizar
        :type name_display_table: str
        :param id_entity: identificador interno de la geometría
        :type id_entity: int
        :return: cadena WKT de la entidad con el identificador interno facilitado
        :rtype: str
        """
        schema = ""
        uri = QgsDataSourceUri()
        uri.setDatabase(path_db_sqlite)
        uri.setDataSource(schema,
                          name_table,
                          name_geom_column)

        vlayer = QgsVectorLayer(uri.uri(),
                                '%s' % name_display_table,
                                'spatialite')

        iter = vlayer.getFeatures()
        for feature in iter:
            str_current_id = feature.id()
            if (str_current_id == id_entity):
                geom = feature.geometry()
                str_wkt_geom = geom.asWkt()
                return str_wkt_geom

        #TODO: control de errores

    def load_to_qgis(self,
                     is_spatial,
                     db_path,
                     name_table,
                     name_geom_column,
                     path_qml_simbology,
                     node_group):
        """
        Brief: Carga tabla espacial o no espacial en qgis. Basado en función de Classes.Table QSpatiaLite
        :param is_spatial: [geo: true - tabla espacial, false - tabla alfanumérica]
        :type is_spatial: bool
        :param db_path: path de la bd spatialite
        :type db_path: str
        :param name_table: nombre de la tabla de la bd a cargar
        :type name_table: str
        :param name_geom_column: nombre de la columna de geometría para capas espaciales
        :type name_geom_column: str
        :param path_qml_simbology: path del fichero qml con la simbología
        :type path_qml_simbology: str
        :param node_group: nodo del grupo donde se quiere añadir la capa gis
        """
        display_name_table = name_table  # como se mostrará en el TOC

        if is_spatial == False:
            layer_no_geometry = QgsVectorLayer('dbname="%s" table="%s"' % (db_path, name_table),
                                               '%s' % display_name_table,
                                               'spatialite')
            if len(path_qml_simbology) > 0:
                layer_no_geometry.loadNamedStyle(path_qml_simbology)
                layer_no_geometry.triggerRepaint()
                self.iface.layerTreeView().refreshLayerSymbology(layer_no_geometry.id())

            QgsProject.instance().addMapLayer(layer_no_geometry)
        else:
            uri = QgsDataSourceUri()
            uri.setDatabase(db_path)
            schema = ""
            table = name_table
            geom_column = name_geom_column
            uri.setDataSource(schema, table, geom_column)
            vlayer = QgsVectorLayer(uri.uri(),
                                    '%s' % display_name_table,
                                    'spatialite')

            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer, False)
                node_layer1 = node_group.addLayer(vlayer)

                if len(path_qml_simbology) > 0:
                    vlayer.loadNamedStyle(path_qml_simbology)
                    vlayer.updateExtents()
                    vlayer.triggerRepaint()
                    self.iface.layerTreeView().refreshLayerSymbology(vlayer.id())

            else:
                str_msg = "Failed to load table spatial " + name_table
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Critical,
                                                    10)
                return

    def load_to_qgis_output_layer_filtered(self,
                                           path_db_project,
                                           node_group_output,
                                           layer,
                                           path_simbology,
                                           geom_field_name,
                                           cod_flight_block):
        """
        Brief: Carga capas de salida sin tener que crear vistas espaciales. Además, hace un zoom a la zona
        :param path_db_project: path de la BD del proyecto PLIPUAV
        :type path_db_project: str
        :param node_group_output: nodo del grupo donde se colgará la capa de salida
        :type node_group_output:
        :param layer: nombre de la capa a cargar
        :type layer: str
        :param path_simbology: ruta de la simbología
        :type path_simbology: str
        :param geom_field_name: nombre del campo que contiene la geometría
        :type geom_field_name: str
        :param cod_flight_block: código de bloque de vuelo para filtrar la salida
        :type cod_flight_block: str
        """
        uri = QgsDataSourceUri()
        uri.setDatabase(path_db_project)
        schema = ""
        filter = "cod_flight_block = '" + cod_flight_block + "'"
        uri.setDataSource(schema,
                          layer,
                          geom_field_name,
                          filter)

        label_display_legend = layer + " - " + cod_flight_block

        vlayer = QgsVectorLayer(uri.uri(),
                                label_display_legend,
                                'spatialite')

        if vlayer.isValid():
            QgsProject.instance().addMapLayer(vlayer, False)
            node_layer1 = node_group_output.addLayer(vlayer)
            vlayer.loadNamedStyle(path_simbology)
            self.iface.layerTreeView().refreshLayerSymbology(vlayer.id())
            vlayer.updateExtents()
            box = vlayer.extent()
            box.scale(1.5)
            self.canvas.setExtent(box)
            self.canvas.refresh()

    def metadata_crs_object(self,
                            str_id_internal):
        """
        Brief: obtiene los metadatos de un objeto QgsCoordinateReferenceSystem a partir de su código interno
        :param str_id_internal: código interno del CRS
        :type str_id_internal: str
        :return: cadena de texto con los metadatos del CRS
        :rtype: str

        """
        int_id_internal = int(str_id_internal)
        qgs_crs = QgsCoordinateReferenceSystem(int_id_internal,
                                               QgsCoordinateReferenceSystem.InternalCrsId)

        # formateo de la salida
        str_msg = "Internal QGIS CRS Id: " + str(qgs_crs.srsid())
        str_msg += ", PostGIS SRID: " + str(qgs_crs.postgisSrid())
        str_msg += ", EPSG ID: " + qgs_crs.authid() + "\n"
        str_msg += "Description: " + qgs_crs.description()
        str_msg += ", Projection Acronym: " + qgs_crs.projectionAcronym()
        str_msg += ", Ellipsoid Acronym: " + qgs_crs.ellipsoidAcronym() + "\n"
        str_msg += "Proj4 String: " + qgs_crs.toProj4() + "\n"
        # check whether it’s geographic or projected coordinate system
        str_msg += "Is geographic:" + str(qgs_crs.isGeographic())
        # check type of map units in this CRS (values defined in QGis::units enum)
        str_msg += ", Map units:" + str(qgs_crs.mapUnits()) + "\n"
        return str_msg

    def remove_group_gis_layers(self,
                                str_name_group):
        """
        Brief: elimina un grupo de capas de la TOC
        :param str_name_group: nombre del grupo
        :type str_name_group: str
        """
        # Return pointer to the root (invisible) node of the project's layer tree
        root = QgsProject.instance().layerTreeRoot()

        # Find group node with specified name. Searches recursively the whole sub-tree. Devuelve un QgsLayerTreeGroup
        qgs_layer_tree_group_to_remove = root.findGroup(str_name_group)

        if qgs_layer_tree_group_to_remove is not None:
            # Remove a child node from this group. The node will be deleted.
            root.removeChildNode(qgs_layer_tree_group_to_remove)

    def transform_point_coordinates(self,
                                    x_source,
                                    y_source,
                                    int_crs_postgisSrid_source,
                                    int_crs_postgisSrid_target):
        """
        Brief: transformación de coordenadas de un punto
        :param x_source: coordenada X origen
        :type x_source: float
        :param y_source: coordenada Y origen
        :type y_source: float
        :param int_crs_postgisSrid_source: código EPSG origen
        :type int_crs_postgisSrid_source: int
        :param int_crs_postgisSrid_target: código EPSG destino
        :type int_crs_postgisSrid_target: int
        :return: Punto transformado
        :rtype: QgsPoint o -1.0 si hay error en la transformación
        """
        try:
            qgsCRS_crs_source = QgsCoordinateReferenceSystem(int_crs_postgisSrid_source)
            qgsCRS_crs_target = QgsCoordinateReferenceSystem(int_crs_postgisSrid_target)
            #SEE: https://qgis.org/pyqgis/3.2/core/Coordinate/QgsCoordinateTransform.html
            xform = QgsCoordinateTransform(qgsCRS_crs_source,
                                           qgsCRS_crs_target,
                                           QgsProject.instance()) # definición de la transformación
            qpoint_transform = xform.transform(x_source,
                                               y_source)  # forward transformation: src -> dest
            return qpoint_transform
        except:
            str_msg = "Failed coordinates transformation. "
            str_msg += "Point (" + str(x_source) + "," + str(y_source) + "). "
            str_msg += "CRS source: " + str(int_crs_postgisSrid_source)
            str_msg += "CRS target: " + str(int_crs_postgisSrid_source)
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Failed coordinates transformation",
                                                Qgis.Critical,
                                                10)
            return -1.0

    def zoom_to_entity(self,
                       path_db_sqlite,
                       name_table,
                       name_geom_column,
                       name_display_table,
                       id_entity):
        """
        Brief: realiza un zoom a la entidad indicada en el argumento
        :param path_db_sqlite: path de la BD sqlite
        :type path_db_sqlite: str
        :param name_table: nombre de la tabla espacial
        :type name_table: str
        :param name_geom_column: nombre del campo de geometría
        :type name_geom_column: str
        :param name_display_table: nombre de la visualización en la toc
        :type name_display_table: str
        :param id_entity: identificador gid de la entidad geográfica
        :type id_entity: int
        """

        # crea la capa vetorial
        display_name_table = name_display_table
        schema = ""
        uri = QgsDataSourceUri()
        uri.setDatabase(path_db_sqlite)
        uri.setDataSource(schema, name_table, name_geom_column)

        vlayer = QgsVectorLayer(uri.uri(),
                                '%s' % display_name_table,
                                'spatialite')

        # zoom a la entidad seleccionada
        entity_selected = vlayer.select(id_entity)
        box = vlayer.boundingBoxOfSelected()
        box.scale(1.20)
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()