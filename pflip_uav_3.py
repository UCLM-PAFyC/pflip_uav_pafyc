# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PflipUav3
                                 A QGIS plugin
 Photogrammetric and Remote Sensing Flight Planning for unmanned aerial vehicle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-23
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernández López, PAFYC-UCLM
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import (QSettings, QTranslator, QCoreApplication, Qt, QVariant)
from PyQt5.QtGui import (QIcon, QColor)
from PyQt5.QtWidgets import (QAction, QMessageBox, QComboBox, QFileDialog, QDialog)
from PyQt5 import QtSql
from osgeo import osr,gdal
from osgeo.gdalconst import *
from qgis.core import (QgsMessageLog, QgsProject, QgsRasterLayer, QgsField, QgsDataSourceUri, QgsVectorFileWriter,
                       QgsColorRampShader, QgsSingleBandPseudoColorRenderer, QgsRasterShader, QgsMapLayerProxyModel,
                       QgsGeometryUtils, QgsCoordinateReferenceSystem, QgsVectorLayer, QgsFeature, QgsPointXY,
                       QgsGeometry, QgsPoint, QgsApplication, QgsDataSourceUri, Qgis)
from .resources import *
from .pflip_uav_3_dialog import PflipUav3Dialog
import math
import os.path
import shutil
import zipfile
from shutil import *
import csv
import sys
from PyQt5.QtCore import QFileInfo, QDir, QObject
from qgis.core import QgsApplication
# sys.path.append("C:\Program Files\JetBrains\PyCharm 2018.3.3\debug-eggs\pycharm-debug.egg") # dhl
# sys.path.append("C:\Program Files\JetBrains\PyCharm 2020.3\debug-eggs\pydevd-pycharm.egg") # dhl
# sys.path.append("C:\Program Files\JetBrains\PyCharm 2023.2\debug-eggs\pydevd-pycharm.egg") # dhl
# import pydevd

from osgeo import osr
projVersionMajor = osr.GetPROJVersionMajor()
# projVersionMinor = osr.GetPROJVersionMinor()
pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
pluginPath = os.path.dirname(os.path.realpath(__file__))
pluginPath = os.path.join(pluginsPath, pluginPath)
sys.path.append(pluginPath)
#os.environ["PATH"] += os.pathsep + libCppPath

qgis_version_number_str = Qgis.QGIS_VERSION.split('-')[0]
qgis_version_first_number = int(qgis_version_number_str.split('.')[0])
qgis_version_second_number = int(qgis_version_number_str.split('.')[1])
qgis_version_third_number = int(qgis_version_number_str.split('.')[2])
qgis_version_second_number_change_buffer_parameters = 20
from . import config as c  # constants
from .classes.db_operations import *
from .classes.qgis3_api_operations import Qgis3ApiOperations
from .planning import planning

# import self QDialogs
from .ui.about_qdialog import AboutQDialog
from .ui.add_camera_dlg import addCameraDlg  # panel nueva camara
from .ui.add_flight_block_dlg import addFlightBlockDlg  # panel código de bloque de vuelo
from .ui.generate_dtm_srtm_dlg import generateDtmSrtm
from .ui.generate_mosaic_images_dlg import generateMosaicImages
from .ui.parameters_print_map import parametersPrintMap
from .ui.progress_dialog_dlg import progressDialogDlg
from .ui.project_data import Projectdata
from .ui.qutline_dlg import QutlineTool
from .ui.update_camera_dlg import updateCameraDlg  # panel editar camara
from .ui.update_project_data import editProjectData  # panel edit proyecto
from .ui.virtual_slope_dtm_tool import VirtualSlopeDtmTool

from .PyGeodesy.GeodeticCalculations.geodetic_calculations import *

"""
from classes.progress_dialog import *
#from mdtFromAsciiFile.mdt_from_ascii_file import *
from mdtConstanAltitude.mdt_constant_altitude import *
from mdtFromDxfFile.mdt_from_dxf_file import *
"""

class PflipUav3:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # pydevd.settrace('localhost',port=54100,stdoutToServer=True,stderrToServer=True)

        # Save reference to the QGIS interface
        self.iface = iface
        self.projVersionMajor = projVersionMajor

        self.path_plugin = pluginPath

        # initialize plugin directory
        self.path_plugin = os.path.dirname(__file__)
        str_msg_log = "Path plugin: " + self.path_plugin
        QgsMessageLog.logMessage(str_msg_log,
                                 c.CONST_PFLIPUAV_TITLE,
                                 Qgis.Info)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.path_plugin,
            'i18n',
            'PflipUav3_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&PFliP-UAV (Photogrammetric Flight Planning for Unmanned Aerial Vehicle)')

        # qsettings: fichero que almacena los últimos valores introducidos por el usuario en la aplicación en anteriores sesiones
        str_path_file_qsettings = self.path_plugin + '/templates/qsettings.ini'
        self.my_qsettings = QSettings(str_path_file_qsettings,
                                      QSettings.IniFormat)

        self.db_op = DbOperations(self.iface)  # new db operations
        self.q3_api_op = Qgis3ApiOperations(self.iface)

        QgsMessageLog.logMessage(str_msg_log,
                                 c.CONST_PFLIPUAV_TITLE,
                                 Qgis.Info)

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PflipUav3', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu,
                                       action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/pflip_uav_pafyc/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Photogrammetric Flight Planning for unmanned aerial vehicle'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&PFliP-UAV (Photogrammetric Flight Planning for Unmanned Aerial Vehicle)'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""
        if self.first_start == True:
            self.first_start = False
            self.ui = PflipUav3Dialog()
            self.initialize()
        self.ui.show()  # show the dialog

    def add_axis(self):
        """
        Brief: Añade un eje a la tabla en el caso de vuelos lineales
        """
        if self.ui.comboBox_segmentsAvailables.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Id. axis is required",
                                                level=Qgis.Critical)
            return

        str_id_axis = self.ui.comboBox_segmentsAvailables.currentText()

        # insert en la base datos
        str_query = "INSERT INTO flight_block_c_axis (cod_flight_block,id_axis) VALUES ('" + self.cod_flight_block_dlg + "'," + str_id_axis + ");"
        self.db_op.execute_query_old(self.path_db_project, str_query)

        self.fill_tableview_axis()

    def add_camera(self):
        """
        Brief: Levanta panel añadir un sensor nuevo
        """
        # vacia la lista que se pasa por referencia
        del self.lst_add_camera_dlg[:]

        path_csv_file_sensors = self.path_plugin + '/templates/sensors.csv'
        if not os.path.exists(path_csv_file_sensors):
            path_csv_file_sensors = None

        dlg_add_camera = addCameraDlg(self.iface,
                                      self.lst_add_camera_dlg,
                                      self.path_db_project,
                                      path_csv_file_sensors)

        # show the dialog
        dlg_add_camera.show()

        # Run the dialog
        result = dlg_add_camera.exec_()

        if len(self.lst_add_camera_dlg) > 0:
            # captura el código guardado en el panel
            new_camera_code = self.lst_add_camera_dlg[0]
            self.ui.comboBox_Camera.addItem(new_camera_code)

            # pone el combo en el índice recién introducido
            index_new_item = self.ui.comboBox_Camera.count() - 1
            self.ui.comboBox_Camera.setCurrentIndex(index_new_item)

        else:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Error while adding a camera ",
                                                Qgis.Critical,
                                                10)

    def add_flight_block(self):
        """
        brief: lanza panel para grabar código de bloque de vuelo, activa resto del panel si se ha grabado el código
                matricula en la bd del proyecto un nuevo bloque de vuelo, carga en QGIS la tabla,
                activa y rellena el combobox correspondiente,
        """
        # vacia la lista que se pasa por referencia
        del self.lst_flight_block_dlg[:]

        # elimina grupos capas GIS si existen
        self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_AUX_GIS_LAYERS)
        self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_GIS_LAYERS)
        self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_MEMORY_GIS_LAYERS)

        cod_mission_type = 0  # pendiente de definir

        # abre díalogo nuevo bloque de vuelo
        dlg_add_flight_block = addFlightBlockDlg(self.iface,
                                                 self.lst_flight_block_dlg,
                                                 self.path_db_project,
                                                 cod_mission_type)

        dlg_add_flight_block.show()  # show the dialog

        result = dlg_add_flight_block.exec_()  # Run the dialog

        # si el usuario ha grabado algún código de bloque de vuelo en el panel
        if len(self.lst_flight_block_dlg) > 0:
            # captura valores introducidos en el panel
            self.cod_flight_block_dlg = self.lst_flight_block_dlg[0]  # código de bloque de vuelo
            # entero con el tipo de mission: [1] - linear route; [2] - polygonal area; [3] - oblique shots; [4] - Polygonal area from linear route
            self.int_photogrammetric_mission_type = self.lst_flight_block_dlg[1]

            # insert en la base datos
            str_query = "INSERT INTO flight_block ("
            str_query += "cod_flight_block,"
            str_query += "id_fb_type,"
            str_query += "ac_gps,"
            str_query += "ac_kap,"
            str_query += "ac_omg,"
            str_query += "ac_phi,"
            str_query += "ascent_speed,"
            str_query += "descent_speed,"
            str_query += "end_height,"
            str_query += "foward_overlap,"
            str_query += "gpa,"
            str_query += "gsd,"
            str_query += "images_item,"
            str_query += "initial_height,"
            str_query += "lea,"
            str_query += "omega_angle,"
            str_query += "phi_angle,"
            str_query += "shot_interval,"
            str_query += "side_overlap,"
            str_query += "ssh,"
            str_query += "tol_gsd,"
            str_query += "wal,"
            str_query += "was,"
            str_query += "wpb,"  # Esta columna se está usando para Smooth_V
            str_query += "offset_omega,"
            str_query += "offset_phi,"
            str_query += "offset_kappa,"
            str_query += "av_height_obj) VALUES ("
            str_query += "'" + self.cod_flight_block_dlg + "',"
            str_query += str(self.int_photogrammetric_mission_type) + ","
            str_query += str(self.my_qsettings.value("default_value_ac_gps")) + ","
            str_query += str(self.my_qsettings.value("default_value_ac_kap")) + ","
            str_query += str(self.my_qsettings.value("default_value_ac_omg")) + ","
            str_query += str(self.my_qsettings.value("default_value_ac_phi")) + ","
            str_query += str(self.default_value_ascent_speed) + ","
            str_query += str(self.default_value_descent_speed) + ","
            str_query += str(self.my_qsettings.value("default_value_end_height")) + ","
            str_query += str(self.my_qsettings.value("default_value_foward_overlap")) + ","
            str_query += str(self.default_value_gpa) + ","
            str_query += str(self.my_qsettings.value("default_value_gsd")) + ","
            # se comenta esto que estaba mal. str_query += str(self.my_qsettings.value("default_value_end_height")) + ","  # default HBL = Landing_height
            str_images_item = self.ui.comboBox_numberOfPointsInSideFrame.currentText()
            str_query += str_images_item + ","
            str_query += str(self.my_qsettings.value("default_value_initial_height")) + ","
            if self.int_photogrammetric_mission_type == 1 or self.int_photogrammetric_mission_type == 3:  # vuelo lineal
                str_lineal_enlargement = str(0)
                self.ui.doubleSpinBox_linealEnlargement.setEnabled(False)
            else:
                str_lineal_enlargement = str(self.my_qsettings.value("default_value_lea"))
                self.ui.doubleSpinBox_linealEnlargement.setEnabled(True)

            str_query += str_lineal_enlargement + ","
            str_query += str(self.old_value_omega_angle) + ","
            str_query += str(self.old_value_phi_angle) + ","
            str_query += str(self.my_qsettings.value("default_value_shot_interval")) + ","
            str_query += str(self.my_qsettings.value("default_value_side_overlap")) + ","
            str_query += str(self.default_value_ssh) + ","
            str_query += str(self.my_qsettings.value("default_value_tol_gsd")) + ","
            str_query += str(self.default_value_wal) + ","
            str_query += str(self.default_value_was) + ","
            str_query += str(self.default_value_smooth_v) + ","
            str_query += str(self.my_qsettings.value("default_value_offset_omega")) + ","
            str_query += str(self.my_qsettings.value("default_value_offset_phi")) + ","
            str_query += str(self.my_qsettings.value("default_value_offset_kappa")) + ","
            str_query += str(self.my_qsettings.value("default_value_average_height_object"))
            str_query += ");"
            self.db_op.execute_query_old(self.path_db_project,
                                         str_query)

            # crea el directorio del bloque de vuelo en la estructura correspondiente
            str_directory_fb = self.current_path_project_directory + c.CONST_SEPARATOR_DIRECTORIES + self.cod_flight_block_dlg
            self.current_path_flight_block_directory = os.path.normcase(str_directory_fb)
            if not os.path.exists(self.current_path_flight_block_directory):
                os.makedirs(self.current_path_flight_block_directory)
            else:
                str_msg = "Directory " + str_directory_fb + " already exists"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Critical,
                                                    10)
                return

            # conforma el path de ficheros de resultados
            self.path_file_results = os.path.normcase(self.current_path_flight_block_directory + "\\" + "report_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".txt")  # path del fichero de resultados = cadena report_prj_
            self.path_file_results_csv = os.path.normcase(self.current_path_flight_block_directory + "\\" + "report_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".csv")  # path del fichero de resultados csv
            self.path_uav_navigation_file_name = os.path.normcase(self.current_path_flight_block_directory + "\\" + "WP_099_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg)  # path del fichero de navegación para ambos sentidos
            self.path_file_map_pdf = os.path.normcase(self.current_path_flight_block_directory + "\\" + "map_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".pdf")  # path del fichero con el mapa en formato pdf

            # inicializa widgets parámetros nuevo bloque de vuelo
            self.ui.lineEdit_pathDTM.clear()  # vacia el lineEdit del path del DTM
            self.ui.pushButton_RemoveFlightBlock.setEnabled(True)  # Activa el botón para poder borrar un bloque de vuelo creado

            self.ui.groupBox_CurrentFlightBlock.setVisible(True)  # hace visible el resto del panel

            # inicializa los dominios,pasos y default_values de los doubleSpinBox y spinBox que no dependen de valores de otros comboBox desde la base de datos plantilla
            self.initialize_domains_steps_from_db(self.path_db_project)

            self.ui.groupBox_CurrentFlightBlock.setEnabled(True)  # activa resto de formulario

            self.ui.groupBox_UAVNavigationParameters.setEnabled(True)
            self.ui.toolBox_currentFlightBlock.setEnabled(True)
            self.ui.toolButton_Planning.setEnabled(True)
            if self.int_photogrammetric_mission_type == 3:
                self.ui.toolButton_Planning.setToolTip("Prepare flight blocks")
                self.ui.toolButton_Planning.setIcon(QIcon(":/plugins/pflip_uav_pafyc/icons/kservices.png"))
            else:
                self.ui.toolButton_Planning.setToolTip("Process flight block")
                self.ui.toolButton_Planning.setIcon(QIcon(":/plugins/pflip_uav_pafyc/icons/processing.png"))

            self.ui.page_ProcessingResults.setEnabled(False)  # deshabilita resultado del procesamiento
            self.ui.toolButton_EditCamera.setEnabled(True)  # habilita funcionalidad de edición de los datos de una cámara
            self.ui.toolButton_RemoveCamera.setEnabled(True)  # habilita funcionalidad de eliminación de una cámara

            # inicializa vuelos LINEALES
            if self.int_photogrammetric_mission_type == 1:  # vuelo lineal *********************************************
                self.load_to_qgis_polygonal_layers()

                self.ui.groupBox_CurrentFlightBlock.setTitle(c.CONST_MISSION_TYPE_LINEAL)
                self.ui.label_linealEnlargement.setText("Lineal segments ext. (m):")
                self.ui.checkBox_removeImagesWithoutStereoscopy.setEnabled(False)
                self.ui.checkBox_removeImagesWithoutStereoscopy.setChecked(False)

                self.ui.groupBox_segmentsPaflr.setVisible(False)
                self.ui.groupBox_segmentsLinealMission.setVisible(True)
                self.ui.doubleSpinBox_bufferLinealFlight.setEnabled(True)  # habilita el widget del parámetro buffer
                self.ui.comboBox_idZone.setEnabled(False)
                self.ui.spinBox_nStrips.setEnabled(True)  # habilita spin number of strips
                if self.ui.spinBox_nStrips.value() > 1:
                    self.ui.pushButton_generateAxisStrips.setEnabled(True)
                    self.ui.comboBox_idVector.setEnabled(True)
                else:
                    self.ui.pushButton_generateAxisStrips.setEnabled(False)
                    self.ui.comboBox_idVector.setEnabled(False)

                self.ui.pushButton_showBuffer.setEnabled(True)  # habilita botón para mostrar el buffer en QGIS
                self.ui.doubleSpinBox_overlapSide.setEnabled(False)  # deshabilita el widget del parámetro side overlap
                self.ui.checkBox_fitAxis.setEnabled(True)  # habilita el checkbox de ajustar trayectoria a eje
                self.ui.toolButton_qutline.setEnabled(True)  # habilita qutline tool

            if self.int_photogrammetric_mission_type == 2:  # vuelo zonal **********************************************
                self.load_to_qgis_zonal_layers()

                self.ui.groupBox_CurrentFlightBlock.setTitle(c.CONST_MISSION_TYPE_ZONAL)
                self.ui.label_linealEnlargement.setText("Lineal zone ext. (m):")
                self.ui.checkBox_removeImagesWithoutStereoscopy.setEnabled(True)

                self.ui.groupBox_segmentsPaflr.setVisible(False)
                self.ui.groupBox_segmentsLinealMission.setVisible(True)
                self.ui.doubleSpinBox_bufferLinealFlight.setEnabled(False)
                self.ui.spinBox_nStrips.setEnabled(False)  # deshabilita spin number of strips
                self.ui.comboBox_idVector.setEnabled(True)
                self.ui.comboBox_idZone.setEnabled(True)
                self.ui.pushButton_generateAxisStrips.setEnabled(True)
                self.ui.pushButton_showBuffer.setEnabled(False)  # deshabilita botón para mostrar el buffer en QGIS
                self.ui.doubleSpinBox_overlapSide.setEnabled(True)
                self.ui.checkBox_fitAxis.setEnabled(False)  # deshabilita el checkbox de ajustar trayectoria a eje
                self.ui.toolButton_qutline.setEnabled(False)  # deshabilita qutline tool

            # Initialize Prepare flight blocks from lineal axis segmentation
            if self.int_photogrammetric_mission_type == 3:  # **********************************************************
                self.load_to_qgis_polygonal_layers()

                self.ui.groupBox_CurrentFlightBlock.setTitle(c.CONST_MISSION_TYPE_PREPARE_FLIGHT_BLOCKS)
                self.ui.label_linealEnlargement.setText("Lineal segments ext. (m):")

                self.ui.groupBox_segmentsPaflr.setVisible(True)
                self.ui.groupBox_segmentsLinealMission.setVisible(False)
                self.ui.doubleSpinBox_bufferLinealFlight.setEnabled(True)  # habilita el widget del parámetro buffer
                self.ui.spinBox_nStrips.setEnabled(True)  # habilita spin number of strips
                self.ui.pushButton_showBuffer.setEnabled(True)  # habilita botón para mostrar el buffer en QGIS
                self.ui.doubleSpinBox_overlapSide.setEnabled(False)  # deshabilita el widget del parámetro side overlap
                self.ui.checkBox_fitAxis.setEnabled(True)  # habilita el checkbox de ajustar trayectoria a eje
                self.ui.toolButton_qutline.setEnabled(True)  # habilita qutline tool

            # rellena combo flight block
            self.ui.comboBox_FlightBlock.setEnabled(True)
            self.fill_combo_nemo_flight_block(self.path_db_project)

            # pone el combo nemos bloque de vuelo en el índice del current fb
            value_compare = self.cod_flight_block_dlg
            str_sql = "SELECT cod_flight_block FROM flight_block ORDER by cod_flight_block ASC;"
            index_combo_new_fb = self.db_op.get_index_combo(self.path_db_project,
                                                            str_sql,
                                                            value_compare)
            self.ui.comboBox_FlightBlock.setCurrentIndex(index_combo_new_fb)

            self.link_firmware_cruised_speed = True  # variable para controlar la relacion entre versión firmware y cruised speed
            self.link_firmware_ascent_speed = True  # variable para controlar la relación entre versión firmware y ascent speed
            self.link_firmware_descent_speed = True  # variable para controlar la relación entre versión firmware y descent speed
            self.link_gimbal_mount_x_sensor_attitude_acc = True  # variable para controlar relación entre type_gimbal_mount y acc_omega, acc_phi y acc_kappa
            self.ui.checkBox_WAL.setChecked(False)  # Por defefecto desactiva el checkbox de autolanding
            self.clicked_wal()
            # self.link_trajectory_type_x_was_checked = True # variable para controlar la relación entre trajectory_type x was checked
            # self.link_trajectory_type_x_nbk = True # variable para controlar la relación entre trajectory_type x NBK

        else:
            # self.ui.groupBox_CurrentFlightBlock.setVisible(False)
            # self.ui.toolBox_currentFlightBlock.setEnabled(False)
            str_msg_error_fb_code = "Has not created new flight block"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg_error_fb_code,
                                                Qgis.Warning,
                                                10)
            return

    def calc_values_terrain(self):
        """
        Brief: Cálculo de la altura teórica de vuelo y dimensiones de la imagen en el terreno en la dirección de avance y en la dirección perpendicular de avance.
        """
        # 1.- recupera variables de entrada para el cálculo

        # características del sensor
        index_combo_sensor = self.ui.comboBox_Camera.currentIndex()
        if index_combo_sensor == 0:
            self.ui.lineEdit_theoreticalFlightAltitude.clear()
            self.ui.lineEdit_dimensionHuellaDirAvance.clear()
            self.ui.lineEdit_dimensionHuellaDirSide.clear()
            return

        str_cod_camera = self.ui.comboBox_Camera.currentText()

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT * FROM camera WHERE cod_camera = '" + str_cod_camera + "'"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            rows_digital_sensor = row[2]
            columns_digital_sensor = row[3]
            focal = row[4]
            pixel_size = row[5]

        gsd = self.ui.doubleSpinBox_gsd.value()

        hv = ((focal * gsd / 1000.0) / pixel_size) * 1000

        precision = 3
        formateo = '.' + str(precision) + 'f'

        # self.ui.lineEdit_theoreticalFlightAltitude.setEnabled(True)
        self.ui.lineEdit_theoreticalFlightAltitude.setText(format(hv, formateo))

        # yaw angle
        index_combo_yaw_angle = self.ui.comboBox_mountingType.currentIndex()
        if index_combo_yaw_angle == 0:
            self.ui.lineEdit_dimensionHuellaDirAvance.clear()
            self.ui.lineEdit_dimensionHuellaDirSide.clear()
            """
            self.ui.lineEdit_dimensionHuellaDirAvance.setEnabled(False)
            self.ui.lineEdit_dimensionHuellaDirSide.setEnabled(False)
            """
            return

        if index_combo_yaw_angle == 1:  # 0 DEG.- y forward direction
            dimension_fwd_direction = rows_digital_sensor * gsd
            dimension_side_direction = columns_digital_sensor * gsd
            self.ui.lineEdit_dimensionHuellaDirAvance.setText(format(dimension_fwd_direction, formateo))
            self.ui.lineEdit_dimensionHuellaDirSide.setText(format(dimension_side_direction, formateo))
            self.ui.doubleSpinBox_bufferLinealFlight.setValue(dimension_side_direction)
            """
            self.ui.lineEdit_dimensionHuellaDirAvance.setEnabled(True)
            self.ui.lineEdit_dimensionHuellaDirSide.setEnabled(True)
            """

        if index_combo_yaw_angle == 2:  # -90 DEG.- x forward direction (currently option n/a)
            dimension_fwd_direction = columns_digital_sensor * gsd
            dimension_side_direction = rows_digital_sensor * gsd
            self.ui.lineEdit_dimensionHuellaDirAvance.setText(format(dimension_fwd_direction, formateo))
            self.ui.lineEdit_dimensionHuellaDirSide.setText(format(dimension_side_direction, formateo))
            self.ui.doubleSpinBox_bufferLinealFlight.setValue(dimension_side_direction)
            """ 
            self.ui.lineEdit_dimensionHuellaDirAvance.setEnabled(True)
            self.ui.lineEdit_dimensionHuellaDirSide.setEnabled(True)
            """

    def clicked_hbl(self):
        """
        Brief: función para igualar o no, la altura del WP de inicio de descenso al último WP de las pasadas
        """
        if (self.ui.checkBox_HBL.isChecked()):  # check activado
            self.ui.doubleSpinBox_HBL.setEnabled(False)
        else:  # check desactivado
            self.ui.doubleSpinBox_HBL.setEnabled(True)
        self.changed_spin_height_before_landing()

    def clicked_fit_axis(self):
        """
        Brief: función para ajustar trayectoria exactamente al eje definido en trayectorias lineales
        """
        if self.ui.checkBox_fitAxis.isChecked():
            value = "1"
            if self.ui.comboBox_NBK.currentIndex() == 2:  # 20190109: Tb debe cumplir NBK=ON
                self.ui.doubleSpinBox_shotInterval.setMinimum(0)
                self.ui.doubleSpinBox_shotInterval.setValue(0)  # Propone shotInterval.value = 0 cuando FitAxis = On
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText("Hold time has been set to zero")
                # msg.setInformativeText("This is additional information")
                msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
                # msg.setDetailedText("Change in the trajectory type has set the NBK parameter to OFF")
                msg.exec_()
        else:
            value = "-1"
            self.ui.doubleSpinBox_shotInterval.setMinimum(0.5)
        fieldname_to_change = "id_wae"  # TODO: Cambiar id de columna por fit axis
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def clicked_smooth_v(self):
        """
        Brief: función para manejar el comportamiento del parámetro de navegación Smooth_V
        """
        if self.ui.checkBox_SmoothV.isChecked():
            value = "1"
        else:
            value = "-1"
        fieldname_to_change = "wpb"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def clicked_wal(self):
        """
        Brief: función para manejar el comportamiento del parámetro opcional WAL
        """
        if (self.ui.checkBox_WAL.isChecked()):
            self.ui.doubleSpinBox_WAL.setEnabled(True)
            self.changed_spin_wp_auto_landing()
        else:
            self.ui.doubleSpinBox_WAL.setEnabled(False)
            value = "-1"
            fieldname_to_change = "wal"
            str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

    def clicked_was(self):
        """
        Brief: función para manejar el comportamiento del parámetro altura vertical en despegue (antiguo WAS)
        """
        if (self.ui.checkBox_WAS.isChecked()):  # check activado
            self.ui.doubleSpinBox_WAS.setEnabled(False)
        else:  # check desactivado
            self.ui.doubleSpinBox_WAS.setEnabled(True)
        self.changed_spin_wp_auto_start()

    def changed_combo_axis(self):
        """
        Brief:
        """
        # si no es el primer elemento del combo
        if self.ui.comboBox_segmentsAvailables.currentIndex() > 0:
            # obtiene el entero id de la entidad a seleccionar
            str_current_id_axis = self.ui.comboBox_segmentsAvailables.currentText()
            current_id_axis = int(str_current_id_axis)

            self.q3_api_op.zoom_to_entity(self.path_db_project,
                                          c.CONST_PFLIPUAV_LAYER_AXIS,
                                          "the_geom",
                                          "name_display_table",
                                          current_id_axis)

    def changed_combo_camera(self):
        """
        Brief: Graba en la base de datos el key cuando el usuario cambia la selección del combo. Afecta a los parámetros acc_omega, acc_phi y acc_kappa
        """
        # si la selección es el primer elemento

        if self.ui.comboBox_Camera.currentIndex() <= 0:
            # necesario seleccionar la camara para el cálculo del max_value de acc_omega y ac_kappa
            self.ui.doubleSpinBox_accOmega.setEnabled(False)
            self.ui.doubleSpinBox_accPhi.setEnabled(False)
            self.ui.doubleSpinBox_accKappa.setEnabled(False)

            self.ui.lineEdit_theoreticalFlightAltitude.clear()
            self.ui.lineEdit_dimensionHuellaDirAvance.clear()
            self.ui.lineEdit_dimensionHuellaDirSide.clear()
            """
            self.ui.lineEdit_theoreticalFlightAltitude.setEnabled(False)
            self.ui.lineEdit_dimensionHuellaDirAvance.setEnabled(False)
            self.ui.lineEdit_dimensionHuellaDirSide.setEnabled(False)
            """

            # deshabilita la edición y eliminación de una cámara
            self.ui.toolButton_EditCamera.setEnabled(False)
            self.ui.toolButton_RemoveCamera.setEnabled(False)

            return

        else:
            str_cod_camera = self.ui.comboBox_Camera.currentText()
            # graba en la tabla flight_block el cod_camera
            str_sql = "UPDATE flight_block SET cod_camera = '" + str_cod_camera + "' "
            str_sql += "WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

            # habilita la edición y eliminación de una cámara
            self.ui.toolButton_EditCamera.setEnabled(True)
            self.ui.toolButton_RemoveCamera.setEnabled(True)

            # recálculo del max_value de acc_omega y recálculo del max_value de acc_phi
            # self.calc_max_values_ac_omega_phi()

            """
            if self.ui.comboBox_typeGimbalMount.currentIndex() > 0 and self.ui.comboBox_mountingType.currentIndex() > 0:
                self.ui.doubleSpinBox_accOmega.setEnabled(True)
                self.ui.doubleSpinBox_accPhi.setEnabled(True)
                """
            if self.ui.comboBox_mountingType.currentIndex() > 0:
                self.ui.doubleSpinBox_accOmega.setEnabled(True)
                self.ui.doubleSpinBox_accPhi.setEnabled(True)
                self.ui.doubleSpinBox_accKappa.setEnabled(True)

            self.calc_values_terrain()

    def changed_combo_eal(self):
        """
        brief:
        """
        # si la selección es el primer elemento
        if self.filling_combo_EAL:
            return
        current_index = self.ui.comboBox_EAL.currentIndex()
        if current_index <= 0:
            return
        else:
            str_value = self.ui.comboBox_EAL.currentText()
            for key in self.dictionary_eal.keys():
                value_dic = self.dictionary_eal[key]
                if (value_dic == str_value):
                    str_key_eal = str(key)
                    break

            # graba en la tabla flight_block el id_flighttype
            str_sql_update_id_eal = "UPDATE flight_block SET id_eal = " + str_key_eal \
                                    + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
            self.db_op.execute_query_old(self.path_db_project, str_sql_update_id_eal)

    def changed_combo_dtm(self):
        """
        brief:
        """
        if self.filling_combo_flight_block or self.fb_process_status == 1:  # a un bloque ya procesado no cambiarle nada
            return

        qgs_raster_layer = self.ui.mMapLayerComboBox_DTM.currentLayer()
        if qgs_raster_layer == None:
            return
        path_qgs_raster_layer = str(qgs_raster_layer.source())
        if self.q3_api_op.control_dtm(qgs_raster_layer,
                                      self.str_epsg_crs_project):
            str_internalCrsId_dtm = str(qgs_raster_layer.crs().srsid())
            self.msg_metadata_crs_dtm = self.q3_api_op.metadata_crs_object(str_internalCrsId_dtm)
            if self.cod_flight_block_dlg:
                self.store_path_dtm_in_db(path_qgs_raster_layer)
            self.ui.lineEdit_pathDTM.setText(path_qgs_raster_layer)
        else:
            self.ui.lineEdit_pathDTM.clear()

    def changed_combo_egi(self):
        """
        brief:
        """
        if self.filling_combo_EGI:
            return
        # si la selección es el primer elemento
        current_index = self.ui.comboBox_EGI.currentIndex()
        if current_index <= 0:
            return
        else:
            str_value = self.ui.comboBox_EGI.currentText()
            for key in self.dictionary_egi.keys():
                value_dic = self.dictionary_egi[key]
                if (value_dic == str_value):
                    str_key_egi = str(key)
                    break

            # graba en la tabla flight_block el id_flighttype
            str_sql_update_id_egi = "UPDATE flight_block SET id_egi = " + str_key_egi \
                                    + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
            self.db_op.execute_query_old(self.path_db_project, str_sql_update_id_egi)

    def changed_combo_erc(self):
        """
        brief:
        """
        # si la selección es el primer elemento
        if self.filling_combo_ERC:
            return
        current_index = self.ui.comboBox_ERC.currentIndex()
        if current_index <= 0:
            return
        else:
            str_value = self.ui.comboBox_ERC.currentText()
            for key in self.dictionary_erc.keys():
                value_dic = self.dictionary_erc[key]
                if (value_dic == str_value):
                    str_key_erc = str(key)
                    break

            # graba en la tabla flight_block el id_erc
            str_sql_update_id_erc = "UPDATE flight_block SET id_erc = " + str_key_erc \
                                    + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
            self.db_op.execute_query_old(self.path_db_project, str_sql_update_id_erc)

    def changed_combo_firmware(self):
        """
        brief: Actualiza la versión de uav model. También está relacionado con los parámetros:
                cruised speed, ascent_speed, descent_speed, ERC, EAL, EGI
        """
        current_index_firmware = self.ui.comboBox_Firmware.currentIndex()
        self.dictionary_eal = self.fill_combo_eal(self.path_db_project)  # rellena combo eal desde db_template
        self.dictionary_egi = self.fill_combo_egi(self.path_db_project)  # rellena combo egi desde db_template
        self.dictionary_erc = self.fill_combo_erc(self.path_db_project)  # rellena combo erc desde db_template

        if current_index_firmware <= 0:  # si la selección es el primer elemento
            """
            self.iface.messageBar().pushMessage(c.CONST_PLIPUAV_TITLE,
                                                "Select UAV & firmware version",
                                                Qgis.Critical,
                                                10)
            """
            # deshabilita cruise speed
            self.ui.doubleSpinBox_speedCruising.setEnabled(False)
            self.ui.doubleSpinBox_speedAsc.setEnabled(False)  # deshabilita ascent speed. 20160820 para Carabo
            self.ui.doubleSpinBox_speedDes.setEnabled(False)  # deshabilita descent speed. 20160820 para Carabo
            self.ui.comboBox_EAL.setCurrentIndex(0)  # fija el combo EAL a (index = 0)
            self.ui.comboBox_EGI.setCurrentIndex(0)  # fija el combo EGI a (index = 0)
            self.ui.comboBox_ERC.setCurrentIndex(0)  # fija el combo ERC a (index = 0)
            self.ui.comboBox_EAL.setEnabled(False)  # deshabilita el combo EAL
            self.ui.comboBox_EGI.setEnabled(False)  # deshabilita el combo EGI
            self.ui.comboBox_ERC.setEnabled(False)  # deshabilita el combo ERC
            str_key_firmware = "-1"
        else:
            str_value_firmware = self.ui.comboBox_Firmware.currentText()
            # habilita cruise speed
            self.ui.doubleSpinBox_speedCruising.setEnabled(True)
            # habilita ascent speed y descent speed. Carlos 20160820
            self.ui.doubleSpinBox_speedAsc.setEnabled(False)
            self.ui.doubleSpinBox_speedDes.setEnabled(False)
            # 20160820. Habilita EAL, ERC , EGI, solo para firmwares microdrones
            if (str_value_firmware == c.CONST_CARABO_S3_AC_030406):
                # vacia los combobox correspondientes y los vuelve a rellenar actualizando los diccionarios
                self.ui.comboBox_EAL.setCurrentIndex(1)  # fija EAL en index = 1 (Aterriza)
                self.ui.comboBox_EGI.setCurrentIndex(1)  # fija EGI en index = 1 (desciende permitiendo control de dirección)
                self.ui.comboBox_ERC.setCurrentIndex(3)  # fija ERC en index = 3 (vuelta a casa)
                self.ui.comboBox_EAL.setEnabled(False)  # deshabilita el combo EAL
                self.ui.comboBox_EGI.setEnabled(False)  # deshabilita el combo EGI
                self.ui.comboBox_ERC.setEnabled(False)  # deshabilita el combo ERC
            else:
                self.ui.comboBox_EAL.setEnabled(True)  # Habilita el combo EAL
                self.ui.comboBox_EGI.setEnabled(True)  # Habilita el combo EGI
                self.ui.comboBox_ERC.setEnabled(True)  # Habilita el combo ERC

            for key in self.dictionary_firmware.keys():
                value_dic = self.dictionary_firmware[key]
                if (value_dic == str_value_firmware):
                    str_key_firmware = str(key)
                    break
                    # conexión con la base de datos

            # estable el dominio, paso y default value del parámetro cruised_speed
            con_db_template = self.db_op.connection_sqlite(self.path_db_project)
            cursor_db_template = con_db_template.cursor()

            # ejecuta consulta para obtener los datos
            str_sql = "SELECT default_value, max_value, min_value, single_step "
            str_sql += "FROM fields_descriptions "
            str_sql += "WHERE fields_descriptions.'table' = 'flight_block' AND fields_descriptions.'fieldname' = 'cruise_speed' AND fields_descriptions.'version_firmaware' = '"
            str_sql += str_value_firmware + "';"

            cursor_db_template.execute(str_sql)

            for row in cursor_db_template.fetchall():
                default_value = row[0]
                max_value = row[1]
                min_value = row[2]
                single_step = row[3]

            self.ui.doubleSpinBox_speedCruising.setMaximum(max_value)
            self.ui.doubleSpinBox_speedCruising.setMinimum(min_value)
            self.ui.doubleSpinBox_speedCruising.setSingleStep(single_step)
            if self.link_firmware_cruised_speed:
                self.ui.doubleSpinBox_speedCruising.setValue(default_value)

            # ejecuta consulta para obtener los datos
            str_sql = "SELECT default_value, max_value, min_value, single_step "
            str_sql += "FROM fields_descriptions "
            str_sql += "WHERE fields_descriptions.'table' = 'flight_block' AND fields_descriptions.'fieldname' = 'ascent_speed' AND fields_descriptions.'version_firmaware' = '"
            str_sql += str_value_firmware + "';"

            cursor_db_template.execute(str_sql)

            for row in cursor_db_template.fetchall():
                default_value = row[0]
                max_value = row[1]
                min_value = row[2]
                single_step = row[3]

            self.ui.doubleSpinBox_speedAsc.setMaximum(max_value)
            self.ui.doubleSpinBox_speedAsc.setMinimum(min_value)
            self.ui.doubleSpinBox_speedAsc.setSingleStep(single_step)
            if self.link_firmware_ascent_speed:
                self.ui.doubleSpinBox_speedAsc.setValue(default_value)

            # ejecuta consulta para obtener los datos
            str_sql = "SELECT default_value, max_value, min_value, single_step "
            str_sql += "FROM fields_descriptions "
            str_sql += "WHERE fields_descriptions.'table' = 'flight_block' AND fields_descriptions.'fieldname' = 'descent_speed' AND fields_descriptions.'version_firmaware' = '"
            str_sql += str_value_firmware + "';"

            cursor_db_template.execute(str_sql)

            for row in cursor_db_template.fetchall():
                default_value = row[0]
                max_value = row[1]
                min_value = row[2]
                single_step = row[3]

            self.ui.doubleSpinBox_speedDes.setMaximum(max_value)
            self.ui.doubleSpinBox_speedDes.setMinimum(min_value)
            self.ui.doubleSpinBox_speedDes.setSingleStep(single_step)
            if self.link_firmware_descent_speed:
                self.ui.doubleSpinBox_speedDes.setValue(default_value)

            con_db_template.close()

            # obtiene la duracion de la bateria para el current uav model y se la asigna al widget correspondiente
            self.float_corrected_duration_battery = self.get_duration_battery(str_value_firmware)
            self.ui.doubleSpinBox_batteryDuration.setValue(self.float_corrected_duration_battery)

            # graba en la tabla flight_block el id_firmware
            self.str_sql_update_id_firmware = "UPDATE flight_block SET id_firmware = " + str_key_firmware \
                                              + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
            self.db_op.execute_query_old(self.path_db_project, self.str_sql_update_id_firmware)

    def changed_combo_final_options_lineal(self):
        """
        Brief:
        """
        """
        if self.q_combo_final_options.currentIndex() == 1:
            str_msg = "Repeat processing by changing parameters"
            self.iface.messageBar().pushMessage(c.CONST_PLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            self.q_combo_final_options.setEnabled(False) # deshabilito el combo de opciones
        """

        if self.q_combo_final_options.currentIndex() == 1:  # Grabación de la memory layer en spatiaLite
            if (self.class_lineal_planning.store_stereo_pairs()):
                str_msg = "Record results and finish processing stereopairs"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Info,
                                                    10)
            else:
                str_msg = "Error while recording stereopairs memory layer in SpatiaLite database"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Critical,
                                                    10)
                return

            if (self.class_lineal_planning.store_images()):
                str_msg = "Record results and finish processing images"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Info,
                                                    10)

            else:
                str_msg = "Error while recording images memory layer in SpatiaLite database"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Critical,
                                                    10)
                return

            if (self.class_lineal_planning.store_strips()):
                self.q_combo_final_options.setEnabled(False)  # deshabilito el combo de opciones
                str_msg = "Record results and finish processing strips"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Info,
                                                    10)

            else:
                str_msg = "Error while recording strips memory layer in SpatiaLite database"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Critical,
                                                    10)
                return

            self.final_actions_process_ok()
            self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_MEMORY_GIS_LAYERS)
            self.load_to_qgis_output_spatialite_layers()

    def changed_combo_flight_block(self):
        """
        Brief:
        """
        # bloque de vuelo distinto del inicialineEdit_pathDTMl *************************************************************************
        if self.ui.comboBox_FlightBlock.currentIndex() > 0:
            self.ui.mGroupBox_spatialData.setVisible(True)
            self.ui.mGroupBox_imagingAcquisitionParameters.setVisible(True)
            self.ui.mGroupBox_geometricNavigationParameters.setVisible(True)
            self.ui.mGroupBox_calculatedParametersGSD.setVisible(True)
            self.ui.mGroupBox_processingResults.setVisible(True)

            self.link_firmware_cruised_speed = False  # variable para controlar la relacion entre versión firmware y cruised speed
            self.link_firmware_ascent_speed = False  # variable para controlar la relación entre versión firmware y ascent speed
            self.link_firmware_descent_speed = False  # variable para controlar la relación entre versión firmware y descent speed
            self.link_gimbal_mount_x_sensor_attitude_acc = False  # variable para controlar relación entre type_gimbal_mount y acc_omega, acc_phi y acc_kappa
            self.link_end_height_HBL = False  # variable para controlar la relación entre end height y height before landing.
            # self.link_trajectory_type_x_nbk = False # variable para controlar la relación entre trajectory_type x NBK
            # self.link_trajectory_type_x_smoothV_checked = False # variable para controlar la relación entre trajectory_type x smooth_v checked
            self.control_flightblock_change = False  # 20190206 - variable para evitar ejecutar dependencias mientras se cambia de bloque de vuelo

            # 0.- configuración inicial

            # habilita / deshabilita widgets
            self.cod_flight_block_dlg = self.ui.comboBox_FlightBlock.currentText()  # establece el código de bloque de vuelo actual

            self.ui.pushButton_RemoveFlightBlock.setEnabled(True)  # habilita el botón de eliminar un bloque de vuelo

            # ficheros de salida
            str_directory_fb = self.current_path_project_directory + c.CONST_SEPARATOR_DIRECTORIES + self.cod_flight_block_dlg
            self.current_path_flight_block_directory = os.path.normcase(str_directory_fb)

            # conforma los paths de los ficheros de salida
            self.path_file_results = os.path.normcase(self.current_path_flight_block_directory + "\\" + "report_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".txt")  # path del fichero de resultados = cadena report_prj_
            self.path_file_results_csv = os.path.normcase(self.current_path_flight_block_directory + "\\" + "report_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".csv")  # path del fichero de resultados csv
            self.path_uav_navigation_file_name = os.path.normcase(self.current_path_flight_block_directory + "\\" + "WP_099_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg)  # path del fichero de navegación para ambos sentidos (falta añadir sentido directo e inverso en la función llamada)
            self.path_file_map_pdf = os.path.normcase(self.current_path_flight_block_directory + "\\" + "map_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".pdf")  # path del fichero con el mapa en formato pdf

            self.ui.groupBox_CurrentFlightBlock.setVisible(True)  # habilita el groupBox current Flight Block

            # conexión con la BD para consulta zoom
            con_db_project = self.db_op.connection_sqlite(self.path_db_project)
            cursor_db_project = con_db_project.cursor()

            # consulta para saber estado de procesamiento y tipo de mision del bloque de vuelo actual
            str_sql = "SELECT id_process_st, id_fb_type FROM flight_block WHERE cod_flight_block = '"
            str_sql += self.cod_flight_block_dlg + "';"
            cursor_db_project.execute(str_sql)

            for row in cursor_db_project.fetchall():
                status_process = row[0]
                self.fb_process_status = status_process
                self.int_photogrammetric_mission_type = row[1]

            self.path_dtm_from_database(cursor_db_project)  # rellena el path DTM

            # elimina grupos capas GIS si existen
            self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_AUX_GIS_LAYERS)
            self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_GIS_LAYERS)
            self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_MEMORY_GIS_LAYERS)

            # rellena combos de capas vectorial tof y lnd
            self.ui.comboBox_SHP.clear()
            self.fill_combo_tof_points(self.path_db_project)
            self.fill_combo_lnd_points(self.path_db_project)
            self.fill_combo_shp_points(self.path_db_project)

            self.fill_tableview_axis()  # rellena tableview axis

            # VUELO LINEAL *********************************************************************************************
            if self.int_photogrammetric_mission_type == 1:
                self.load_to_qgis_polygonal_layers()
                self.ui.groupBox_CurrentFlightBlock.setTitle(c.CONST_MISSION_TYPE_LINEAL)
                self.ui.groupBox_segmentsPaflr.setVisible(False)
                self.ui.groupBox_segmentsLinealMission.setVisible(True)
                self.ui.label_linealEnlargement.setText("Lineal segments ext. (m):")
                self.ui.doubleSpinBox_linealEnlargement.setEnabled(False)
                self.ui.checkBox_removeImagesWithoutStereoscopy.setEnabled(False)
                self.ui.checkBox_removeImagesWithoutStereoscopy.setChecked(False)

                self.ui.doubleSpinBox_bufferLinealFlight.setEnabled(True)  # habilita el widget del parámetro buffer
                self.ui.spinBox_nStrips.setEnabled(True)  # habilita spin number of strips
                self.ui.comboBox_idZone.setCurrentIndex(0)
                self.ui.comboBox_idZone.setEnabled(False)
                if self.ui.spinBox_nStrips.value() > 1:
                    self.ui.pushButton_generateAxisStrips.setEnabled(True)
                    self.ui.comboBox_idVector.setEnabled(True)
                else:
                    self.ui.pushButton_generateAxisStrips.setEnabled(False)
                    self.ui.comboBox_idVector.setEnabled(False)
                self.ui.pushButton_showBuffer.setEnabled(True)  # habilita botón para mostrar el buffer en QGIS
                self.ui.doubleSpinBox_overlapSide.setEnabled(False)  # deshabilita el widget del parámetro side overlap
                self.ui.checkBox_fitAxis.setEnabled(True)  # habilita el checkbox de ajustar trayectoria a eje
                self.ui.toolButton_qutline.setEnabled(True)  # habilita qutline tool
                self.ui.comboBox_tofPoints.setEnabled(True)  # deshabilita combo takeoff points
                self.ui.comboBox_lndPoints.setEnabled(True)  # deshabilita combo lnd points

            # VUELO ZONAL **********************************************************************************************
            if self.int_photogrammetric_mission_type == 2:  # vuelo zonal
                self.load_to_qgis_zonal_layers()

                self.ui.groupBox_CurrentFlightBlock.setTitle(c.CONST_MISSION_TYPE_ZONAL)
                self.ui.groupBox_segmentsPaflr.setVisible(False)
                self.ui.groupBox_segmentsLinealMission.setVisible(True)
                self.ui.label_linealEnlargement.setText("Lineal zone ext. (m):")
                self.ui.doubleSpinBox_linealEnlargement.setEnabled(True)
                self.ui.checkBox_removeImagesWithoutStereoscopy.setEnabled(True)
                self.ui.checkBox_removeImagesWithoutStereoscopy.setChecked(True)

                self.ui.doubleSpinBox_bufferLinealFlight.setEnabled(False)
                self.ui.pushButton_generateAxisStrips.setEnabled(True)
                self.ui.spinBox_nStrips.setEnabled(False)  # habilita spin number of strips
                self.ui.comboBox_idVector.setEnabled(True)
                self.ui.comboBox_idZone.setEnabled(True)
                self.ui.pushButton_showBuffer.setEnabled(False)  # deshabilita botón para mostrar el buffer en QGIS
                self.ui.doubleSpinBox_overlapSide.setEnabled(True)
                self.ui.checkBox_fitAxis.setEnabled(False)  # deshabilita el checkbox de ajustar trayectoria a eje
                self.ui.toolButton_qutline.setEnabled(False)  # habilita qutline tool
                self.ui.comboBox_tofPoints.setEnabled(True)  # deshabilita combo takeoff points
                self.ui.comboBox_lndPoints.setEnabled(True)  # deshabilita combo lnd points

            # Prepare flight blocks from lineal axis segmentation ******************************************************
            if self.int_photogrammetric_mission_type == 3:
                self.load_to_qgis_polygonal_layers()

                self.ui.groupBox_segmentsPaflr.setVisible(True)
                self.ui.groupBox_segmentsLinealMission.setVisible(False)

                self.ui.groupBox_CurrentFlightBlock.setTitle(c.CONST_MISSION_TYPE_PREPARE_FLIGHT_BLOCKS)
                self.ui.label_linealEnlargement.setText("Lineal segments ext. (m):")
                self.ui.doubleSpinBox_linealEnlargement.setEnabled(False)

                self.ui.doubleSpinBox_bufferLinealFlight.setEnabled(True)  # habilita el widget del parámetro buffer
                self.ui.spinBox_nStrips.setEnabled(True)  # habilita spin number of strips
                self.ui.pushButton_showBuffer.setEnabled(True)  # habilita botón para mostrar el buffer en QGIS
                self.ui.doubleSpinBox_overlapSide.setEnabled(False)  # deshabilita el widget del parámetro side overlap
                self.ui.checkBox_fitAxis.setEnabled(True)  # habilita el checkbox de ajustar trayectoria a eje
                self.ui.toolButton_qutline.setEnabled(True)  # habilita qutline tool
                self.ui.comboBox_tofPoints.setEnabled(False)  # deshabilita combo takeoff points
                self.ui.comboBox_lndPoints.setEnabled(False)  # deshabilita combo lnd points

            # pone los doubleSpinBox en su correspondiente valor
            self.set_lineedit_dtm(cursor_db_project)
            self.set_double_spinbox_gsd(cursor_db_project)
            self.set_double_spinbox_tol_gsd(cursor_db_project)
            self.set_spinbox_n_strips(cursor_db_project)
            self.set_double_spinbox_foward_overlap(cursor_db_project)
            self.set_double_spinbox_side_overlap(cursor_db_project)
            self.set_double_spinbox_ac_gps(cursor_db_project)
            self.set_double_spinbox_ac_omega(cursor_db_project)
            self.set_double_spinbox_ac_phi(cursor_db_project)
            self.set_double_spinbox_ac_kap(cursor_db_project)
            self.set_double_spinbox_cruise_speed(cursor_db_project)
            self.set_double_spinbox_ascent_speed(cursor_db_project)
            self.set_double_spinbox_descent_speed(cursor_db_project)
            self.set_double_spinbox_lea(cursor_db_project)
            self.set_double_spinbox_initial_height(cursor_db_project)
            self.set_double_spinbox_hbl(cursor_db_project)
            self.set_double_spinbox_end_height(cursor_db_project)
            self.set_double_spinbox_offset_omega(cursor_db_project)
            self.set_double_spinbox_offset_phi(cursor_db_project)
            self.set_double_spinbox_offset_kappa(cursor_db_project)
            self.set_double_spinbox_omega_angle(cursor_db_project)
            self.set_double_spinbox_phi_angle(cursor_db_project)
            self.set_double_spinbox_ssh(cursor_db_project)
            self.set_double_spinbox_gpa(cursor_db_project)
            self.set_double_spinbox_omega_angle(cursor_db_project)
            self.set_double_spinbox_wal(cursor_db_project)
            self.set_double_spinbox_was(cursor_db_project)
            self.set_double_spinbox_average_height_object(cursor_db_project)

            # pone los comboBoxs en su correspondiente índice
            self.filling_combo_EAL = True
            self.filling_combo_ERC = True
            self.filling_combo_EGI = True
            self.set_index_combo_firmware(cursor_db_project)
            self.filling_combo_EAL = False
            self.filling_combo_ERC = False
            self.filling_combo_EGI = False
            self.set_index_combo_camera(cursor_db_project)

            if self.ui.comboBox_Firmware.currentIndex() > 0:
                self.dictionary_eal = self.fill_combo_eal(self.path_db_project)  # rellena combo eal desde la base de datos template
                self.dictionary_egi = self.fill_combo_egi(self.path_db_project)  # rellena combo egi desde la base de datos template
                self.dictionary_erc = self.fill_combo_erc(self.path_db_project)  # rellena combo erc desde la base de datos template
                self.set_index_combo_eal(cursor_db_project)
                self.set_index_combo_egi(cursor_db_project)
                self.set_index_combo_erc(cursor_db_project)

            self.set_index_combo_mounting_type(cursor_db_project)
            self.set_index_combo_nbk(cursor_db_project)
            self.set_index_combo_npsf(cursor_db_project)
            self.set_index_combo_shp(cursor_db_project)
            self.set_checkbox_SmoothV(cursor_db_project)
            self.set_index_combo_trajectory_type(cursor_db_project)
            self.set_index_combo_type_gimbal_mount(cursor_db_project)
            self.set_double_spinbox_shot_interval(cursor_db_project)
            self.set_checkbox_fitAxis(cursor_db_project)

            # habilita/deshabilita widgets de parámetros dependientes de combobox
            self.initialize_enabled_spins_depends_combo()

            if status_process == 1:  # procesado  **********************************************************************
                # self.ui.mGroupBox_spatialData.setCollapsed(True)
                self.ui.groupBox_segmentsLinealMission.setEnabled(False)
                self.ui.groupBox_generateAxisStripsTool.setEnabled(False)
                self.ui.groupBox_DTM.setEnabled(False)
                # self.ui.mGroupBox_imagingAcquisitionParameters.setCollapsed(True)
                # self.ui.mGroupBox_geometricNavigationParameters.setCollapsed(True)
                # self.ui.mGroupBox_calculatedParametersGSD.setCollapsed(True)
                # self.ui.mGroupBox_processingResults.setCollapsed(False)
                self.ui.mGroupBox_processingResults.setEnabled(True)

                if self.int_photogrammetric_mission_type == 3:  # polygonal area from lineal route
                    self.ui.groupBox_segmentsPaflr.setVisible(False)

                # botones a nivel de bloque de vuelo
                self.ui.toolButton_Planning.setEnabled(False)  # bloque procesado no se pueden reprocesar
                self.ui.toolButton_CopyParameter.setEnabled(True)  # bloques procesados si se pueden copiar parámetros
                # self.ui.toolBox_currentFlightBlock.setItemEnabled(0,False)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(0, True)  # pestaña project data definition
                self.ui.groupBox_generalData.setEnabled(False)
                #self.ui.groupBoxSpatialData.setEnabled(False)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(1, True)  # pestaña geometric navigation parameters
                self.ui.groupBox_GeometricParameters.setEnabled(False)
                self.ui.groupBox_UAVNavigationParameters.setEnabled(False)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(2, True)  # pestaña imaging adqisition parameters
                self.ui.groupBox_OnBoardSensor.setEnabled(False)
                self.ui.groupBox_sensorAttitude.setEnabled(False)
                self.ui.groupBox_ImagingAcqParameters.setEnabled(False)
                self.ui.label_SensorPositionAccuracy.setEnabled(False)
                self.ui.doubleSpinBox_accGps.setEnabled(False)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(3, True)  # pestaña security parameters
                self.ui.groupBox_GeneralSecurityParameters.setEnabled(False)
                self.ui.groupBox_settingSpecialTasks.setEnabled(False)
                self.ui.groupBox_optionalsParameters.setEnabled(False)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(4, True)  # pestaña processing results
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(4)
                self.ui.page_ProcessingResults.setEnabled(True)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(5, False)  # pestaña ground control planning
                # self.ui.checkBox_groundControlPlanningSetCalibrationFixed.setChecked(True)

                if self.int_photogrammetric_mission_type == 1 or self.int_photogrammetric_mission_type == 2:
                    # habilita combobox con fichero de resultados
                    self.ui.comboBox_fileResults.setEnabled(True)
                    self.ui.pushButton_processReport.setEnabled(True)
                    self.ui.groupBox_DuracionDelVuelo.setVisible(False)  # dhl 20220203
                    self.ui.mGroupBox_axisProccessedSummary.setVisible(False)
                    self.fill_combo_file_results()

                    self.load_to_qgis_output_spatialite_layers()

                    """
                    self.canvas.freeze(False)
                    self.canvas.refresh()
                    """

                    # habilita el QTimeEdit estableciendo la duración del vuelo calculada en el script de navegación
                    con_db_project = self.db_op.connection_sqlite(self.path_db_project)
                    cursor_db_project = con_db_project.cursor()
                    field = "flight_duration"
                    str_sql = "SELECT " + field + " FROM flight_block WHERE cod_flight_block = '"
                    str_sql += self.cod_flight_block_dlg + "';"
                    cursor_db_project.execute(str_sql)
                    for row in cursor_db_project.fetchall():
                        time_store_in_db = row[0]
                    if time_store_in_db == None:
                        time_store_in_db = 0  # evita excepcion cuando no se envía la llamada al script de navegación
                    self.time_store_in_db = time_store_in_db

                    self.set_time_duration_flight(self.time_store_in_db)  # establece el valor de la duración del vuelo en el widget correspondiente

                    self.set_widget_duration_battery_vs_fly()  # configura el widget duración batería vs. duración del vuelo

                if self.int_photogrammetric_mission_type == 3:
                    self.ui.comboBox_fileResults.setEnabled(False)
                    self.ui.pushButton_processReport.setEnabled(False)
                    self.ui.groupBox_DuracionDelVuelo.setVisible(False)
                    # rellena tableview axis processed summary
                    # self.fill_tableview_axis()
                    self.ui.mGroupBox_axisProccessedSummary.setVisible(True)
                    self.fill_tableview_axis_processed_summary()

            if status_process == 0:  # no procesado  *******************************************************************
                self.ui.mGroupBox_spatialData.setCollapsed(False)
                self.ui.groupBox_segmentsLinealMission.setEnabled(True)
                self.ui.groupBox_generateAxisStripsTool.setEnabled(True)
                self.ui.groupBox_DTM.setEnabled(True)
                self.ui.mGroupBox_imagingAcquisitionParameters.setCollapsed(False)
                self.ui.mGroupBox_geometricNavigationParameters.setCollapsed(False)
                self.ui.mGroupBox_calculatedParametersGSD.setCollapsed(False)
                self.ui.mGroupBox_processingResults.setCollapsed(True)
                self.ui.mGroupBox_processingResults.setEnabled(False)

                self.ui.toolButton_Planning.setEnabled(True)
                if self.int_photogrammetric_mission_type == 3:  # Prepare flight blocks from lineal axis segmentation
                    self.ui.toolButton_Planning.setToolTip("Prepare flight block")
                    self.ui.toolButton_Planning.setIcon(QIcon(":/plugins/pflip_uav_pafyc/icons/kservices.png"))

                    # self.fill_combo_axis_segments(self.path_db_project)
                    self.fill_combo_axis_paflr(self.path_db_project,
                                               self.cod_flight_block_dlg)
                    self.ui.groupBox_segmentsPaflr.setVisible(True)

                else:
                    self.ui.toolButton_Planning.setToolTip("Process flight block")
                    self.ui.toolButton_Planning.setIcon(QIcon(":/plugins/pflip_uav_pafyc/icons/processing.png"))

                self.ui.toolButton_CopyParameter.setEnabled(False)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(0, True)  # pestaña project data definition
                self.ui.groupBox_generalData.setEnabled(True)
                #self.ui.groupBoxSpatialData.setEnabled(True)
                self.ui.mGroupBox_spatialData.setCollapsed(False)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(1, True)  # pestaña geometric navigation parameters
                self.ui.groupBox_GeometricParameters.setEnabled(True)
                self.ui.groupBox_UAVNavigationParameters.setEnabled(True)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(2, True)  # pestaña imaging adqisition parameters
                self.ui.groupBox_OnBoardSensor.setEnabled(True)
                self.ui.groupBox_sensorAttitude.setEnabled(True)
                self.ui.groupBox_ImagingAcqParameters.setEnabled(True)
                self.ui.label_SensorPositionAccuracy.setEnabled(True)
                self.ui.doubleSpinBox_accGps.setEnabled(True)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(3, True)  # pestaña security parameters
                self.ui.groupBox_GeneralSecurityParameters.setEnabled(True)
                self.ui.groupBox_settingSpecialTasks.setEnabled(True)
                self.ui.groupBox_optionalsParameters.setEnabled(True)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(4, False)  # pestaña processing results
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)

                self.ui.toolBox_currentFlightBlock.setItemEnabled(5, False)  # pestaña ground control planning

            # zoom al axis si éxiste
            id_axis = None
            str_sql = "SELECT id_axis FROM flight_block_c_axis WHERE cod_flight_block = '"
            str_sql += self.cod_flight_block_dlg + "';"
            cursor_db_project.execute(str_sql)
            for row in cursor_db_project.fetchall():
                id_axis = row[0]

            if (id_axis != None):
                self.q3_api_op.zoom_to_entity(self.path_db_project,
                                              c.CONST_PFLIPUAV_LAYER_AXIS,
                                              "the_geom",
                                              "name_display_table",
                                              id_axis)

            con_db_project.close()  # cierra la base de datos
            self.link_firmware_cruised_speed = True  # variable para controlar la relacion entre versión firmware y cruised speed
            self.link_firmware_ascent_speed = True  # variable para controlar la relación entre versión firmware y ascent speed
            self.link_firmware_descent_speed = True  # variable para controlar la relación entre versión firmware y descent speed
            self.link_gimbal_mount_x_sensor_attitude_acc = True  # variable para controlar relación entre type_gimbal_mount y acc_omega, acc_phi y acc_kappa
            # self.link_trajectory_type_x_smoothV_checked = True # variable para controlar la relación entre trajectory_type x smooth_v checked
            self.link_end_height_HBL = True  # variable para controlar la relación entre end height y height before landing.
            self.control_flightblock_change = True

        else:
            self.ui.groupBox_CurrentFlightBlock.setVisible(False)
            self.ui.pushButton_AddFlightBlock.setEnabled(True)
            self.ui.pushButton_RemoveFlightBlock.setEnabled(False)
            self.ui.toolButton_CopyParameter.setEnabled(False)
            self.ui.toolButton_Planning.setEnabled(False)

    def changed_combo_lnd(self):
        """
        Brief:
        """
        if self.ui.comboBox_lndPoints.currentIndex() <= 0:
            return
            # str_current_id_lnd_point = "-2"

        # toff point
        if self.ui.comboBox_lndPoints.currentIndex() == 1:
            # no se ha seleccionado punto de despegue
            if self.ui.comboBox_tofPoints.currentIndex() == 0:
                # self.iface.messageBar().pushMessage(c.CONST_PLIPUAV_TITLE,
                #                                "Select takeoff point in the corresponding combo",
                #                                Qgis.Critical,
                #                                10)
                str_current_id_lnd_point = "-2"
                str_sql = "UPDATE flight_block SET id_lnd = " + str_current_id_lnd_point + " "
                str_sql += "WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
                self.db_op.execute_query_old(self.path_db_project, str_sql)
                self.ui.comboBox_lndPoints.setCurrentIndex(0)

            else:
                # obtiene el entero id de la entidad a seleccionar
                str_current_id_tof_point = self.ui.comboBox_tofPoints.currentText()
                current_id_tof_point = int(str_current_id_tof_point)
                self.q3_api_op.zoom_to_entity(self.path_db_project,
                                              c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                              "the_geom",
                                              "name_display_table",
                                              current_id_tof_point)

                # código de tipo de aterrizaje = punto de despegue (0)
                str_current_id_lnd_point = "-1"

        # punto digitalizado en la capa lnd_point
        if self.ui.comboBox_lndPoints.currentIndex() > 1:

            # obtiene el entero id de la entidad a seleccionar
            str_current_id_lnd_point = self.ui.comboBox_lndPoints.currentText()
            current_id_lnd_point = int(str_current_id_lnd_point)

            self.q3_api_op.zoom_to_entity(self.path_db_project,
                                          c.CONST_PFLIPUAV_LAYER_LANDING_POINT,
                                          "the_geom",
                                          "name_display_table",
                                          current_id_lnd_point)
            if self.ui.comboBox_SHP.currentIndex() == 2:  # si shp = landing point
                # conforma el msg emergente
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("WARNING!! The selected Home position is different of the Take-off point  ")
                str_msg_informative_text = "  ** This is a NON standard mission procedure !! **  " + "\n"
                str_msg_informative_text += "An inadvertent activation of this option could be dangerous" + "\n"
                str_msg_informative_text += "A mission safety assessment should be done" + "\n"
                msg.setInformativeText(str_msg_informative_text)
                msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
                # msg.setDetailedText("")
                msg.exec_()

        # graba en la tabla flight_block el id_lnd siempre y cuando haya algún código de bloque de vuelo seleccionado
        if (self.cod_flight_block_dlg != None):
            str_sql = "UPDATE flight_block SET id_lnd = " + str_current_id_lnd_point + " "
            str_sql += "WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_combo_mounting_type(self):
        """
        Brief:
        """
        # si la selección es el primer elemento
        current_index = self.ui.comboBox_mountingType.currentIndex()
        if current_index <= 0:
            self.ui.doubleSpinBox_accOmega.setEnabled(False)
            self.ui.doubleSpinBox_accPhi.setEnabled(False)
            # se añade con el minimal ui
            self.ui.doubleSpinBox_accKappa.setEnabled(False)

            self.ui.lineEdit_dimensionHuellaDirAvance.clear()
            self.ui.lineEdit_dimensionHuellaDirSide.clear()
            """
            self.ui.lineEdit_dimensionHuellaDirAvance.setEnabled(False)
            self.ui.lineEdit_dimensionHuellaDirSide.setEnabled(False)
            """
            return
        else:
            str_value = self.ui.comboBox_mountingType.currentText()
            for key in self.dictionary_mounting.keys():
                value_dic = self.dictionary_mounting[key]
                if (value_dic == str_value):
                    str_key_mounting = str(key)
                    break

            # graba en la tabla flight_block
            str_sql = "UPDATE flight_block SET id_mounting_type = " + str_key_mounting \
                      + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

            # recálculo del max_value de acc_omega y recálculo del max_value de acc_phi
            # self.calc_max_values_ac_omega_phi()

            # minimal ui no contempla comboBox_typeGimbalMount
            """
            if self.ui.comboBox_typeGimbalMount.currentIndex() > 0 and self.ui.comboBox_Camera.currentIndex() > 0:
                self.ui.doubleSpinBox_accOmega.setEnabled(True)
                self.ui.doubleSpinBox_accPhi.setEnabled(True)
                """
            if self.ui.comboBox_Camera.currentIndex() > 0:
                self.ui.doubleSpinBox_accOmega.setEnabled(True)
                self.ui.doubleSpinBox_accPhi.setEnabled(True)
                # se añade con el minimal ui
                self.ui.doubleSpinBox_accKappa.setEnabled(True)

            self.calc_values_terrain()

    def changed_combo_nbk(self):
        """
        Brief: Graba en la tabla fb el valor id_nbk y si nbk está activado establece el valor de number_photoshots a 1
        """
        # si la selección es el primer elemento
        current_index = self.ui.comboBox_NBK.currentIndex()
        current_index_trajectory_type = self.ui.comboBox_trajectoryType.currentIndex()
        if current_index <= 0:
            return
        else:
            str_value = self.ui.comboBox_NBK.currentText()
            for key in self.dictionary_nbk.keys():
                value_dic = self.dictionary_nbk[key]
                if (value_dic == str_value):
                    str_key_nbk = str(key)
                    # 20190109: Gestiona las nuevas dependencias NBK/VStrategy/shotInterval
                    if key == 0:  # para current_index = 1 = Stop at every WP = Yes
                        self.ui.comboBox_trajectoryType.setCurrentIndex(
                            1)  # Fuerza VStrategy = 1 (único que escribe WP de todos los fotocentros)
                        self.ui.comboBox_trajectoryType.setEnabled(False)  # Deshabilita el combo para evitar cambios
                        self.ui.doubleSpinBox_shotInterval.setMinimum(
                            0.5)  # Es incongruente permitir 0s si vamos a parar en todos los WP
                    else:  # Stop at every WP = Disabled
                        self.ui.comboBox_trajectoryType.setEnabled(True)
                        if self.ui.checkBox_fitAxis.isChecked():
                            self.ui.doubleSpinBox_shotInterval.setMinimum(0)
                            # self.ui.doubleSpinBox_shotInterval.setValue(0)  # Propone shotInterval.value = 0 cuando FitAxis = On
                    break
            # graba en la tabla flight_block
            str_sql = "UPDATE flight_block SET id_nbk = " + str_key_nbk \
                      + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_combo_npsf(self):
        """
        Brief:
        Caso especial de comboBox. Los posibles valores han sido grabado en la ui. El index 0 no es del tipo --- Select ... ---
        """
        str_value = self.ui.comboBox_numberOfPointsInSideFrame.currentText()

        # graba en la tabla flight_block el npsf
        str_sql = "UPDATE flight_block SET npsf = " + str_value \
                  + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"

        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_combo_report_option(self):
        """
        Habilita / deshabilita pushbutton en función de la opción escogida en el comboBox
        """
        index_combo = self.ui.comboBox_fileResults.currentIndex()
        if index_combo == 0 or index_combo == 2 or index_combo == 3 or index_combo == 4 or index_combo == 5:
            self.ui.pushButton_processReport.setEnabled(False)
        if index_combo == 1 or index_combo == 6:
            self.ui.pushButton_processReport.setEnabled(True)
        # if index_combo == 5:  # Tablas de SpatiaLite no geométricas (.sqlite)
        #     if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
        #         self.ui.pushButton_processReport.setEnabled(False)

    def changed_combo_shp(self):
        """
        brief:
        """
        index_combo_shp = self.ui.comboBox_SHP.currentIndex()
        index_combo_tof = self.ui.comboBox_tofPoints.currentIndex()
        index_combo_lnd = self.ui.comboBox_lndPoints.currentIndex()

        # "--- Select homing position ---"
        if index_combo_shp <= 0:
            return

        if index_combo_shp == 1:  # Take-off point (default)
            if index_combo_tof == 0:  # no se ha seleccionado punto de despegue
                self.ui.comboBox_SHP.setCurrentIndex(0)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
                return

                # zoom al punto de despegue
            str_current_id_tof_point = self.ui.comboBox_tofPoints.currentText()
            current_id_tof_point = int(str_current_id_tof_point)
            self.q3_api_op.zoom_to_entity(self.path_db_project,
                                          c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                          "the_geom",
                                          "name_display_table",
                                          current_id_tof_point)

            str_id_shp = "-1"  # código para takeoff point

        # landing point
        if index_combo_shp == 2:  # landing point
            if index_combo_lnd == 0:  # no se ha seleccionado punto de aterrizaje (lnd point)
                self.ui.comboBox_SHP.setCurrentIndex(0)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
                return

            if index_combo_lnd == 1:  # valor para landing point = takeoff point (valor en db = -1)
                if index_combo_tof == 0:  # si no hay seleccionado tof
                    self.ui.comboBox_SHP.setCurrentIndex(0)
                    self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
                    return
                else:
                    # zoom al punto de despegue
                    str_current_id_tof_point = self.ui.comboBox_tofPoints.currentText()
                    current_id_tof_point = int(str_current_id_tof_point)
                    self.q3_api_op.zoom_to_entity(self.path_db_project,
                                                  c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                                  "the_geom",
                                                  "name_display_table",
                                                  current_id_tof_point)
                    str_id_shp = "0"  # código para el home point = lnd point

            if index_combo_lnd > 1:  # cualquier punto grabado en la capa lnd
                # zoom al punto de aterrizaje
                str_current_id_lnd_point = self.ui.comboBox_lndPoints.currentText()
                current_id_lnd_point = int(str_current_id_lnd_point)
                self.q3_api_op.zoom_to_entity(self.path_db_project,
                                              c.CONST_PFLIPUAV_LAYER_LANDING_POINT,
                                              "the_geom",
                                              "name_display_table",
                                              current_id_lnd_point)
                str_id_shp = "0"  # FIXME: de momento ponemos código para lnd point, pero debería ser el código del pto ya sea de la capa tof points o lnd points

                # conforma el msg emergente
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("WARNING!! The selected Home position is different of the Take-off point  ")
                str_msg_informative_text = "  ** This is a NON standard mission procedure !! **  " + "\n"
                str_msg_informative_text += "An inadvertent activation of this option could be dangerous" + "\n"
                str_msg_informative_text += "A mission safety assessment should be done" + "\n"
                msg.setInformativeText(str_msg_informative_text)
                msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
                # msg.setDetailedText("")
                msg.exec_()

        # graba en la tabla flight_block el id_lnd siempre y cuando haya algún código de bloque de vuelo seleccionado
        if (self.cod_flight_block_dlg != None):
            str_sql = "UPDATE flight_block SET id_shp = " + str_id_shp + " "
            str_sql += "WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_combo_tof(self):
        """
        Brief:
        """
        # si no es el primer elemento del combo
        if self.ui.comboBox_tofPoints.currentIndex() > 0:

            # obtiene el entero id de la entidad a seleccionar
            str_current_id_tof_point = self.ui.comboBox_tofPoints.currentText()
            current_id_tof_point = int(str_current_id_tof_point)

            self.q3_api_op.zoom_to_entity(self.path_db_project,
                                          c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                          "the_geom",
                                          "name_display_table",
                                          current_id_tof_point)

            if (self.cod_flight_block_dlg != None):
                # graba en la tabla flight_block el id_tof. Sólo cuando el índice es mayor que 0
                str_sql = "UPDATE flight_block SET id_tof = " + str_current_id_tof_point + " "
                str_sql += "WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
                self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_combo_trajectory_type(self):
        """
        brief:
        """
        # si la selección es el primer elemento
        current_index_trajectory_type = self.ui.comboBox_trajectoryType.currentIndex()
        if current_index_trajectory_type <= 0:
            return
        if current_index_trajectory_type > 0:  # and self.link_trajectory_type_x_smoothV_checked:
            if current_index_trajectory_type <= 2:
                # 20190108: se establece la nueva logica de dependencias VStrategy/NBK/SmoothV
                self.ui.doubleSpinBox_tolGsd.setEnabled(True)
                self.ui.checkBox_SmoothV.setEnabled(True)  # Habilita el checkBox Smooth vertical (desmarcado)
                self.ui.label_25.setEnabled(True)  # Deshabilita el label_25 "Smooth trajectory"
                """
                # /// 20190109: Se ELIMINA la relacion automática propuesta entre el tipo de VStrategy y SmoothV_Check ///
                if not self.ui.checkBox_SmoothV.isChecked():
                    self.ui.checkBox_SmoothV.setChecked(True) #Smooth vertical - Enabled
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Warning)
                    msg.setText("Smooth vertical profile = Enabled")
                    #msg.setInformativeText("This is additional information")
                    msg.setWindowTitle(c.CONST_PLIPUAV_TITLE)
                    #msg.setDetailedText("Change in the trajectory type has set the NBK parameter to OFF")
                    msg.exec_()
                """
            else:
                # 20170320: Resto de trayectorias NO debe generar splines verticales ya que solo escribe el WP de los extremos
                # 20190109: Se añade a esta condición la VS=2 (solo escribe WP extremos y puntos intermedios con quiebro vertical)
                self.ui.doubleSpinBox_tolGsd.setEnabled(False)
                self.ui.doubleSpinBox_tolGsd.setValue(0)
                self.ui.checkBox_SmoothV.setEnabled(False)  # Deshabilita el checkBox Smooth vertical
                self.ui.label_25.setEnabled(False)  # Deshabilita el label_25 "Smooth trajectory"
                if self.ui.checkBox_SmoothV.isChecked():
                    self.ui.checkBox_SmoothV.setChecked(False)
                    self.clicked_smooth_v()  # envía a función para actualizar tabla flight_block
                """
                /// 20190109: Se ELIMINA la relacion propuesta automatica entre VStrategy y SmoothV_Check
                if self.ui.checkBox_SmoothV.isChecked():
                    self.ui.checkBox_SmoothV.setChecked(False) #Smooth vertical - Disabled
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Warning)
                    msg.setText("Smooth vertical profile = Disabled")
                    #msg.setInformativeText("This is additional information")
                    msg.setWindowTitle(c.CONST_PLIPUAV_TITLE)
                    #msg.setDetailedText("Change in the trajectory type has set the NBK parameter to OFF")
                    msg.exec_()
            """

            # Control para mensaje informativo en caso de trayectoria tipo 2 y toler.GSD = 0%
            if current_index_trajectory_type == 2 and self.ui.doubleSpinBox_tolGsd.value() == 0:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Information)
                msg.setText(" Current GSD tolerance = 0%  ??? ")
                msg.setInformativeText("This height profile is useful only if  GSD tolerance > 0%")
                msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
                # msg.setDetailedText("  ")
                msg.exec_()

        str_value = self.ui.comboBox_trajectoryType.currentText()
        for key in self.dictionary_trajectory_type.keys():
            value_dic = self.dictionary_trajectory_type[key]
            if (value_dic == str_value):
                str_key_trajectory_type = str(key)
                break

        # graba en la tabla flight_block
        str_sql = "UPDATE flight_block SET id_trajectory_type = " + str_key_trajectory_type \
                  + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        # self.link_trajectory_type_x_smoothV_checked = True

    def changed_combo_type_gimbal_mount(self):
        """
        brief:  Establece el comportamiento de la aplicación cuando se cambia la selección en el desplegable de type gimbal mount
                - Si la selección es el primer elemento deshabilita doubleSpinBoxs acc Omega, Phi y Kappa
                - Si la selección es cualquier otra realiza las siguientes acciones:
                    - graba en la BD el valor del gimbal_mount
                    - establece los valores por defecto de los doubleSpinBoxs acc Omega, Phi y Kappa
                    - habilita el doubleSpinBox acc Kappa
                    - habilita controles doubleSpinBoxs acc Omega, Phi si hay alguna selección en los combos Yaw angle y Camera
                      (ver función calc_max_values_ac_omega_phi)
        """
        # si la selección es el primer elemento
        current_index = self.ui.comboBox_typeGimbalMount.currentIndex()
        if current_index <= 0:
            self.ui.doubleSpinBox_accKappa.setEnabled(False)
            self.ui.doubleSpinBox_accOmega.setEnabled(False)
            self.ui.doubleSpinBox_accPhi.setEnabled(False)
            return
        else:
            # graba en la base de datos el valor type_gimbal mount
            str_value = self.ui.comboBox_typeGimbalMount.currentText()
            for key in self.dictionary_type_gimbal_mount.keys():
                value_dic = self.dictionary_type_gimbal_mount[key]
                if (value_dic == str_value):
                    str_key_type_gimbal_mount = str(key)
                    break

            str_sql = "UPDATE flight_block SET id_type_gimbel_mount = " + str_key_type_gimbal_mount \
                      + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

            # si no se está en el proceso de cambio o copia de fb, establece default values
            if (self.link_gimbal_mount_x_sensor_attitude_acc):  # variable para controlar relación entre type_gimbal_mount y acc_omega, acc_phi y acc_kappa
                if current_index == 1:  # 1.- Brushed, 2 axis gimbaled (pitch & roll)
                    default_value_acc_omega = 0.5
                    default_value_acc_phi = 0.5
                    default_value_acc_kappa = 0.5

                if current_index == 2:  # 2.- Brushless, 2 axis  gimbaled (pitch & roll)
                    default_value_acc_omega = 0.2
                    default_value_acc_phi = 0.2
                    default_value_acc_kappa = 0.5

                if current_index == 3:  # 3.- Brushed, pitch gimbaled / Roll free
                    default_value_acc_omega = 0.5
                    default_value_acc_phi = 3.0
                    default_value_acc_kappa = 0.5

                if current_index == 4:  # 4.- Brushed, pitch gimbaled / Roll UAV fixed
                    default_value_acc_omega = 0.5
                    default_value_acc_phi = 15.0
                    default_value_acc_kappa = 0.5

                # caso especial: el default value > max_value actual -> se fija el max_value con el default value
                current_max_value_acc_phi = self.ui.doubleSpinBox_accPhi.maximum()
                if default_value_acc_phi > current_max_value_acc_phi:
                    self.ui.doubleSpinBox_accPhi.setMaximum(default_value_acc_phi)

                self.ui.doubleSpinBox_accKappa.setValue(default_value_acc_kappa)
                self.ui.doubleSpinBox_accOmega.setValue(default_value_acc_omega)
                self.ui.doubleSpinBox_accPhi.setValue(default_value_acc_phi)

                self.ui.doubleSpinBox_accKappa.setEnabled(True)  # habilita el doubleSpinBox Kappa

                # habilita controles doubleSpinBoxs acc Omega, Phi si hay alguna selección en los combos Yaw angle y Camera
                # (ver función calc_max_values_ac_omega_phi)
                if self.ui.comboBox_Camera.currentIndex() > 0 and self.ui.comboBox_mountingType.currentIndex() > 0:
                    self.ui.doubleSpinBox_accOmega.setEnabled(True)
                    self.ui.doubleSpinBox_accPhi.setEnabled(True)

    def changed_combo_vector(self):
        """
        """
        # si no es el primer elemento del combo
        if self.ui.comboBox_idVector.currentIndex() > 0:  # si no es el primer elemento del combo
            # obtiene el entero id de la entidad a seleccionar
            str_current_id_vector = self.ui.comboBox_idVector.currentText()
            current_id_vector = int(str_current_id_vector)
            self.q3_api_op.zoom_to_entity(self.path_db_project,
                                          c.CONST_PFLIPUAV_LAYER_VECTOR,
                                          "the_geom",
                                          "name_display_table",
                                          current_id_vector)
            if (self.cod_flight_block_dlg != None):
                # graba en la tabla flight_block el id_vector
                str_sql = "UPDATE flight_block SET id_vector = %s WHERE cod_flight_block = '%s';" % (str_current_id_vector, self.cod_flight_block_dlg)
                self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_combo_zone(self):
        """
        """
        if self.ui.comboBox_idZone.currentIndex() > 0:  # si no es el primer elemento del combo
            # obtiene el entero id de la entidad a seleccionar
            str_id_zone = self.ui.comboBox_idZone.currentText()
            int_id_zone = int(str_id_zone)
            self.q3_api_op.zoom_to_entity(self.path_db_project,
                                          c.CONST_PFLIPUAV_LAYER_ZONE,
                                          "the_geom",
                                          "name_display_table",
                                          int_id_zone)
            if (self.cod_flight_block_dlg != None):
                # graba en la tabla flight_block el id_vector
                str_sql = "UPDATE flight_block SET id_zone = %s WHERE cod_flight_block = '%s';" % (str_id_zone, self.cod_flight_block_dlg)
                self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_acc_gps(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_accGps.value()
        str_value = str(value)
        fieldname_to_change = "ac_gps"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        # actualiza valor qsettings
        self.my_qsettings.setValue("default_value_ac_gps", value)

    def changed_spin_acc_kappa(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_accKappa.value()
        str_value = str(value)
        fieldname_to_change = "ac_kap"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        # actualiza valor qsettings
        self.my_qsettings.setValue("default_value_ac_kap", value)

    def changed_spin_acc_omega(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_accOmega.value()
        str_value = str(value)
        fieldname_to_change = "ac_omg"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_ac_omg", value)  # actualiza valor qsettings

    def changed_spin_acc_phi(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_accPhi.value()
        str_value = str(value)
        fieldname_to_change = "ac_phi"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_ac_phi", value)  # actualiza valor qsettings

    def changed_spin_ascent_speed(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_speedAsc.value()
        str_value = str(value)
        fieldname_to_change = "ascent_speed"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_average_height_object(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_averageHeightObject.value()
        str_value = str(value)
        fieldname_to_change = "av_height_obj"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_average_height_object", value)  # actualiza valor qsettings

    def changed_spin_takeoff_height(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_heightStart.value()
        str_value = str(value)
        fieldname_to_change = "initial_height"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_initial_height", value)  # actualiza valor qsettings

    def changed_spin_buffer(self):
        """
        Brief: modifica el valor del doubleSpinBox GSD en el caso de  vuelos lineales
        """
        # 1.- recupera variables de entrada para el cálculo

        # características del sensor
        index_combo_sensor = self.ui.comboBox_Camera.currentIndex()
        if index_combo_sensor == 0:
            return
        str_cod_camera = self.ui.comboBox_Camera.currentText()

        # yaw angle
        index_combo_yaw_angle = self.ui.comboBox_mountingType.currentIndex()
        if index_combo_yaw_angle == 0:
            return

        dimension_side_direction = self.ui.doubleSpinBox_bufferLinealFlight.value()

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT * FROM camera WHERE cod_camera = '" + str_cod_camera + "'"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            rows_digital_sensor = row[2]
            columns_digital_sensor = row[3]
            focal = row[4]
            pixel_size = row[5]

        if index_combo_yaw_angle == 1:  # 0 DEG.- y forward direction
            hv = (dimension_side_direction * focal) / (columns_digital_sensor * pixel_size)

        if index_combo_yaw_angle == 2:  # -90 DEG.- x forward direction (currently option n/a)
            hv = (dimension_side_direction * focal) / (rows_digital_sensor * pixel_size)

        gsd = (pixel_size * hv) / focal

        self.ui.doubleSpinBox_gsd.setValue(gsd)

    def changed_spin_cruise_speed(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_speedCruising.value()
        str_value = str(value)
        fieldname_to_change = "cruise_speed"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_descent_speed(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_speedDes.value()
        str_value = str(value)
        fieldname_to_change = "descent_speed"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_fw_ov(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_overlapFwd.value()
        str_value = str(value)
        fieldname_to_change = "foward_overlap"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_foward_overlap", value)  # actualiza valor qsettings

        # TODO: Recálculo del max_value de acc_omega y acc_phi
        # if self.ui.comboBox_Camera.currentIndex()>0: # el cálculo depende de valores de la cámara
        #    self.calc_max_values_ac_omega_phi()

    def changed_spin_general_pos_accuary(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_GPA.value()
        str_value = str(value)
        fieldname_to_change = "gpa"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_gsd(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_gsd.value()
        str_value = str(value)
        fieldname_to_change = "gsd"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_gsd", value)  # actualiza valor qsettings

        self.calc_values_terrain()  # actualiza valores calculados

    def changed_spin_landing_height(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_heightEnd.value()
        safety_height = self.ui.doubleSpinBox_SSH.value()
        if self.ui.checkBox_WAL.isChecked() and self.link_end_height_HBL:  # checkBox autolanding activado
            if value < safety_height:
                value = safety_height
                self.ui.doubleSpinBox_heightEnd.setValue(value)
        str_value = str(value)
        fieldname_to_change = "end_height"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_end_height", value)  # actualiza valor qsettings
        self.changed_spin_height_before_landing()

    def changed_spin_lineal_zone_enlargement(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_linealEnlargement.value()
        str_value = str(value)
        fieldname_to_change = "lea"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_lea", value)  # actualiza valor qsettings

    def changed_spin_offset_kappa(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_offsetKappa.value()
        str_value = str(value)
        fieldname_to_change = "offset_kappa"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_offset_kappa", value)  # actualiza valor qsettings

    def changed_spin_offset_omega(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
                Guarda dependencia con el valor introducido en omega angle. De forma que la diferencia de omega angle - offset omega tiene que estar en el
                dominio [0,90]
        """
        float_omega_angle = self.ui.doubleSpinBox_omegaAngle.value()
        float_offset_omega = self.ui.doubleSpinBox_offsetOmega.value()
        dif_angle_offset = float_omega_angle - float_offset_omega
        if (dif_angle_offset < -20 or dif_angle_offset > 70):
            str_msg = "The different of omega angle - offset omega must be in the domain [-20,70]. Value ofsset omega has been restored to default value"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            self.ui.doubleSpinBox_offsetOmega.setValue(
                self.old_value_offset_omega)  # pone el doubleSpinBox al valor por defecto
            return
        else:
            self.old_value_offset_omega = float_offset_omega  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega
            str_value = str(float_offset_omega)
            fieldname_to_change = "offset_omega"
            str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_offset_omega", float_offset_omega)  # actualiza valor qsettings

    def changed_spin_offset_phi(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
                Guarda dependencia con el valor introducido en phi angle. De forma que la diferencia de phi angle - offset phi tiene que estar en el
                    dominio [-45,45]
        """
        float_phi_angle = self.ui.doubleSpinBox_phiAngle.value()
        float_offset_phi = self.ui.doubleSpinBox_offsetPhi.value()
        dif_angle_offset = float_phi_angle - float_offset_phi
        if (dif_angle_offset < -45 or dif_angle_offset > 45):
            str_msg = "The different of phi angle - offset phi must be in the domain [-25,25]. Value ofsset phi has been restored to default value"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            self.ui.doubleSpinBox_offsetPhi.setValue(
                self.old_value_offset_phi)  # pone el doubleSpinBox al valor anterior al cambio del doubleSpin
            return
        else:
            self.old_value_offset_phi = float_offset_phi  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega
            str_value = str(float_offset_phi)
            fieldname_to_change = "offset_phi"
            str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_offset_phi", float_offset_phi)  # actualiza valor qsettings

    def changed_spin_omega_angle(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
                Guarda dependencia con el valor introducido en offset omega. De forma que la diferencia de omega angle - offset omega tiene que estar en el
                dominio [0,90]
        """
        float_omega_angle = self.ui.doubleSpinBox_omegaAngle.value()
        float_offset_omega = self.ui.doubleSpinBox_offsetOmega.value()
        dif_angle_offset = float_omega_angle - float_offset_omega
        if (dif_angle_offset < -20 or dif_angle_offset > 70):
            str_msg = "The different of omega angle - offset omega must be in the domain [-20,70]. Value omega angle has been restored to default value"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            self.ui.doubleSpinBox_omegaAngle.setValue(
                self.old_value_omega_angle)  # pone el doubleValue al valor por defecto
            return
        else:
            self.old_value_omega_angle = float_omega_angle  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega
            str_value = str(float_omega_angle)
            fieldname_to_change = "omega_angle"
            str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_sql)

    def changed_spin_phi_angle(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        float_phi_angle = self.ui.doubleSpinBox_phiAngle.value()
        float_offset_phi = self.ui.doubleSpinBox_offsetPhi.value()
        dif_angle_offset = float_phi_angle - float_offset_phi
        if (dif_angle_offset < -45 or dif_angle_offset > 45):
            str_msg = "The different of phi angle - offset phi must be in the domain [-25,25]. Value phi angle has been restored to default value"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            self.ui.doubleSpinBox_phiAngle.setValue(
                self.old_value_phi_angle)  # pone el doubleSpinBox al valor por defecto
            return
        else:
            self.old_value_phi_angle = float_phi_angle  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega
            str_value = str(float_phi_angle)
            fieldname_to_change = "phi_angle"
            str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_number_strips(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        if self.int_photogrammetric_mission_type == 1:
            value = self.ui.spinBox_nStrips.value()
            str_value = str(value)
            fieldname_to_change = "n_strips"
            str_sql = "UPDATE flight_block SET %s = %s WHERE cod_flight_block = '%s';" % (fieldname_to_change,
                                                                                          str_value,
                                                                                          self.cod_flight_block_dlg)
            self.db_op.execute_query_old(self.path_db_project, str_sql)

            # habilita doubleSpinBox side overlap y botón de acción para generación de axis strips si n_strips >= 2
            if value >= 2:
                self.ui.doubleSpinBox_overlapSide.setEnabled(True)
                self.ui.comboBox_idVector.setEnabled(True)
                self.ui.pushButton_generateAxisStrips.setEnabled(True)
            else:
                self.ui.doubleSpinBox_overlapSide.setEnabled(False)
                self.ui.comboBox_idVector.setEnabled(False)
                self.ui.pushButton_generateAxisStrips.setEnabled(False)

    def changed_spin_sd_ov(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_overlapSide.value()
        str_value = str(value)
        fieldname_to_change = "side_overlap"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_side_overlap", value)  # actualiza valor qsettings

        # Recálculo del max_value de acc_omega y acc_phi
        # if self.ui.comboBox_Camera.currentIndex()>0: # el cálculo depende de valores de la cámara
        #    self.calc_max_values_ac_omega_phi()

    def changed_spin_setting_secure_height(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_SSH.value()
        str_value = str(value)
        fieldname_to_change = "ssh"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_shot_interval(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_shotInterval.value()
        str_value = str(value)
        fieldname_to_change = "shot_interval"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_shot_interval", value)  # actualiza valor qsettings

    def changed_spin_tol_gsd(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_tolGsd.value()
        str_value = str(value)
        fieldname_to_change = "tol_gsd"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.my_qsettings.setValue("default_value_tol_gsd", value)  # actualiza valor qsettings

    def changed_spin_wp_auto_landing(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
                 Saca una advertencia de que se ha activado esta función.
                 En caso que landing_height < safety height, saca advertencia indicando que landing_height se iguala a SSH
        """
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setText("Auto-Landing has been enabled !!")
        msg.setInformativeText("Check the suitability of the landing spot")
        msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
        # msg.setDetailedText("The details are as follows:")
        msg.exec_()

        value = self.ui.doubleSpinBox_WAL.value()
        str_value = str(value)
        fieldname_to_change = "wal"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        if self.ui.doubleSpinBox_heightEnd.value() < self.ui.doubleSpinBox_SSH.value():
            self.ui.doubleSpinBox_heightEnd.setValue(self.ui.doubleSpinBox_SSH.value())
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("Height above Landing is lower than the Safety Height !!")
            msg.setInformativeText("Height above Landing will be updated")
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText(
                "If Autolanding is enabled, ""Height above Landing"" can't be lower than ""Safety Height"":")
            msg.exec_()

    def changed_spin_wp_auto_start(self):
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite
                cuando el usuario cambia valor en el Spinbox.
                Saca un error crítico cuando la altura del WAS se establece por debajo de 30 metros.
        """
        value = self.ui.doubleSpinBox_WAS.value()
        if self.ui.checkBox_WAS.isChecked():  # checkBox activado
            self.ui.doubleSpinBox_WAS.setValue(self.default_value_was)
            value = -1
        else:
            if value < 30:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Diagonal trajectory starts bellow of 30 meters height")
                msg.setInformativeText("Risk of collision with tall obstacles")
                msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
                # msg.setDetailedText("The details are as follows:")
                msg.exec_()
        str_value = str(value)
        fieldname_to_change = "was"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def changed_spin_height_before_landing(self):  # 20170317: Creado para gestionar la cota del WP antes de iniciar el descenso.
        """
        Brief: actualiza el valor introducido en el correspondiente spinBox en la base de datos SpatiaLite cuando el usuario cambia valor en el Spinbox
        """
        value = self.ui.doubleSpinBox_HBL.value()
        landing_height = self.ui.doubleSpinBox_heightEnd.value()
        if self.ui.checkBox_HBL.isChecked():  # checkBox activado
            self.ui.doubleSpinBox_HBL.setValue(landing_height)
            value = -1
        else:  # checkBox Desactivado
            if value < landing_height and self.link_end_height_HBL:
                value = landing_height
                self.ui.doubleSpinBox_HBL.setValue(value)
        str_value = str(value)
        fieldname_to_change = "end_height"
        str_sql = "UPDATE flight_block SET " + fieldname_to_change + " = " + str_value + " WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

    def copy_parameter(self,
                       nemo_flight_block_source):
        """
        Brief: abre un nuevo bloque de vuelo a partir de los datos grabados en otro bloque de vuelo procesado con anteriorioridad
        """
       # vacia la lista que se pasa por referencia al diálogo
        del self.lst_flight_block_dlg[:]
        cod_mission_type = self.int_photogrammetric_mission_type

        dlg_copy_parameter = addFlightBlockDlg(self.iface,
                                               self.lst_flight_block_dlg,
                                               self.path_db_project,
                                               cod_mission_type)

        # show the dialog
        dlg_copy_parameter.show()

        # Run the dialog
        result = dlg_copy_parameter.exec_()

        # si el usuario ha grabado algún código de bloque de vuelo dato en el panel algún dato
        if len(self.lst_flight_block_dlg) > 0:
            self.link_firmware_cruised_speed = False  # variable para controlar la relacion entre versión firmware y cruised speed
            self.link_firmware_ascent_speed = False  # variable para controlar la relación entre versión firmware y ascent speed
            self.link_firmware_descent_speed = False  # variable para controlar la relación entre versión firmware y descent speed
            self.link_gimbal_mount_x_sensor_attitude_acc = False  # variable para controlar relación entre type_gimbal_mount y acc_omega, acc_phi y acc_kappa
            # self.link_trajectory_type_x_was_checked = False # variable para controlar la relación entre trajectory_type x was checked
            # self.link_trajectory_type_x_nbk = False # variable para controlar la relación entre trajectory_type x NBK

            # 0.- configuración inicial
            # conexión con la BD para consulta zoom
            con_db_project = self.db_op.connection_sqlite(self.path_db_project)
            cursor_db_project = con_db_project.cursor()

            # captura el código guardado en el panel
            self.cod_flight_block_dlg = self.lst_flight_block_dlg[0]

            # entero con el tipo de mission: [1] - linear route; [2] - polygonal area; [3] - oblique shots
            self.int_photogrammetric_mission_type = self.lst_flight_block_dlg[1]
            # self.msg_header_data_flight_block = "Flight block code: " + self.cod_flight_block_dlg + "\n"

            # crea el directorio del bloque de vuelo en la estructura correspondiente
            str_directory_fb = self.current_path_project_directory + c.CONST_SEPARATOR_DIRECTORIES + self.cod_flight_block_dlg
            self.current_path_flight_block_directory = os.path.normcase(str_directory_fb)
            if not os.path.exists(self.current_path_flight_block_directory):
                os.makedirs(self.current_path_flight_block_directory)
            else:
                str_msg = "Directory " + str_directory_fb + " already exists"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Critical,
                                                    10)
                return

            # conforma los paths de los ficheros de salida
            self.path_file_results = os.path.normcase(
                self.current_path_flight_block_directory + "\\" + "report_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".txt")  # path del fichero de resultados = cadena report_prj_
            self.path_file_results_csv = os.path.normcase(
                self.current_path_flight_block_directory + "\\" + "report_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".csv")  # path del fichero de resultados csv
            self.path_uav_navigation_file_name = os.path.normcase(
                self.current_path_flight_block_directory + "\\" + "WP_099_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg)  # path del fichero de navegación para ambos sentidos (falta añadir sentido directo e inverso en la función llamada)
            self.path_file_map_pdf = os.path.normcase(
                self.current_path_flight_block_directory + "\\" + "map_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".pdf")  # path del fichero con el mapa en formato pdf

            # Duplica registro en la tabla [flight_block] con el nuevo código de bloque de vuelo y id_proccess a cero
            str_sql = "INSERT into flight_block ("
            str_sql += "cod_flight_block,"
            str_sql += "cod_camera,"
            str_sql += "dtm_path,"
            str_sql += "id_tof,"
            str_sql += "id_lnd,"
            str_sql += "id_firmware,"
            str_sql += "id_fb_type,"
            str_sql += "gsd,"
            str_sql += "tol_gsd,"
            str_sql += "foward_overlap,"
            str_sql += "side_overlap,"
            str_sql += "ac_gps,ac_omg,"
            str_sql += "ac_phi,"
            str_sql += "ac_kap,"
            str_sql += "id_trajectory_type,"
            str_sql += "cruise_speed,"
            str_sql += "ascent_speed,"
            str_sql += "descent_speed,"
            str_sql += "lea,"
            str_sql += "initial_height,"
            str_sql += "id_nbk,end_height,"
            str_sql += "wpb,images_item,"
            str_sql += "shot_interval,"
            str_sql += "omega_angle,"
            str_sql += "phi_angle,"
            str_sql += "id_erc,"
            str_sql += "id_eal,"
            str_sql += "id_egi,"
            str_sql += "id_shp,"
            str_sql += "ssh,"
            str_sql += "gpa,"
            str_sql += "id_wae,"
            str_sql += "wal,"
            str_sql += "was,"
            str_sql += "id_process_st,"
            str_sql += "npsf,"
            str_sql += "id_mounting_type,"
            str_sql += "id_type_gimbel_mount,"
            str_sql += "offset_omega,"
            str_sql += "offset_phi,"
            str_sql += "offset_kappa,"
            str_sql += "av_height_obj) "

            str_sql += "SELECT "
            str_sql += "'" + self.cod_flight_block_dlg + "',"
            str_sql += "cod_camera,"
            str_sql += "dtm_path,"
            str_sql += "id_tof,"
            str_sql += "id_lnd,"
            str_sql += "id_firmware,"
            str_sql += str(self.int_photogrammetric_mission_type) + ","
            str_sql += "gsd,"
            str_sql += "tol_gsd,"
            str_sql += "foward_overlap,"
            str_sql += "side_overlap,"
            str_sql += "ac_gps,"
            str_sql += "ac_omg,"
            str_sql += "ac_phi,"
            str_sql += "ac_kap,"
            str_sql += "id_trajectory_type,"
            str_sql += "cruise_speed,"
            str_sql += "ascent_speed,"
            str_sql += "descent_speed,"
            str_sql += "lea,"
            str_sql += "initial_height,"
            str_sql += "id_nbk,"
            str_sql += "end_height,"
            str_sql += "wpb,"
            str_sql += "images_item,"
            str_sql += "shot_interval,"
            str_sql += "omega_angle,"
            str_sql += "phi_angle,"
            str_sql += "id_erc,"
            str_sql += "id_eal,"
            str_sql += "id_egi,"
            str_sql += "id_shp,"
            str_sql += "ssh,"
            str_sql += "gpa,"
            str_sql += "id_wae,"
            str_sql += "wal,"
            str_sql += "was,"
            str_sql += "'0',"  # no procesado, string
            str_sql += "npsf,"
            str_sql += "id_mounting_type,"
            str_sql += "id_type_gimbel_mount,"
            str_sql += "offset_omega,"
            str_sql += "offset_phi,"
            str_sql += "offset_kappa,"
            str_sql += "av_height_obj "

            str_sql += "FROM flight_block WHERE cod_flight_block = '" + nemo_flight_block_source + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

            self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_AUX_GIS_LAYERS)
            self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_GIS_LAYERS)
            self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_MEMORY_GIS_LAYERS)

            self.fill_tableview_axis()  # rellena tableview axis

            # Duplica registro en la tabla [flight_block_c_axis] con el nuevo código de bloque de vuelo
            str_sql = "INSERT into flight_block_c_axis ("
            str_sql += "cod_flight_block,"
            str_sql += "id_axis) "
            str_sql += "SELECT '" + self.cod_flight_block_dlg + "',"
            str_sql += "id_axis "
            str_sql += "FROM flight_block_c_axis "
            str_sql += "WHERE cod_flight_block = '" + nemo_flight_block_source + "';"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

            if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
                self.load_to_qgis_polygonal_layers()

            if self.int_photogrammetric_mission_type == 2:  # vuelo zonal
                self.ui.pushButton_generateAxisStrips.setEnabled(True)
                self.load_to_qgis_zonal_layers()

            self.ui.pushButton_RemoveFlightBlock.setEnabled(True)  # Activa el botón para poder borrar un bloque de vuelo creado
            self.ui.toolButton_Planning.setEnabled(True)  # activa el botón de procesamiento
            self.ui.toolButton_Planning.setToolTip("Process flight block")
            self.ui.toolButton_Planning.setIcon(QIcon(":/plugins/pflip_uav_pafyc/icons/processing.png"))

            self.ui.toolButton_CopyParameter.setEnabled(False)  # desactiva el botón de copia
            self.ui.groupBox_CurrentFlightBlock.setVisible(True)  # hace visible el resto del panel

            # habilita / deshabilita algunas partes del panel del current flight block
            self.ui.page_ProcessingResults.setEnabled(False)  # deshabilita resultado del procesamiento
            self.ui.toolButton_EditCamera.setEnabled(True)  # habilita funcionalidad de edición de los datos de una cámara
            self.ui.toolButton_RemoveCamera.setEnabled(True)  # habilita funcionalidad de eliminación de una cámara
            self.ui.mMapLayerComboBox_DTM.setEnabled(True)

            # rellena combo flight block
            self.ui.comboBox_FlightBlock.setEnabled(True)
            self.fill_combo_nemo_flight_block(self.path_db_project)

            # pone el combo nemos bloque de vuelo en el índice del current fb
            value_compare = self.cod_flight_block_dlg
            str_sql = "SELECT cod_flight_block FROM flight_block ORDER by cod_flight_block ASC"
            index_combo_new_fb = self.db_op.get_index_combo(self.path_db_project,
                                                            str_sql,
                                                            value_compare)
            self.ui.comboBox_FlightBlock.setCurrentIndex(index_combo_new_fb)

            # rellena combos de capas vectorial tof y lnd
            # self.fill_combo_tof_points(self.path_db_project)
            # self.fill_combo_lnd_points(self.path_db_project)
            # self.fill_combo_shp_points(self.path_db_project)

            self.link_firmware_cruised_speed = True  # variable para controlar la relacion entre versión firmware y cruised speed
            self.link_firmware_ascent_speed = True  # variable para controlar la relación entre versión firmware y ascent speed
            self.link_firmware_descent_speed = True  # variable para controlar la relación entre versión firmware y descent speed
            self.link_gimbal_mount_x_sensor_attitude_acc = True  # variable para controlar relación entre type_gimbal_mount y acc_omega, acc_phi y acc_kappa
            # self.link_trajectory_type_x_smoothV_checked = True # variable para controlar la relación entre trajectory_type x smooth_v checked
            # self.link_trajectory_type_x_was_checked = True # variable para controlar la relación entre trajectory_type x was checked

            str_msg = "Flight block copyed succesfully"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Info,
                                                10)

        else:
            # self.ui.groupBox_CurrentFlightBlock.setVisible(False)
            # self.ui.toolBox_currentFlightBlock.setEnabled(False)
            # mensaje error
            str_msg_warning_copy_parameter = "The parameters are not copied"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg_warning_copy_parameter,
                                                Qgis.Warning,
                                                10)
            return False

    def fill_combo_axis_paflr(self,
                              path,
                              str_cod_flight_block):
        """
        """
        # vacia el combo
        self.ui.mComboBox_checkeableAxis.clear()

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_c_axis,  cod_segment FROM c_axis ORDER BY cod_segment ASC"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            str_current_id_c_axis = str(row[0])  # key
            str_current_cod_segment = row[1]
            if str_current_cod_segment is not None:
                lst_current_cod_segment = str_current_cod_segment.split("#")
                current_cod_fb_segment = lst_current_cod_segment[0]
                current_c_axis_id_qutline = lst_current_cod_segment[1]
                current_segment_count = lst_current_cod_segment[2]
                if current_cod_fb_segment == str_cod_flight_block:
                    self.ui.mComboBox_checkeableAxis.addItem(str_current_cod_segment)  # añade value al combobox
        con_db_project.close()  # cierra la base de datos

    def fill_combo_axis_segments(self, path):
        """
        Brief: Rellena combo axis segments para el caso de vuelos lineales
        """
        # vacia el combo
        self.ui.comboBox_segmentsAvailables.clear()

        # añade la primera línea
        self.ui.comboBox_segmentsAvailables.addItem("--- Select axis ---")

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_c_axis FROM c_axis ORDER BY id_c_axis ASC"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            str_current_id_c_axis = str(row[0])  # key
            self.ui.comboBox_segmentsAvailables.addItem(str_current_id_c_axis)  # añade value al combobox

        # self.set_index_combo_takeoff_point(cursor_db_project)
        con_db_project.close()  # cierra la base de datos

    def fill_combo_camera(self,
                          path_db_project):
        """
        Brief: Rellena el combo camera con los valores de la tabla camera
        """
        self.ui.comboBox_Camera.clear()  # vacia el combo
        self.ui.comboBox_Camera.addItem("--- Select onboard sensor ---")
        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT cod_camera FROM camera ORDER BY cod_camera ASC"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            current_cod_camera = row[0]  # key
            self.ui.comboBox_Camera.addItem(current_cod_camera)  # añade key al combobox

        con_db_project.close()  # cierra la base de datos

    def fill_combo_eal(self, path):
        """
        brief: rellena el comboBox Emergency Accumul. Low (EAL) a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values EAL
        """
        self.filling_combo_EAL = True
        # vacia el combo
        self.ui.comboBox_EAL.clear()

        # añade la primera línea
        self.ui.comboBox_EAL.addItem("---  Set the action to perform in case of low battery ---")

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        if (self.ui.comboBox_Firmware.currentText() == c.CONST_CARABO_S3_AC_030406):
            str_tablename_fb_eal = "flight_block_ealMav"
        else:
            str_tablename_fb_eal = "flight_block_eal"

        str_sql = "SELECT id_eal, def_eal FROM" + " "
        str_sql += str_tablename_fb_eal + " "
        str_sql += "ORDER BY id_eal ASC;"
        cursor_db_project.execute(str_sql)

        # incializa matriz asociativa con el par identificador interno de qgis (key) - descripcion (value)
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_eal_key = row[0]  # key
            current_eal_value = row[1]  # value
            dictionary[current_eal_key] = current_eal_value

            self.ui.comboBox_EAL.addItem(current_eal_value)  # añade value al combobox

        con_db_project.close()  # cierra la base de datos
        self.filling_combo_EAL = False
        return dictionary

    def fill_combo_egi(self, path):
        """
        brief: rellena el comboBox Emergency GPS Invalid (EGI) a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values EGI
        """
        self.filling_combo_EGI = True
        # vacia el combo
        self.ui.comboBox_EGI.clear()

        # añade la primera línea
        self.ui.comboBox_EGI.addItem("---  Set the action to perform in case of GPS loss ---")

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        if (self.ui.comboBox_Firmware.currentText() == c.CONST_CARABO_S3_AC_030406):
            str_tablename_fb_egi = "flight_block_egiMav"
        else:
            str_tablename_fb_egi = "flight_block_egi"

        str_sql = "SELECT id_egi,def_egi FROM" + " "
        str_sql += str_tablename_fb_egi + " "
        str_sql += "ORDER BY id_egi ASC;"
        cursor_db_project.execute(str_sql)

        # incializa matriz asociativa con el par identificador interno de qgis (key) - descripcion (value)
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_egi_key = row[0]  # key
            current_egi_value = row[1]  # value
            dictionary[current_egi_key] = current_egi_value

            self.ui.comboBox_EGI.addItem(current_egi_value)  # añade value al combobox

        con_db_project.close()  # cierra la base de datos
        self.filling_combo_EGI = False
        return dictionary

    def fill_combo_erc(self, path):
        """
        brief: rellena el comboBox Emergency Radio Control (ERC) a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values ERC
        """
        self.filling_combo_ERC = True
        # vacia el combo
        self.ui.comboBox_ERC.clear()

        # añade la primera línea
        self.ui.comboBox_ERC.addItem("---  Set the action to perform in case of RC loss ---")

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_erc,def_erc FROM flight_block_erc ORDER BY id_erc ASC"
        if (self.ui.comboBox_Firmware.currentText() == c.CONST_CARABO_S3_AC_030406):
            str_sql = "SELECT id_erc,def_erc FROM flight_block_ercMav ORDER BY id_erc ASC"
        cursor_db_project.execute(str_sql)

        # incializa matriz asociativa con el par identificador interno de qgis (key) - descripcion (value)
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_erc_key = row[0]  # key
            current_erc_value = row[1]  # value
            dictionary[current_erc_key] = current_erc_value

            self.ui.comboBox_ERC.addItem(current_erc_value)  # añade value al combobox

        con_db_project.close()  # cierra la base de datos
        self.filling_combo_ERC = False
        return dictionary

    def fill_combo_file_results(self):
        """
        Brief:
        """
        self.ui.comboBox_fileResults.clear()  # vacia el combo

        self.ui.comboBox_fileResults.addItem("--- Select result files ---")
        self.ui.comboBox_fileResults.addItem("Mission Planning report (.txt)")
        self.ui.comboBox_fileResults.addItem("Mission time report (.txt)")
        self.ui.comboBox_fileResults.addItem("Process information (.csv)")
        self.ui.comboBox_fileResults.addItem("Drone navigation script file")
        self.ui.comboBox_fileResults.addItem("Load to QGIS side overlap, strips connections & strips images output tables (.sqlite)")
        self.ui.comboBox_fileResults.addItem("Final report (.pdf)")

        # añade iconos identificativos
        self.ui.comboBox_fileResults.setItemIcon(1, QIcon(":/plugins/pflip_uav_pafyc/icons/txt2.png"))
        self.ui.comboBox_fileResults.setItemIcon(2, QIcon(":/plugins/pflip_uav_pafyc/icons/appointment-new.png"))
        self.ui.comboBox_fileResults.setItemIcon(3, QIcon(":/plugins/pflip_uav_pafyc/icons/csvIcon.png"))
        self.ui.comboBox_fileResults.setItemIcon(4, QIcon(":/plugins/pflip_uav_pafyc/icons/iconGeoflip.png"))
        self.ui.comboBox_fileResults.setItemIcon(5, QIcon(":/plugins/pflip_uav_pafyc/icons/qgis-icon.png"))
        self.ui.comboBox_fileResults.setItemIcon(6, QIcon(":/plugins/pflip_uav_pafyc/icons/pdf.png"))

        self.ui.comboBox_fileResults.setEnabled(True)

    def fill_combo_firmware(self, path):
        """
        brief: rellena el comboBox UAV model (UAV & firmware version) a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values firmware
        """
        # vacia el combo
        self.ui.comboBox_Firmware.clear()

        # añade la primera línea
        self.ui.comboBox_Firmware.addItem("--- Select UAV & firmware version ---")

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_firmware, des_firmware FROM firmware WHERE is_obsolete = 0 ORDER BY id_firmware ASC"
        cursor_db_project.execute(str_sql)

        # incializa matriz asociativa
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_firmware_id = row[0]  # key
            current_description_firmware = row[1]  # value
            dictionary[current_firmware_id] = current_description_firmware
            self.ui.comboBox_Firmware.addItem(row[1])  # añade value al combobox

        con_db_project.close()  # cierra la base de datos
        return dictionary

    def fill_combo_lnd_points(self, path):
        """
        Brief:
        """
        # vacia el combo
        self.ui.comboBox_lndPoints.clear()

        # añade la primera línea
        self.ui.comboBox_lndPoints.addItem("--- Select landing point ---")
        self.ui.comboBox_lndPoints.addItem("Take off point")
        # self.ui.comboBox_lndPoints.addItem("Last way point")

        # conexión con la base de datos que contiene los crs
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_c_lnd FROM c_lnd ORDER BY id_c_lnd ASC"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            str_current_id_c_lnd = str(row[0])  # key
            self.ui.comboBox_lndPoints.addItem(str_current_id_c_lnd)  # añade value al combobox

        self.set_index_combo_landing_point(cursor_db_project)
        con_db_project.close()  # cierra la base de datos con crs por defecto de qgis

    def fill_combo_mounting_type(self, path):
        """
        brief: rellena el comboBox UAV yaw attitude a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values
        """
        # vacia el combo
        self.ui.comboBox_mountingType.clear()

        # habilita el combobox y añade la primera línea
        self.ui.comboBox_mountingType.setEnabled(True)
        self.ui.comboBox_mountingType.addItem("--- Select UAV yaw attitude ---")

        # conexión con la base de datos template
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_mounting_type, def_mounting_type FROM flight_block_mounting_type ORDER BY def_mounting_type ASC"
        cursor_db_project.execute(str_sql)

        # inicializa matriz asociativa con el par id montaje tipo (key) - descripción montaje (value)
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_id_mounting_type = row[0]  # key
            current_def_mounting_type = row[1]  # value
            dictionary[current_id_mounting_type] = current_def_mounting_type

            self.ui.comboBox_mountingType.addItem(current_def_mounting_type)  # añade value al combobox

        con_db_project.close()  # cierra la base de datos template
        return dictionary


    def fill_combo_nbk(self, path):
        """
        brief: rellena el comboBox No Braking a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values
        """
        # vacia el combo
        self.ui.comboBox_NBK.clear()

        # añade la primera línea
        self.ui.comboBox_NBK.addItem("---  Select option  ---")

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_nbk,des_nbk FROM flight_block_nbk ORDER BY id_nbk ASC"
        cursor_db_project.execute(str_sql)

        # incializa matriz asociativa con el par identificador interno de qgis (key) - descripcion (value)
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_nbk_key = row[0]  # key
            current_nbk_value = row[1]  # value
            dictionary[current_nbk_key] = current_nbk_value

            self.ui.comboBox_NBK.addItem(current_nbk_value)  # añade value al combobox

        con_db_project.close()  # cierra la base de datos
        return dictionary

    def fill_combo_nemo_flight_block(self, path):
        """
        Brief: rellena el combobox con los nombres cortos de los bloques de vuelo grabados en la base de datos
        """
        self.filling_combo_flight_block = True
        self.ui.comboBox_FlightBlock.clear()
        self.ui.comboBox_FlightBlock.addItem("--- Select flight block ---")
        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT cod_flight_block,id_process_st FROM flight_block ORDER by cod_flight_block ASC"
        cursor_db_project.execute(str_sql)

        num_fb = 1
        for row in cursor_db_project.fetchall():
            nemo = row[0]
            status_process = row[1]
            self.ui.comboBox_FlightBlock.addItem(nemo)  # añade nemo al combobox
            if status_process == 1:
                self.ui.comboBox_FlightBlock.setItemIcon(num_fb,
                                                         QIcon(":/plugins/pflip_uav_pafyc/icons/apply.png"))
            if status_process == 0:
                self.ui.comboBox_FlightBlock.setItemIcon(num_fb,
                                                         QIcon(":/plugins/pflip_uav_pafyc/icons/quick_restart.png"))
            num_fb = num_fb + 1

        con_db_project.close()  # cierra la base de datos
        self.filling_combo_flight_block = False

    def fill_combo_shp_points(self, path):
        """
        brief:
        """
        # vacia el combo
        self.ui.comboBox_SHP.clear()

        # añade la primera línea
        self.ui.comboBox_SHP.addItem("--- Select homing position ---")
        self.ui.comboBox_SHP.addItem("Take-off point (default)")
        self.ui.comboBox_SHP.addItem("Landing point")

        """
        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos         
        str_sql = "SELECT id_c_lnd FROM c_lnd ORDER BY id_c_lnd ASC"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            str_current_id_c_lnd = str(row[0]) # key
            self.ui.comboBox_SHP.addItem(str_current_id_c_lnd) #añade value al combobox        

        self.set_index_combo_shp(cursor_db_project)
        con_db_project.close() #cierra la base de datos
        """

    def fill_combo_trajectory_type(self, path):
        """
        brief: rellena el comboBox UAV trajectory a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values
        """

        # vacia el combo
        self.ui.comboBox_trajectoryType.clear()

        # añade la primera línea
        self.ui.comboBox_trajectoryType.addItem("--- Select trajectory type ---")

        # conexión con la base de datos que contiene los tipos de vuelo
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_trajectory_type,def_trajectory_type FROM flight_block_trajectory_type ORDER BY id_trajectory_type ASC"
        cursor_db_project.execute(str_sql)

        # incializa matriz asociativa con el par identificador interno de qgis (key) - descripcion (value)
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_key_trajectory_type = row[0]  # key
            # if current_key_trajectory_type == 2: # 20170114 Tipo 2 (deltaV/deltaH)es obsoleta
            #    continue
            current_description_trajectory_type = row[1]  # value
            dictionary[current_key_trajectory_type] = current_description_trajectory_type

            self.ui.comboBox_trajectoryType.addItem(current_description_trajectory_type)  # añade value al combobox

        con_db_project.close()  # cierra la base de datos
        return dictionary

    def fill_combo_tof_points(self, path):
        """
        Brief:
        """
        # vacia el combo
        self.ui.comboBox_tofPoints.clear()

        # añade la primera línea
        self.ui.comboBox_tofPoints.addItem("--- Select take off point ---")

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_c_tof FROM c_tof ORDER BY id_c_tof ASC"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            str_current_id_c_tof = str(row[0])  # key
            self.ui.comboBox_tofPoints.addItem(str_current_id_c_tof)  # añade value al combobox

        self.set_index_combo_takeoff_point(cursor_db_project)
        con_db_project.close()  # cierra la base de datos

    def fill_combo_type_gimbal_mount(self, path):
        """
        brief: rellena el comboBox type of gimbal mount a partir de los datos almacenados en la tabla correspondiente de la BD plantilla
        param[in]: path de la BD plantilla
        return: diccionario con keys-values
        """
        # vacia el combo
        self.ui.comboBox_typeGimbalMount.clear()

        # añade la primera línea
        self.ui.comboBox_typeGimbalMount.addItem("--- Select type of gimbal mount ---")

        # conexión con la base de datos que contiene los tipos de vuelo
        con_db_project = self.db_op.connection_sqlite(path)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_type_gimbal_mount,def_type_gimbal_mount FROM flight_block_type_gimbal_mount ORDER BY id_type_gimbal_mount ASC"
        cursor_db_project.execute(str_sql)

        # incializa matriz asociativa con el par identificador interno de qgis (key) - descripcion (value)
        dictionary = {}

        for row in cursor_db_project.fetchall():
            current_key_type_gimbal_mount = row[0]  # key
            current_description_type_gimbal_mount = row[1]  # value
            dictionary[current_key_type_gimbal_mount] = current_description_type_gimbal_mount

            self.ui.comboBox_typeGimbalMount.addItem(current_description_type_gimbal_mount)  # añade value al combobox

        con_db_project.close()  # cierra la base de datos
        return dictionary

    def fill_combo_id_vector(self,
                             path_db_project):
        """
        brief:
        """
        self.ui.comboBox_idVector.clear()  # vacia el combo
        self.ui.comboBox_idVector.addItem("- Select vector -")  # añade la primera línea

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_c_vector FROM %s ORDER BY id_c_vector ASC" % c.CONST_PFLIPUAV_LAYER_VECTOR
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            str_id_vector = str(row[0]) # key
            self.ui.comboBox_idVector.addItem(str_id_vector)  # añade value al combobox

        self.set_index_combo_vector(cursor_db_project)
        con_db_project.close()

    def fill_combo_id_zone(self,
                           path_db_project):
        """
        Brief:
        """
        self.ui.comboBox_idZone.clear()  # vacia el combo
        self.ui.comboBox_idZone.addItem("--- Select zone ---")  # añade la primera línea

        # conexión con la base de datos que contiene los crs
        con_db_project = self.db_op.connection_sqlite(path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT id_c_zone FROM %s ORDER BY id_c_zone ASC" % c.CONST_PFLIPUAV_LAYER_ZONE
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            str_id_zone = str(row[0])  # key
            self.ui.comboBox_idZone.addItem(str_id_zone)  # añade value al combobox

        self.set_index_combo_zone(cursor_db_project)
        con_db_project.close()

    def fill_sensors_sqlite_from_csv_file(self,
                                          path_csv_file,
                                          path_db_project):
        # consulta sensors grabados en bd sqlite y almacena en una lista las keys
        list_cod_camera_sqlite = []
        con_db_project = self.db_op.connection_sqlite(path_db_project)
        cursor_db_project = con_db_project.cursor()
        str_sql = "SELECT cod_camera FROM camera"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            list_cod_camera_sqlite.append(row[0])

        list_to_db = []
        file_csv_sensors = open(path_csv_file, 'r')
        with file_csv_sensors:
            reader = csv.reader(file_csv_sensors, delimiter=';')
            next(reader, None)  # skip the headers
            for current_csv_sensor in reader:
                current_cod_camera_csv = current_csv_sensor[0]
                list_current_camera_to_db = []
                if current_cod_camera_csv not in list_cod_camera_sqlite:
                    trademark_csv = current_csv_sensor[1]
                    rows_csv = current_csv_sensor[2]
                    columns_csv = current_csv_sensor[3]
                    focal_csv = current_csv_sensor[4]
                    geometric_res = current_csv_sensor[5]
                    coor_x_ppa = current_csv_sensor[6]
                    coor_y_ppa = current_csv_sensor[7]
                    list_current_camera_to_db.append(current_cod_camera_csv)
                    list_current_camera_to_db.append(trademark_csv)
                    list_current_camera_to_db.append(rows_csv)
                    list_current_camera_to_db.append(columns_csv)
                    list_current_camera_to_db.append(focal_csv)
                    list_current_camera_to_db.append(geometric_res)
                    list_current_camera_to_db.append(coor_x_ppa)
                    list_current_camera_to_db.append(coor_y_ppa)
                    list_to_db.append(list_current_camera_to_db)

        if len(list_to_db) > 0:
            cursor_db_project.executemany("INSERT INTO camera (cod_camera, trademark, rows, columns, focal, geometric_res, coor_x_ppa, coor_y_ppa) VALUES (?,?,?,?,?,?,?,?);", list_to_db)
            con_db_project.commit()
        con_db_project.close()  # cierra la base de datos

    def fill_tableview_axis(self):
        """
        brief: rellena la tabla que enlaza vectores y zonas
        """
        db = QtSql.QSqlDatabase.addDatabase('QSQLITE')
        db.setDatabaseName(self.path_db_project)
        db.open()

        self.model_axis = QtSql.QSqlTableModel(self.ui,
                                               db)
        self.model_axis.setTable("flight_block_c_axis")
        filter = "cod_flight_block = '" + self.cod_flight_block_dlg + "'"
        self.model_axis.setFilter(filter)
        self.model_axis.setHeaderData(0, Qt.Horizontal, "Id.")
        self.model_axis.setHeaderData(1, Qt.Horizontal, "Cod. Flight Block")
        self.model_axis.setHeaderData(2, Qt.Horizontal, "Id. Axis")
        self.model_axis.select()

        tableview = self.ui.tableView_segments
        tableview.setModel(self.model_axis)
        # tableview.setSortingEnabled(True)
        tableview.resizeColumnsToContents()
        tableview.show()

        db.close()

    def fill_tableview_axis_processed_summary(self):
        """
        """
        db = QtSql.QSqlDatabase.addDatabase('QSQLITE')
        db.setDatabaseName(self.path_db_project)
        db.open()

        str_sql = "SELECT flight_block_c_axis.id_axis, c_axis.length, c_axis.cod_segment, flight_block.id_process_st" + "\n"
        str_sql += "FROM (flight_block_c_axis INNER JOIN c_axis ON flight_block_c_axis.id_axis = c_axis.id_c_axis) INNER JOIN flight_block ON c_axis.cod_segment = flight_block.cod_flight_block" + "\n"
        str_sql += "WHERE (((flight_block_c_axis.cod_flight_block)=\""
        str_sql += self.cod_flight_block_dlg + "\"));"

        qsqlquery = QtSql.QSqlQuery()
        qsqlquery.exec_(str_sql)

        model = QtSql.QSqlTableModel(self.ui,
                                     db)
        model.setQuery(qsqlquery)

        model.setHeaderData(0, Qt.Horizontal, "Id. Axis")
        model.setHeaderData(1, Qt.Horizontal, "Length")
        model.setHeaderData(2, Qt.Horizontal, "Cod. Segment")
        model.setHeaderData(3, Qt.Horizontal, "Process statatus")
        model.select()

        tableview = self.ui.tableView_axisProcessedSummary
        tableview.setModel(model)
        tableview.setSortingEnabled(True)
        tableview.resizeColumnsToContents()
        tableview.resizeRowsToContents()
        tableview.show()

        db.close()

    def final_actions_process_ko(self):
        """
        Brief: acciones finales procesamiento KO
        """
        # graba en tabla [flight_block] el estado de procesado
        str_sql = "UPDATE flight_block SET id_process_st = 0 WHERE cod_flight_block = '"
        str_sql += self.str_code_flight_block + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        # botones a nivel de bloque de vuelo
        self.ui.toolButton_Planning.setEnabled(True)
        if self.int_photogrammetric_mission_type == 3:
            self.ui.toolButton_Planning.setToolTip("Prepare flight blocks")
            self.ui.toolButton_Planning.setIcon(QIcon(":/plugins/pflip_uav_pafyc/icons/kservices.png"))
        else:
            self.ui.toolButton_Planning.setToolTip("Process flight block")
            self.ui.toolButton_Planning.setIcon(QIcon(":/plugins/pflip_uav_pafyc/icons/processing.png"))
        self.ui.toolButton_CopyParameter.setEnabled(False)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(0, True)  # pestaña project data definition
        self.ui.groupBox_generalData.setEnabled(True)
        #self.ui.groupBoxSpatialData.setEnabled(True)
        self.ui.mGroupBox_spatialData.setCollapsed(False)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(1, True)  # pestaña geometric navigation parameters
        self.ui.groupBox_GeometricParameters.setEnabled(True)
        self.ui.groupBox_UAVNavigationParameters.setEnabled(True)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(2, True)  # pestaña imaging adqisition parameters
        self.ui.groupBox_OnBoardSensor.setEnabled(True)
        self.ui.groupBox_sensorAttitude.setEnabled(True)
        self.ui.groupBox_ImagingAcqParameters.setEnabled(True)
        self.ui.label_SensorPositionAccuracy.setEnabled(True)
        self.ui.doubleSpinBox_accGps.setEnabled(True)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(3, True)  # pestaña security parameters
        self.ui.groupBox_GeneralSecurityParameters.setEnabled(True)
        self.ui.groupBox_settingSpecialTasks.setEnabled(True)
        self.ui.groupBox_optionalsParameters.setEnabled(True)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(4, False)  # pestaña processing results
        self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(5, False)  # pestaña ground control planning

        # deshabilita combobox con fichero de resultados
        self.ui.comboBox_fileResults.setEnabled(False)
        self.ui.pushButton_processReport.setEnabled(False)

        # actualiza icon estado de procesamiento
        index_fb_no_procesado = self.ui.comboBox_FlightBlock.currentIndex()
        self.ui.comboBox_FlightBlock.setItemIcon(index_fb_no_procesado,
                                                 QIcon(":/plugins/pflip_uav_pafyc/icons/quick_restart.png"))

    def final_actions_process_ok(self,
                                 is_mission_type_paflr=False):
        """
        Brief: acciones finales procesamiento OK
        """
        # graba en tabla [flight_block] el estado de procesado
        str_sql = "UPDATE flight_block SET id_process_st = 1 WHERE cod_flight_block = '"
        str_sql += self.str_code_flight_block + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        self.ui.page_ProcessingResults.setEnabled(True)

        # botones a nivel de bloque de vuelo
        self.ui.toolButton_Planning.setEnabled(False)
        self.ui.toolButton_CopyParameter.setEnabled(True)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(0, True)  # pestaña project data definition
        self.ui.groupBox_generalData.setEnabled(False)
        #self.ui.groupBoxSpatialData.setEnabled(False)
        # self.ui.mGroupBox_spatialData.setCollapsed(True)
        self.ui.mGroupBox_spatialData.setCollapsed(False) #dhl

        self.ui.toolBox_currentFlightBlock.setItemEnabled(1, True)  # pestaña geometric navigation parameters
        self.ui.groupBox_GeometricParameters.setEnabled(False)
        self.ui.groupBox_UAVNavigationParameters.setEnabled(False)
        # self.ui.mGroupBox_geometricNavigationParameters.setCollapsed(True)
        self.ui.mGroupBox_geometricNavigationParameters.setCollapsed(False) #dhl

        self.ui.toolBox_currentFlightBlock.setItemEnabled(2, True)  # pestaña imaging adqisition parameters
        self.ui.groupBox_OnBoardSensor.setEnabled(False)
        self.ui.groupBox_sensorAttitude.setEnabled(False)
        self.ui.groupBox_ImagingAcqParameters.setEnabled(False)
        self.ui.label_SensorPositionAccuracy.setEnabled(False)
        self.ui.doubleSpinBox_accGps.setEnabled(False)
        # self.ui.mGroupBox_imagingAcquisitionParameters.setCollapsed(True)
        # self.ui.mGroupBox_calculatedParametersGSD.setCollapsed(True)
        self.ui.mGroupBox_imagingAcquisitionParameters.setCollapsed(False) #dhl
        self.ui.mGroupBox_calculatedParametersGSD.setCollapsed(False) #dhl

        self.ui.toolBox_currentFlightBlock.setItemEnabled(3, True)  # pestaña security parameters
        self.ui.groupBox_GeneralSecurityParameters.setEnabled(False)
        self.ui.groupBox_settingSpecialTasks.setEnabled(False)
        self.ui.groupBox_optionalsParameters.setEnabled(False)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(4, True)  # pestaña processing results
        self.ui.toolBox_currentFlightBlock.setCurrentIndex(4)

        self.ui.toolBox_currentFlightBlock.setItemEnabled(5, False)  # pestaña ground control planning
        self.ui.mGroupBox_processingResults.setCollapsed(False)
        self.ui.mGroupBox_processingResults.setEnabled(True)

        if not is_mission_type_paflr:
            # habilita combobox con fichero de resultados
            self.fill_combo_file_results()
            self.ui.comboBox_fileResults.setEnabled(True)
            self.ui.pushButton_processReport.setEnabled(True)
            self.ui.groupBox_DuracionDelVuelo.setVisible(False) # dhl 20220203
            self.ui.mGroupBox_axisProccessedSummary.setVisible(False)
        else:  # Polygonal area from lineal route
            self.fill_tableview_axis_processed_summary()
            self.ui.comboBox_fileResults.setEnabled(False)
            self.ui.pushButton_processReport.setEnabled(False)
            self.ui.groupBox_DuracionDelVuelo.setVisible(False)
            self.ui.mGroupBox_axisProccessedSummary.setVisible(True)

        # actualiza icon estado de procesamiento
        index_fb_procesado = self.ui.comboBox_FlightBlock.currentIndex()
        self.ui.comboBox_FlightBlock.setItemIcon(index_fb_procesado, QIcon(":/plugins/pflip_uav_pafyc/icons/apply.png"))

        # deshabilita botón procesado
        self.ui.toolButton_Planning.setEnabled(False)
        self.ui.toolButton_CopyParameter.setEnabled(True)

    def get_variables_panel(self):
        """
        Brief:  Comprueba que los parámetros introducidos en el panel son correctos
                y escribe en el fichero de salida los valores de entrada del procesamiento
        """

        # si existe fichero eliminarlo
        try:
            os.remove(self.path_file_results)
        except OSError:
            pass

        # abre fichero para escritura
        self.file_results = open(self.path_file_results, "w")

        # *** escribe la CABECERA del proyecto PLIPUAV ***
        # recupera variables del proyecto desde base de datos
        path_project_store_in_db, \
        nemo, title, \
        author, \
        path_db_project_store_in_db, \
        str_idinternal_crs_proyect, \
        company, \
        path_logo, \
        path_logo_2 = self.db_op.get_project_header_data(self.path_db_project)

        msg_information_crs = self.q3_api_op.metadata_crs_object(self.str_idinternal_crs_proyect)

        # formateo msg para salida a fichero
        msg_header_data_project = "*** INPUT DATA ***\n"
        msg_header_data_project += "0.- HEADER DATA PROJECT\n"
        msg_header_data_project += "\tNemo: " + nemo + "\n"
        msg_header_data_project += "\tTitle: " + title + "\n"
        msg_header_data_project += "\tAuthor: " + author + "\n"
        msg_header_data_project += "\tCompany: " + company + "\n"
        msg_header_data_project += "\tPath logo: " + path_logo + "\n"
        msg_header_data_project += "\tPath logo: " + path_logo_2 + "\n"
        msg_header_data_project += "\tPath sqlite database: '" + path_db_project_store_in_db + "'\n"
        msg_header_data_project += "\tCRS information project: " + msg_information_crs + "\n"
        self.file_results.writelines(msg_header_data_project)

        # Escribe el código de bloque de vuelo a procesar
        if (self.ui.comboBox_FlightBlock.currentIndex() == 0):
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select flight block code",
                                                Qgis.Critical,
                                                10)

            self.file_results.close()
            return False

        self.str_code_flight_block = self.ui.comboBox_FlightBlock.currentText()
        str_msg_input_data = "FLIGHT BLOCK CODE PROCESS: " + self.str_code_flight_block + "\n\n"
        self.file_results.write(str_msg_input_data)

        # *** PROJECT DATA DEFINITION ***
        str_msg_input_data = "1.- PROJECT DATA DEFINITION\n"
        str_msg_input_data += "\t1.1.- General data\n"

        # Tipo de vuelo o aerial mission
        if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
            str_msg_input_data += "\t\t%s\n" % c.CONST_MISSION_TYPE_LINEAL
            self.file_results.writelines(str_msg_input_data)

        if self.int_photogrammetric_mission_type == 2:  # vuelo zonal
            str_msg_input_data += "\t\t%s\n" % c.CONST_MISSION_TYPE_ZONAL
            self.file_results.writelines(str_msg_input_data)

        if self.int_photogrammetric_mission_type == 3:  # tPrepare flight blocks from lineal axis segmentation
            str_msg_input_data += "\t\t%s\n" % c.CONST_MISSION_TYPE_PREPARE_FLIGHT_BLOCKS
            self.file_results.writelines(str_msg_input_data)

        # firmware
        if self.ui.comboBox_Firmware.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select UAV model",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
            self.file_results.close()
            return False
        else:
            str_define_firmware_version = self.ui.comboBox_Firmware.currentText()
            str_msg_input_data = "\t\tUAV model & firmware version: " + str_define_firmware_version + "\n"
            self.file_results.write(str_msg_input_data)

        str_msg_input_data = "\t1.2.- Spatial Data\n"

        # tof point
        if self.ui.comboBox_tofPoints.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select take off point",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
            self.file_results.close()
            return False
        else:
            str_id_tof_point = self.ui.comboBox_tofPoints.currentText()
            str_msg_input_data += "\t\tTake off point code: " + str_id_tof_point + "\n"
            self.file_results.writelines(str_msg_input_data)

            # lnd point
        if self.ui.comboBox_lndPoints.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select landing point",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
            self.file_results.close()
            return False
        else:
            str_id_lnd_point = self.ui.comboBox_lndPoints.currentText()
            str_msg_input_data = "\t\tLanding point code: " + str_id_lnd_point + "\n"
            self.file_results.write(str_msg_input_data)


        # segments axis
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()
        str_sql = "SELECT * FROM flight_block_c_axis WHERE cod_flight_block = '" + self.str_code_flight_block + "'"
        cursor_db_project.execute(str_sql)
        num_segments_axis = 0  # contador para el número de zonas a procesar

        for row in cursor_db_project.fetchall():
            num_segments_axis = num_segments_axis + 1

        con_db_project.close()

        if num_segments_axis == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No axis defined",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
            self.file_results.close()
            return False



        if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
            # LineaL segments enlargement
            # lineal_segments_enlargement = self.ui.doubleSpinBox_linealEnlargement.value()
            # str_lineal_segments_enlargement = str(lineal_segments_enlargement)
            str_msg_input_data = "\t\tLineal segments enlargement: disabled  m.\n"
            self.file_results.write(str_msg_input_data)

        if self.int_photogrammetric_mission_type == 2:  # vuelo zonal
            # LineaL zone enlargement
            lineal_zone_magnification = self.ui.doubleSpinBox_linealEnlargement.value()
            str_lineal_zone_magnification = str(lineal_zone_magnification)
            str_msg_input_data = "\t\tLineal zone enlargement: " + str_lineal_zone_magnification + " m.\n"
            self.file_results.write(str_msg_input_data)

        # path dtm
        str_path_dtm = self.ui.lineEdit_pathDTM.text()
        if len(str_path_dtm) == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select path DTM",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
            self.file_results.close()
            return False
        else:
            # obtiene los metadatos del CRS del DTM para el informe
            str_msg_input_data = "\t\tPath DTM: '" + str_path_dtm + "'\n"
            # str_msg_input_data += "\t\tDTM CRS:" + self.msg_metadata_crs_dtm + "\n"
            self.file_results.writelines(str_msg_input_data)

            # *** IMAGING ACQUISITION PARAMETERS ***

            str_msg_input_data = "2.- IMAGING ACQUISITION PARAMETERS\n"
            str_msg_input_data += "\t2.1- On board Sensor\n"

            # camera
            if self.ui.comboBox_Camera.currentIndex() == 0:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Select sensor",
                                                    Qgis.Critical,
                                                    10)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
                self.file_results.close()
                return False
            else:
                str_cod_camera = self.ui.comboBox_Camera.currentText()
                str_msg_input_data += "\t\tData sensor code: " + str_cod_camera + "\n"
                self.get_variables_camera(str_cod_camera)
                str_msg_input_data += "\t\t\t- Trademark: " + self.str_cam_trademark + "\n"
                str_msg_input_data += "\t\t\t- Rows: " + self.str_cam_rows + "\n"
                str_msg_input_data += "\t\t\t- Columns: " + self.str_cam_columns + "\n"
                str_msg_input_data += "\t\t\t- Focal: " + self.str_cam_focal + "\n"
                str_msg_input_data += "\t\t\t- Geometric resolution: " + self.str_cam_geom_resolution + "\n"
                str_msg_input_data += "\t\t\t- xPPA: " + self.str_cam_xppa + "\n"
                str_msg_input_data += "\t\t\t- yPPA: " + self.str_cam_yppa + "\n"
                self.file_results.writelines(str_msg_input_data)

            str_msg_input_data = "\t2.2- Sensor attitude\n"

            # type of gimbal mount
            if self.ui.comboBox_typeGimbalMount.currentIndex() == 0:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Select type of gimbal mount",
                                                    Qgis.Critical,
                                                    10)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(2)
                self.file_results.close()
                return False
            else:
                str_type_gimbal_mount = self.ui.comboBox_typeGimbalMount.currentText()
                str_msg_input_data += "\t\t- Type of gimbal mount: " + str_type_gimbal_mount + "\n"
                self.file_results.writelines(str_msg_input_data)

                # omega angle
            omega_angle = self.ui.doubleSpinBox_omegaAngle.value()
            str_omega_angle = str(omega_angle)
            str_msg_input_data = "\t\t- Omega Angle: " + str_omega_angle + "DEG.\n"
            self.file_results.write(str_msg_input_data)

            # phi angle
            phi_angle = self.ui.doubleSpinBox_phiAngle.value()
            str_phi_angle = str(phi_angle)
            str_msg_input_data = "\t\t- Phi Angle: " + str_phi_angle + "DEG.\n"
            self.file_results.write(str_msg_input_data)

            # mount offset omega
            offset_omega = self.ui.doubleSpinBox_offsetOmega.value()
            str_offset_omega = str(offset_omega)
            str_msg_input_data = "\t\t- Mount attitude offset Omega: " + str_offset_omega + "DEG\n"
            self.file_results.write(str_msg_input_data)

            # mount offset phi
            offset_phi = self.ui.doubleSpinBox_offsetPhi.value()
            str_offset_phi = str(offset_phi)
            str_msg_input_data = "\t\t- Mount attitude offset Phi: " + str_offset_phi + "DEG\n"
            self.file_results.write(str_msg_input_data)

            # mount offset kappa
            offset_kappa = self.ui.doubleSpinBox_offsetKappa.value()
            str_offset_kappa = str(offset_kappa)
            str_msg_input_data = "\t\t- Mount attitude offset Kappa: " + str_offset_kappa + "DEG\n"
            self.file_results.write(str_msg_input_data)

            # precision omega
            if self.ui.doubleSpinBox_accOmega.isEnabled() == False:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Accuracy omega(select onboard sensor, gimbal mount and yaw angle)",
                                                    Qgis.Critical,
                                                    10)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(2)
                self.file_results.close()
                return False
            else:
                omega_precision = self.ui.doubleSpinBox_accOmega.value()
                str_omega_precision = str(omega_precision)
                str_msg_input_data = "\t\t- Sensor attitude accuracy Omega: " + str_omega_precision + " DEG\n"
                self.file_results.write(str_msg_input_data)

                # precision phi
            if self.ui.doubleSpinBox_accPhi.isEnabled() == False:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Accuracy phi(select onboard sensor, gimbal mount and yaw angle)",
                                                    Qgis.Critical,
                                                    10)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(2)
                self.file_results.close()
                return False
            else:
                phi_precision = self.ui.doubleSpinBox_accPhi.value()
                str_phi_precision = str(phi_precision)
                str_msg_input_data = "\t\t- Sensor attitude accuracy Phi: " + str_phi_precision + " DEG\n"
                self.file_results.write(str_msg_input_data)

            # precision kappa
            if self.ui.doubleSpinBox_accKappa.isEnabled() == False:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Accuracy kappa(select gimbal mount)",
                                                    Qgis.Critical,
                                                    10)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(2)
                self.file_results.close()
                return False
            else:
                kappa_precision = self.ui.doubleSpinBox_accKappa.value()
                str_kappa_precision = str(kappa_precision)
                str_msg_input_data = "\t\t- Sensor attitude accuracy Kappa: " + str_kappa_precision + " DEG\n"
                self.file_results.write(str_msg_input_data)

            # precisión GPS
            gps_precision = self.ui.doubleSpinBox_accGps.value()
            str_gps_precision = str(gps_precision)
            str_msg_input_data = "\t\t- Sensor Position Accuracy: " + str_gps_precision + " m.\n"
            self.file_results.write(str_msg_input_data)

            # mounting type or yaw angle
            if self.ui.comboBox_mountingType.currentIndex() == 0:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Select yaw angle",
                                                    Qgis.Critical,
                                                    10)
                self.ui.toolBox_currentFlightBlock.setCurrentIndex(1)
                self.file_results.close()
                return False
            else:
                str_yaw_angle = self.ui.comboBox_mountingType.currentText()
                str_msg_input_data = "\t\t- Yaw angle: " + str_yaw_angle + "\n"
                self.file_results.write(str_msg_input_data)

            str_msg_input_data = "\t2.3.- Shooting parameters\n"
            self.file_results.write(str_msg_input_data)

            # shot interval
            shot_interval = self.ui.doubleSpinBox_shotInterval.value()
            str_shot_interval = str(shot_interval)
            str_msg_input_data = "\t\t- Hold time in mandatory stop waypoints before trigger: " + str_shot_interval + "s.\n\n"
            self.file_results.write(str_msg_input_data)

        # *** GEOMETRIC NAVIGATION PARAMETERS ***
        str_msg_input_data = "3.- GEOMETRIC NAVIGATION PARAMETERS\n"
        str_msg_input_data += "\t3.1.- Flight planning: Geometric Parameters\n"

        # GSD
        gsd = self.ui.doubleSpinBox_gsd.value()
        str_gsd = str(gsd)
        str_msg_input_data += "\t\t- GSD: " + str_gsd + " m.\n"
        self.file_results.writelines(str_msg_input_data)

        # Tolerance GSD
        if self.ui.comboBox_trajectoryType.currentIndex() > 2:  # 20190105: Vstrategies 3, 4 y 5
            self.ui.doubleSpinBox_tolGsd.setValue(0)  # Pone tolerancia gsd = 0 en reprocesamientos
        tol_gsd = self.ui.doubleSpinBox_tolGsd.value()
        str_tol_gsd = str(tol_gsd)
        str_msg_input_data = "\t\t- GSD tolerance: " + str_tol_gsd + " %\n"
        self.file_results.write(str_msg_input_data)

        # Buffer (sólo para vuelo lineal)
        if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
            buffer = self.ui.doubleSpinBox_bufferLinealFlight.value()
            str_buffer = str(buffer)
            str_msg_input_data = "\t\t- Buffer (lineal route): " + str_buffer + " m.\n"
            self.file_results.write(str_msg_input_data)

        # Number of strips (sólo para vuelo lineal)
        if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
            n_strips = self.ui.spinBox_nStrips.value()
            str_n_strips = str(n_strips)
            str_msg_input_data = "\t\t- Number of strips (linear route): " + str_n_strips + " m.\n"
            self.file_results.write(str_msg_input_data)

        # Points by footprint side
        str_points_by_footprint_side = self.ui.comboBox_numberOfPointsInSideFrame.currentText()
        str_msg_input_data = "\t\t- Points by footprint side: " + str_points_by_footprint_side + "\n"
        self.file_results.write(str_msg_input_data)

        # Foward overlap
        overlap_fwd = self.ui.doubleSpinBox_overlapFwd.value()
        str_overlap_fwd = str(overlap_fwd)
        str_msg_input_data = "\t\t- Forward overlap: " + str_overlap_fwd + " %\n"
        self.file_results.write(str_msg_input_data)

        # Side overlap
        if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
            str_msg_input_data = "\t\t- Side overlap: - \n"
            self.file_results.write(str_msg_input_data)

        if self.int_photogrammetric_mission_type == 2:  # vuelo zonal
            overlap_side = self.ui.doubleSpinBox_overlapSide.value()
            str_overlap_side = str(overlap_side)
            str_msg_input_data = "\t\t- Side overlap: " + str_overlap_side + " %\n"
            self.file_results.write(str_msg_input_data)

            # Fit_Axis
        if self.int_photogrammetric_mission_type == 1:
            if self.ui.checkBox_fitAxis.isChecked():
                str_msg_input_data = "\t\t- #Lineal trajectory matches de axis geometry:  Enabled\n"
                self.file_results.write(str_msg_input_data)
            else:
                str_msg_input_data = "\t\t- #Lineal trajectory matches de axis geometry:  Disabled\n"
                self.file_results.write(str_msg_input_data)

        str_msg_input_data = "\t3.2.- UAV navigation parameters\n"
        self.file_results.write(str_msg_input_data)

        # trajectory_type
        if self.ui.comboBox_trajectoryType.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select Vertical strategy",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(2)
            self.file_results.close()
            return False
        else:
            str_trajectory_type = self.ui.comboBox_trajectoryType.currentText()
            str_msg_input_data = "\t\t- UAV Vertical strategy: " + str_trajectory_type + "\n"
            self.file_results.write(str_msg_input_data)

        # Smooth_V
        if self.ui.checkBox_SmoothV.isChecked():
            str_msg_input_data = "\t\t- #Smooth Vertical Profile:  Enabled\n"
            self.file_results.write(str_msg_input_data)
        else:
            str_msg_input_data = "\t\t- #Smooth Vertical Profile:  Disabled\n"
            self.file_results.write(str_msg_input_data)

        # Cruising speed
        if self.ui.doubleSpinBox_speedCruising.isEnabled() == False:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Cruised speed enabled (Select UAV & firmware version)",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(1)
            self.file_results.close()
            return False
        else:
            cruising_speed = self.ui.doubleSpinBox_speedCruising.value()
            str_cruising_speed = str(cruising_speed)
            str_msg_input_data = "\t\t- Cruising speed: " + str_cruising_speed + " m/s\n"
            self.file_results.write(str_msg_input_data)

            # Ascent speed
        ascent_speed = self.ui.doubleSpinBox_speedAsc.value()
        str_ascent_speed = str(ascent_speed)
        str_msg_input_data = "\t\t- Ascent speed: " + str_ascent_speed + " m/s\n"
        self.file_results.write(str_msg_input_data)

        # Descent speed
        descent_speed = self.ui.doubleSpinBox_speedDes.value()
        str_descent_speed = str(descent_speed)
        str_msg_input_data = "\t\t- Descent speed: " + str_descent_speed + " m/s\n"
        self.file_results.write(str_msg_input_data)

        # No braking
        if self.ui.comboBox_NBK.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select Stop at every WP option",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(1)
            self.file_results.close()
            return False
        else:
            str_no_braking = self.ui.comboBox_NBK.currentText()
            str_msg_input_data = "\t\t- Stop at every waypoint: " + str_no_braking + "\n"
            self.file_results.write(str_msg_input_data)

        # Takeoff height
        takeoff_height = self.ui.doubleSpinBox_heightStart.value()
        str_takeoff_height = str(takeoff_height)
        str_msg_input_data = "\t\t- Takeoff: Offset height from DTM altitude: " + str_takeoff_height + " m.\n"
        self.file_results.write(str_msg_input_data)

        # Height at the end of a route
        landing_height = self.ui.doubleSpinBox_heightEnd.value()
        str_landing_height = str(landing_height)
        str_msg_input_data = "\t\t- Landing: Safe height before landing ....: " + str_landing_height + " m.\n"
        self.file_results.write(str_msg_input_data)

        # Average height object
        average_height_object = self.ui.doubleSpinBox_averageHeightObject.value()
        str_average_height_object = str(average_height_object)
        str_msg_input_data = "\t\t- Average height object: " + str_average_height_object + " m.\n"
        self.file_results.write(str_msg_input_data)

        str_msg_input_data = "\t3.3.- Calculated parameters\n"

        # Theoretical flight altitude
        str_theoretical_flight_altitude = self.ui.lineEdit_theoreticalFlightAltitude.text()
        if len(str_theoretical_flight_altitude) > 0:
            str_msg_input_data += "\t\t- Theoretical flight altitude: " + str_theoretical_flight_altitude + " m.\n"
            self.file_results.writelines(str_msg_input_data)

        # Dimension of the image on the ground in the forward direction
        str_dim_terrain_fwd_direction = self.ui.lineEdit_dimensionHuellaDirAvance.text()
        if len(str_dim_terrain_fwd_direction) > 0:
            str_msg_input_data = "\t\t- Dimension of the image on the ground in the forward direction: " \
                                 + str_dim_terrain_fwd_direction + " m.\n"
            self.file_results.write(str_msg_input_data)

        # Dimension of the image on the ground in the side direction
        str_dim_terrain_side_direction = self.ui.lineEdit_dimensionHuellaDirSide.text()
        if len(str_dim_terrain_side_direction) > 0:
            str_msg_input_data = "\t\t- Dimension of the image on the ground in the side direction: " \
                                 + str_dim_terrain_side_direction + " m.\n\n"
            self.file_results.write(str_msg_input_data)

        # *** SAFETY PARAMETERS ***
        str_msg_input_data = "4.- SAFETY PARAMETERS\n"
        str_msg_input_data += "\t4.1.- Carabo S3 failsafe default actions\n"

        # erc
        if self.ui.comboBox_ERC.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select Failsafe Radio Control action  #FS_RC:",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(3)
            self.file_results.close()
            return False
        else:
            str_erc = self.ui.comboBox_ERC.currentText()
            str_msg_input_data += "\t\t- Failsafe Radio Control  #FS_RC: " + str_erc + "\n"
            self.file_results.writelines(str_msg_input_data)

        # eal
        if self.ui.comboBox_EAL.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select Failsafe Low Battery action. #FS_BAT",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(3)
            self.file_results.close()
            return False
        else:
            str_eal = self.ui.comboBox_EAL.currentText()
            str_msg_input_data = "\t\t- Failsafe Low Battery. #FS_BAT:: " + str_eal + "\n"
            self.file_results.write(str_msg_input_data)

        # eal
        if self.ui.comboBox_EGI.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select Failsafe GPS Invalid action  #FS_GPS:",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(3)
            self.file_results.close()
            return False
        else:
            str_egi = self.ui.comboBox_EGI.currentText()
            str_msg_input_data = "\t\t- Failsafe GPS Invalid  #FS_GPS: " + str_egi + "\n"
            self.file_results.write(str_msg_input_data)

        str_msg_input_data = "\t4.2.- Setting parameters & special task\n"

        # SHP
        if self.ui.comboBox_SHP.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select Homing Position #SHP",
                                                Qgis.Critical,
                                                10)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(3)
            self.file_results.close()
            return False
        else:
            str_shp = self.ui.comboBox_SHP.currentText()
            str_msg_input_data += "\t\t- Homing Position #SHP: " + str_shp + "\n"
            if self.ui.comboBox_SHP.currentIndex() == 2 and self.ui.comboBox_lndPoints.currentIndex() > 1:
                str_msg_input_data += "\t\t\t- # WARNING: Home point is different from Takeoff point" + "\n"
            self.file_results.writelines(str_msg_input_data)

            # SSH
        ssh = self.ui.doubleSpinBox_SSH.value()
        str_ssh = str(ssh)
        str_msg_input_data = "\t\t- Setting Secure Height #SSH: " + str_ssh + "m.\n"
        self.file_results.write(str_msg_input_data)

        # GPA
        gpa = self.ui.doubleSpinBox_GPA.value()
        str_gpa = str(gpa)
        str_msg_input_data = "\t\t- General Pos. Accuracy #GPA: " + str_gpa + "m.\n"
        self.file_results.write(str_msg_input_data)

        str_msg_input_data = "\t\t- Take-off and Landing parameters\n"

        # ITH
        if self.ui.doubleSpinBox_WAS.isEnabled():  # -> ITH: Unchecked -> takeoff height = WAS value
            was = self.ui.doubleSpinBox_WAS.value()
            str_was = str(was)
            str_msg_input_data += "\t\t\t- Take off Height: " + str_was + "m.\n"
            # self.file_results.writelines(str_msg_input_data)
        else:  # -> ITH: Checked
            str_msg_input_data += "\t\t\t- #ITH: Checked - Take off Height is the same as the 1st WP\n"
            # self.file_results.writelines(str_msg_input_data)

        # HBL
        if self.ui.doubleSpinBox_HBL.isEnabled():  # -> HBL: Unchecked
            hbl = self.ui.doubleSpinBox_HBL.value()
            str_hbl = str(hbl)
            str_msg_input_data += "\t\t\t- #HBL: " + str_hbl + "m.\n"
            # self.file_results.writelines(str_msg_input_data)
        else:  # -> HBL: Checked
            str_msg_input_data += "\t\t\t- #HBL: Checked - Height before landing is the same as the ending WP\n"
            # self.file_results.writelines(str_msg_input_data)

        # WAL
        if not self.ui.doubleSpinBox_WAL.isEnabled():  # -> WAL: Unchecked
            str_msg_input_data += "\t\t\t- AutoLanding action: Disabled\n"
            # self.file_results.write(str_msg_input_data)
        else:  # -> WAL: Checked
            wal = self.ui.doubleSpinBox_WAL.value()
            str_wal = str(wal)
            str_msg_input_data += "\t\t\t- AutoLanding action Enabled: " + str_wal + "m/s.\n\n"
            # self.file_results.write(str_msg_input_data)

        self.file_results.write(str_msg_input_data)
        self.file_results.close()
        return True

    def generate_multiple_axis_strips(self):
        """
        Herramienta para la generación de un eje multilineal
        """
        # comprobación de valores necesarios para el cálculo ***********************************************************
        if self.ui.comboBox_idVector.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No vector selected",
                                                Qgis.Warning,
                                                20)
            return
        # obtiene el entero id de la entidad a seleccionar
        str_current_id_vector = self.ui.comboBox_idVector.currentText()
        current_id_vector = int(str_current_id_vector)
        # obtiene coordenadas del eje
        list_qgspointxy_vertex_vector = self.q3_api_op.get_list_vertex_by_id_entity(self.path_db_project,
                                                                                    c.CONST_PFLIPUAV_LAYER_VECTOR,
                                                                                    "the_geom",
                                                                                    "name_display_table",
                                                                                    str_current_id_vector)
        if self.int_photogrammetric_mission_type == 2:  # para zonal mission el vector solo puede tener dos nodos
            if len(list_qgspointxy_vertex_vector) > 2:
                str_msg = "Selected vector has more than two vertex. Vector not supported for zonal flights"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Critical,
                                                    20)
                self.ui.comboBox_idVector.setCurrentIndex(0)
                return
        # zoom al vector
        self.q3_api_op.zoom_to_entity(self.path_db_project,
                                      "c_vector",
                                      "the_geom",
                                      "name_display_table",
                                      current_id_vector)

        if self.ui.comboBox_tofPoints.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No take-off point selected",
                                                Qgis.Warning,
                                                20)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)
            return
        else:
            id_tof = self.ui.comboBox_tofPoints.currentText()

        if self.ui.comboBox_Camera.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No sensor selected",
                                                Qgis.Warning,
                                                20)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(1)
            return

        if self.ui.comboBox_mountingType.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No sensor axis yaw selected",
                                                Qgis.Warning,
                                                20)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(1)
            return

        # geometría del vector en formato wkt
        vector_2d_wkt = "LINESTRING("  # geometría wkt en 2D
        for qgspointxy in list_qgspointxy_vertex_vector:
            vector_2d_wkt += "%s %s," % (qgspointxy.x(), qgspointxy.y())
        vector_2d_wkt = vector_2d_wkt[:-1]
        vector_2d_wkt = vector_2d_wkt + ")"
        qgsgeometry_vector = QgsGeometry.fromWkt(vector_2d_wkt)

        if self.int_photogrammetric_mission_type == 1:  # lineal mission
            n_strips = self.ui.spinBox_nStrips.value()

        # Dimension of the image on the ground in the forward direction perpendicular
        distance_perpendicular = float(self.ui.lineEdit_dimensionHuellaDirSide.text())  # FIXME: comprobar cálculos
        side_overlap = self.ui.doubleSpinBox_overlapSide.value() / 100.0  # recubrimiento transversal en tanto por uno
        dp = distance_perpendicular * (1 - side_overlap)  # distancia entre pasadas

        # calculo del numero de pasada para misiones zonales
        if self.int_photogrammetric_mission_type == 2:  # zonal mission
            if self.ui.comboBox_idZone.currentIndex() == 0:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "No zone selected",
                                                    Qgis.Warning,
                                                    20)
                return
            # get geometry zone
            str_current_id_zone = self.ui.comboBox_idZone.currentText()
            current_id_zone = int(str_current_id_zone)
            str_wkt_geom_zone = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                          c.CONST_PFLIPUAV_LAYER_ZONE,
                                                                          "the_geom",
                                                                          "name_display_table",
                                                                          current_id_zone)
            qgsgeometry_zone = QgsGeometry.fromWkt(str_wkt_geom_zone)
            lineal_zone_enlargement = self.ui.doubleSpinBox_linealEnlargement.value()
            qgsgeometry_zone_buffer = qgsgeometry_zone.buffer(lineal_zone_enlargement, 0)
            list_qgspointxy_vertex_zone = qgsgeometry_zone_buffer.asPolygon()

            # geometry centroid
            qgsgeometry_centroid_zone = qgsgeometry_zone.centroid()
            qgspointxy_centroid_zone = qgsgeometry_centroid_zone.asPoint()

            # traslacion vector al centroid zone
            qgspoint_original_vector_start = qgsgeometry_vector.vertexAt(0)
            x_qgspoint_original_vector_start = qgspoint_original_vector_start.x()
            y_qgspoint_original_vector_start = qgspoint_original_vector_start.y()
            dx = qgspointxy_centroid_zone.x() - x_qgspoint_original_vector_start
            dy = qgspointxy_centroid_zone.y() - y_qgspoint_original_vector_start
            qgsgeometry_vector.translate(dx, dy)
            qgspoint_vector_translate_centroid_start = qgsgeometry_vector.vertexAt(0)
            qgspoint_vector_translate_centroid_end = qgsgeometry_vector.vertexAt(1)

            # inicializa variables calculo distancia puntos zone al vector trasladado al centroide
            max_distance_point_zone_to_vector_translate_centroid = 0.0
            qgspoint_max_distance_point_zone_to_vector_translate_centroid = QgsPoint(0, 0)
            extent_distance = 10000.0
            qgspoint_extent_start = QgsGeometryUtils.pointOnLineWithDistance(qgspoint_vector_translate_centroid_end,
                                                                             qgspoint_vector_translate_centroid_start,
                                                                             extent_distance)
            qgspoint_extent_end = QgsGeometryUtils.pointOnLineWithDistance(qgspoint_vector_translate_centroid_start,
                                                                           qgspoint_vector_translate_centroid_end,
                                                                           extent_distance)

            for current_qgspointxy_zone in list_qgspointxy_vertex_zone[0]:
                current_qgspoint_proyectado = QgsGeometryUtils.projectPointOnSegment(QgsPoint(current_qgspointxy_zone),
                                                                                     qgspoint_extent_start,
                                                                                     qgspoint_extent_end)
                distance_current_point_zone_to_vector_translate_centroid = current_qgspoint_proyectado.distance(QgsPoint(current_qgspointxy_zone))
                if distance_current_point_zone_to_vector_translate_centroid > max_distance_point_zone_to_vector_translate_centroid:
                    max_distance_point_zone_to_vector_translate_centroid = distance_current_point_zone_to_vector_translate_centroid
                    qgspoint_max_distance_point_zone_to_vector_translate_centroid = current_qgspointxy_zone

            # traslacion vector al punto de máxima distancia
            dx = qgspoint_max_distance_point_zone_to_vector_translate_centroid.x() - qgspointxy_centroid_zone.x()
            dy = qgspoint_max_distance_point_zone_to_vector_translate_centroid.y() - qgspointxy_centroid_zone.y()
            qgsgeometry_vector.translate(dx, dy)
            qgspoint_vector_translate_point_max_dist_start = qgsgeometry_vector.vertexAt(0)
            qgspoint_vector_translate_point_max_dist_end = qgsgeometry_vector.vertexAt(1)

            # inicializa variables calculo distancia puntos zone al vector trasladado al punto de máxima distancia
            max_distance_point_zone_to_vector_translate = 0.0
            max_distance_linestring_geom = None
            # qgspoint_max_distance_point_zone_to_vector_translate_point_max_dist = QgsPoint(0, 0)
            qgspoint_extent_start = QgsGeometryUtils.pointOnLineWithDistance(qgspoint_vector_translate_point_max_dist_end,
                                                                             qgspoint_vector_translate_point_max_dist_start,
                                                                             extent_distance)
            qgspoint_extent_end = QgsGeometryUtils.pointOnLineWithDistance(qgspoint_vector_translate_point_max_dist_start,
                                                                           qgspoint_vector_translate_point_max_dist_end,
                                                                           extent_distance)

            for current_qgspointxy_zone in list_qgspointxy_vertex_zone[0]:
                current_qgspoint_proyectado = QgsGeometryUtils.projectPointOnSegment(QgsPoint(current_qgspointxy_zone),
                                                                                     qgspoint_extent_start,
                                                                                     qgspoint_extent_end)

                distance_current_point_zone_to_vector_translate = current_qgspoint_proyectado.distance(QgsPoint(current_qgspointxy_zone))
                if distance_current_point_zone_to_vector_translate > max_distance_point_zone_to_vector_translate:
                    max_distance_point_zone_to_vector_translate = distance_current_point_zone_to_vector_translate
                    max_distance_linestring_geom = QgsGeometry.fromPolyline([current_qgspoint_proyectado, QgsPoint(current_qgspointxy_zone)])

            qgsgeometry_centroid_max_distance_linestring = max_distance_linestring_geom.centroid()
            qgspointxy_centroid_max_distance_linestring = qgsgeometry_centroid_max_distance_linestring.asPoint()

            # traslacion vector al centroide de linestrin de máxima distancia
            dx = qgspointxy_centroid_max_distance_linestring.x() - qgspoint_max_distance_point_zone_to_vector_translate_centroid.x()
            dy = qgspointxy_centroid_max_distance_linestring.y() - qgspoint_max_distance_point_zone_to_vector_translate_centroid.y()
            qgsgeometry_vector.translate(dx, dy)
            qgspointxy_centroid_max_distance_linestring_start = qgsgeometry_vector.vertexAt(0)
            qgspointxy_centroid_max_distance_linestring_end = qgsgeometry_vector.vertexAt(1)

            qgspoint_extent_start = QgsGeometryUtils.pointOnLineWithDistance(qgspointxy_centroid_max_distance_linestring_end,
                                                                             qgspointxy_centroid_max_distance_linestring_start,
                                                                             extent_distance)
            qgspoint_extent_end = QgsGeometryUtils.pointOnLineWithDistance(qgspointxy_centroid_max_distance_linestring_start,
                                                                           qgspointxy_centroid_max_distance_linestring_end,
                                                                           extent_distance)
            # inicializa variables para cortes de la linea extendida
            qgspoint_project_envolope_start = QgsPoint(0, 0)
            qgspoint_project_envelope_end = QgsPoint(0, 0)
            min_distance_qgspoint_vector_translate_start_to_qgspoint_proyectado = extent_distance + 1
            min_distance_qgspoint_vector_translate_end_to_qgspoint_proyectado = extent_distance + 1

            for current_qgspointxy_zone in list_qgspointxy_vertex_zone[0]:
                current_qgspoint_proyectado = QgsGeometryUtils.projectPointOnSegment(QgsPoint(current_qgspointxy_zone),
                                                                                     qgspoint_extent_start,
                                                                                     qgspoint_extent_end)
                distance_qgspoint_extent_start_to_current_qgspoint_proyectado = qgspoint_extent_start.distance(current_qgspoint_proyectado)
                distance_qgspoint_extent_end_to_current_qgspoint_proyectado = qgspoint_extent_end.distance(current_qgspoint_proyectado)
                if distance_qgspoint_extent_start_to_current_qgspoint_proyectado < min_distance_qgspoint_vector_translate_start_to_qgspoint_proyectado:
                    qgspoint_project_envolope_start = current_qgspoint_proyectado
                    min_distance_qgspoint_vector_translate_start_to_qgspoint_proyectado = distance_qgspoint_extent_start_to_current_qgspoint_proyectado
                if distance_qgspoint_extent_end_to_current_qgspoint_proyectado < min_distance_qgspoint_vector_translate_end_to_qgspoint_proyectado:
                    qgspoint_project_envelope_end = current_qgspoint_proyectado
                    min_distance_qgspoint_vector_translate_end_to_qgspoint_proyectado = distance_qgspoint_extent_end_to_current_qgspoint_proyectado

            # calculo separacion entre pasadas
            n_strips = math.ceil(1 + ((max_distance_point_zone_to_vector_translate - distance_perpendicular) / (distance_perpendicular * (1 - side_overlap))))
            self.ui.spinBox_nStrips.setValue(n_strips)

            # para que valga el resto de algoritmo como en el caso lineal
            qgsgeometry_vector = QgsGeometry.fromPolyline([qgspoint_project_envolope_start, qgspoint_project_envelope_end])
            list_qgspointxy_vertex_vector = [QgsPointXY(qgspoint_project_envolope_start), QgsPointXY(qgspoint_project_envelope_end)]

        # obtiene coordendadas del tof point
        qgspoint_tof = self.q3_api_op.get_list_vertex_by_id_entity(self.path_db_project,
                                                                   c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                                                   "the_geom",
                                                                   "name_display_table",
                                                                   id_tof)
        # Cálculo del número de buffers
        if n_strips % 2 == 0: # número de pasadas par
            n_buffer = int(n_strips / 2)
        else:
            n_buffer = int((n_strips - 1) / 2)

        # parametros para el buffer
        segments = 5  # For round joins, number of segments to approximate quarter-circle

        end_cap_style = 2
        # Round (1) / Flat (2) / Square (3) end cap style
        # 3.22:
        # Qgis.EndCapStyle.Round Round cap.
        # Qgis.EndCapStyle.Flat Flat cap( in line with start / end of line)
        # Qgis.EndCapStyle.Square Square cap(extends past start / end of line by buffer distance)

        join_style = 2
        # Round (1) / Mitre (inglete) (2) / Bevel (bisel) (3) join style
        # 3.22:
        # Qgis.JoinStyle.Round Use rounded joins.
        # Qgis.JoinStyle.Miter Use mitered joins.
        # Qgis.JoinStyle.Bevel Use beveled joins.

        mitre_limit = 100.0  # Limit on the mitre ratio used for very sharp corners
        # create memory layer buffer
        name_layer = c.CONST_PFLIPUAV_LAYER_BUFFER
        type_geom_with_epsg_code = "Polygon?crs=EPSG:" + self.str_epsg_crs_project
        vlayer_target_mem_layer = QgsVectorLayer(type_geom_with_epsg_code,
                                                 name_layer,
                                                 "memory")
        if not vlayer_target_mem_layer.isValid():
            raise Exception("Failed to create memory layer")
            return
        vlayer_target_mem_layer_provider = vlayer_target_mem_layer.dataProvider()

        # generación de la geometrías del buffer
        for i in range(n_buffer):
            if n_strips % 2 == 0:
                distance_buffer = dp * (i + 1) - dp * 0.5
            else:
                distance_buffer = dp * (i + 1)
            # Obtiene geometría buffer
            if qgis_version_second_number < qgis_version_second_number_change_buffer_parameters:
                geom_buffer_to_entity_selected = qgsgeometry_vector.buffer(distance_buffer,
                                                                         segments,
                                                                         end_cap_style,
                                                                         join_style,
                                                                         mitre_limit)
            else:
                geom_buffer_to_entity_selected = qgsgeometry_vector.buffer(distance_buffer,
                                                                         segments,
                                                                         Qgis.EndCapStyle.Flat,
                                                                         Qgis.JoinStyle.Miter,
                                                                         mitre_limit)
            feature_buffer = QgsFeature()
            feature_buffer.setGeometry(geom_buffer_to_entity_selected)
            vlayer_target_mem_layer_provider.addFeatures([feature_buffer])

        # Carga de la memory layer del buffer en QGIS
        """
        root = QgsProject.instance().layerTreeRoot()
        QgsProject.instance().addMapLayer(vlayer_target_mem_layer, False)
        root.insertLayer(0, vlayer_target_mem_layer)  # carga la capa at the top
        # añade simbología
        path_symbol_buffer_layer = self.path_plugin + '/templates/qgis_templates/style_buffer.qml'
        vlayer_target_mem_layer.loadNamedStyle(path_symbol_buffer_layer)
        self.iface.layerTreeView().refreshLayerSymbology(vlayer_target_mem_layer.id())
        # zoom factor 1.2 a la memory layer buffer
        vlayer_target_mem_layer.updateExtents()
        box = vlayer_target_mem_layer.extent()
        box.scale(1.2)
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()
        """

        # obtiene una lista de bufferes quitándole el último punto (inicio y final de polígono es el mismo)
        list_buffers = []
        for current_buffer in vlayer_target_mem_layer.getFeatures():
            current_geom_buffer = current_buffer.geometry()
            wkt_current_geom_buffer = current_geom_buffer.asWkt()
            list_vertex_current_buffer = current_geom_buffer.asPolygon()[0]
            list_vertex_current_buffer = list_vertex_current_buffer[:-1]  # quitamos el último punto
            list_buffers.append(list_vertex_current_buffer)

        # obtiene la posición del primer punto del primer buffer
        first_buffer = list_buffers[0]
        num_vertex_buffer = len(first_buffer)
        num_vertex_ida = int(num_vertex_buffer / 2)

        # cálculo de las distancias del punto inicial y punto final del eje al tof point
        first_qgspoint_axis = list_qgspointxy_vertex_vector[0]
        last_qgspoint_axis = list_qgspointxy_vertex_vector[-1]
        distance_qgspoint_tof_2_first_qgspoint_axis = qgspoint_tof.distance(first_qgspoint_axis)
        distance_qgspoint_tof_2_last_qgspoint_axis = qgspoint_tof.distance(last_qgspoint_axis)
        if distance_qgspoint_tof_2_first_qgspoint_axis > distance_qgspoint_tof_2_last_qgspoint_axis:
            begin_qgspoint_axis = last_qgspoint_axis
            second_qgspoint_axis = list_qgspointxy_vertex_vector[-2]
        else:
            begin_qgspoint_axis = first_qgspoint_axis
            second_qgspoint_axis = list_qgspointxy_vertex_vector[1]

        int_pos_first_point = 0
        tolerance_distance = 0.01  #FIXME:
        instance_geodetic_calculations = GeodeticCalculations(self.iface,
                                                              self.path_db_project,
                                                              self.path_plugin)  # instancia a geodetic_calculations
        state_error, acimuth_begin_qgspoint_axis_x_second_qgspoint_axis = instance_geodetic_calculations.azimuth(begin_qgspoint_axis.x(),
                                                                                                                 begin_qgspoint_axis.y(),
                                                                                                                 second_qgspoint_axis.x(),
                                                                                                                 second_qgspoint_axis.y())
        perpendicular_acimuth_begin_qgspoint_axis = acimuth_begin_qgspoint_axis_x_second_qgspoint_axis - pi / 2
        if(perpendicular_acimuth_begin_qgspoint_axis < 0.0):
            perpendicular_acimuth_begin_qgspoint_axis = perpendicular_acimuth_begin_qgspoint_axis + 2.0 * pi

        tolerance_acimuth = 0.001  #FIXME:
        for i in range(n_buffer):
            if n_strips % 2 == 0:
                distance_first_point_axis_x_first_point_buffer = dp * 0.5
            else:
                distance_first_point_axis_x_first_point_buffer = dp

        for current_point_buffer in first_buffer:
            distance_current_point_buffer_x_first_point_axis = current_point_buffer.distance(begin_qgspoint_axis)
            if (distance_current_point_buffer_x_first_point_axis < (distance_first_point_axis_x_first_point_buffer + tolerance_distance)) and \
                    (distance_current_point_buffer_x_first_point_axis > (distance_first_point_axis_x_first_point_buffer - tolerance_distance)):
                state_error, acimuth_first_point_axis_x_current_point_buffer = instance_geodetic_calculations.azimuth(begin_qgspoint_axis.x(),
                                                                                                                      begin_qgspoint_axis.y(),
                                                                                                                      current_point_buffer.x(),
                                                                                                                      current_point_buffer.y())

                if (acimuth_first_point_axis_x_current_point_buffer < (perpendicular_acimuth_begin_qgspoint_axis + tolerance_acimuth)) and \
                        (acimuth_first_point_axis_x_current_point_buffer > (perpendicular_acimuth_begin_qgspoint_axis - tolerance_acimuth)):
                   break
            int_pos_first_point += 1

        # reordena lo puntos de todos los bufferes a partir de la posición del primer punto
        list_buffers_vertex_ordered = []
        for current_buffer in list_buffers:
            current_buffer_ordered = current_buffer[int_pos_first_point:] + current_buffer[:int_pos_first_point]
            list_buffers_vertex_ordered.append(current_buffer_ordered)

        # transforma buffers en ejes de ida y vuelta
        list_axis_strips = []

        if n_strips % 2 != 0: # número de pasadas impar
            if distance_qgspoint_tof_2_first_qgspoint_axis > distance_qgspoint_tof_2_last_qgspoint_axis:
                list_qgspointxy_vertex_vector.reverse()
            list_axis_strips.append(list_qgspointxy_vertex_vector)  # añade en primer lugar el eje

        for current_buffer in list_buffers_vertex_ordered:
            list_ida = current_buffer[:num_vertex_ida]
            list_vuelta = current_buffer[num_vertex_ida:]
            list_vuelta.reverse()
            list_axis_strips.insert(0, list_ida)
            list_axis_strips.append(list_vuelta)

        # aplica ida y vuelta
        list_qgspoints_axis_strips_result = []
        count_axis = 1

        for current_axis_strip in list_axis_strips:
            if count_axis % 2 == 0:
                current_axis_strip.reverse()
                list_qgspoints_axis_strips_result = list_qgspoints_axis_strips_result + current_axis_strip
            else:
                list_qgspoints_axis_strips_result = list_qgspoints_axis_strips_result + current_axis_strip
            count_axis += 1

        begin_point_list_qgspoints_axis_strips_result = list_qgspoints_axis_strips_result[0]
        last_point_list_qgspoints_axis_strips_result = list_qgspoints_axis_strips_result[-1]
        distance_qgspoint_tof_2_begin_point_list_qgspoints_axis_strips_result = qgspoint_tof.distance(begin_point_list_qgspoints_axis_strips_result)
        distance_qgspoint_tof_2_last_point_list_qgspoints_axis_strips_result = qgspoint_tof.distance(last_point_list_qgspoints_axis_strips_result)
        if distance_qgspoint_tof_2_begin_point_list_qgspoints_axis_strips_result > distance_qgspoint_tof_2_last_point_list_qgspoints_axis_strips_result:
            list_qgspoints_axis_strips_result.reverse()

        # geometría wkt del axis resultante
        strip_2d_axis_wkt = "LINESTRING("  # geometría wkt en 2D
        for qgspointxy in list_qgspoints_axis_strips_result:
            strip_2d_axis_wkt += "%s %s," % (qgspointxy.x(), qgspointxy.y())
        strip_2d_axis_wkt = strip_2d_axis_wkt[:-1]
        strip_2d_axis_wkt = strip_2d_axis_wkt + ")"

        # Add geom wkt to original layer
        uri = QgsDataSourceUri()
        uri.setDatabase(self.path_db_project)
        uri.setDataSource("", c.CONST_PFLIPUAV_LAYER_AXIS, "the_geom")
        qgs_vlayer_c_axis = QgsVectorLayer(uri.uri(),
                                           c.CONST_PFLIPUAV_LAYER_AXIS,
                                           'spatialite')
        provider_qgs_vlayer_c_axis = qgs_vlayer_c_axis.dataProvider()

        qgsfields_axis_layer = qgs_vlayer_c_axis.fields()
        qgsfeature_linestring = QgsFeature()
        qgsfeature_linestring.setFields(qgsfields_axis_layer,
                                        True)
        qgsgeometry_axis = QgsGeometry.fromWkt(strip_2d_axis_wkt)
        qgsfeature_linestring.setGeometry(qgsgeometry_axis)
        #str_cod_segment = self.cod_flight_block + "#" + str(str_id_c_axis) + "#" + str(count_segment)
        #qgsfeature_segment['cod_segment'] = str_cod_segment

        provider_qgs_vlayer_c_axis.addFeatures([qgsfeature_linestring])
        qgs_vlayer_c_axis.startEditing()
        qgs_vlayer_c_axis.commitChanges()
        qgs_vlayer_c_axis.reload()
        qgs_vlayer_c_axis.updateFields()
        qgs_vlayer_c_axis.updateExtents()

        self.iface.mapCanvas().refresh()

        #TODO: zoom to axis a partir del id generado
        """
        self.instaceDatabase.zoom_to_entity(self.path_db_project,
                                            c.CONST_PFLIPUAV_LAYER_AXIS,
                                            "the_geom",
                                            "name_display_table",
                                            current_id_axis)
                                            """
        self.fill_combo_axis_segments(self.path_db_project)


    def generate_dtm_srtm90(self):
        """
        Brief: herramienta auxiliar para formar del DTM SRTM90
        """
        # 1.- OBTENCIÓN DEL BOUNDING BOX DE LA ZONA A PROCESAR (TENIENDO EN CUENTA TOF Y LND POINTS)
        # valores absurdos
        x_min_process = 999999999.0
        y_min_process = 999999999.0
        x_max_process = -999999999.0
        y_max_process = -999999999.0

        # TOF POINT
        if self.ui.comboBox_tofPoints.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "DTM must be overlap takeoff point. Select TOF point",
                                                Qgis.Warning,
                                                10)
            return
        else:
            str_id_tof_point = self.ui.comboBox_tofPoints.currentText()
            str_wkt_geom_tof_point = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                                     c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                                                                     "the_geom",
                                                                                     "name_display_table",
                                                                                     int(str_id_tof_point))
            qgs_geom_tof = QgsGeometry.fromWkt(str_wkt_geom_tof_point)  # obtención de QgsGeometry del tof
            ggs_point_tof = qgs_geom_tof.asPoint()
            x_tof = ggs_point_tof.x()
            y_tof = ggs_point_tof.y()

        # LND POINT
        current_index_combo_lnd = self.ui.comboBox_lndPoints.currentIndex()
        if current_index_combo_lnd == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "DTM must be overlap landing point. Select LND point",
                                                Qgis.Warning,
                                                10)
            return
        else:
            if current_index_combo_lnd == 1:  # tof point
                str_id_tof_point = self.ui.comboBox_tofPoints.currentText()
                str_wkt_geom_tof_point = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                                   c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                                                                   "the_geom",
                                                                                   "name_display_table",
                                                                                   int(str_id_tof_point))
                qgs_geom_tof = QgsGeometry.fromWkt(str_wkt_geom_tof_point)  # obtención de QgsGeometry del tof
                ggs_point_tof = qgs_geom_tof.asPoint()
                x_lnd = ggs_point_tof.x()
                y_lnd = ggs_point_tof.y()

            # if current_index_combo_lnd == 2: # last way point
            #    #TODO:
            #    x_lnd = x_tof
            #    y_lnd = y_tof

            if current_index_combo_lnd > 1:  # cualquier punto de la capa lnd
                str_id_lnd_point = self.ui.comboBox_lndPoints.currentText()
                str_wkt_geom_lnd_point = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                                   c.CONST_PFLIPUAV_LAYER_LANDING_POINT,
                                                                                   "the_geom",
                                                                                   "name_display_table",
                                                                                   int(str_id_lnd_point))
                qgs_geom_lnd = QgsGeometry.fromWkt(str_wkt_geom_lnd_point)  # obtención de QgsGeometry del tof
                ggs_point_lnd = qgs_geom_lnd.asPoint()
                x_lnd = ggs_point_lnd.x()
                y_lnd = ggs_point_lnd.y()

        # abre la conexión con la BD del proyecto
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()

        # AXIS (VUELO LINEAL)
        if (self.int_photogrammetric_mission_type == 1):  # vuelo lineal no procesado
            str_sql = "SELECT * FROM flight_block_c_axis WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            cursor_db_project.execute(str_sql)

            num_axis = 0  # contador para el número de ejes a procesar
            for row in cursor_db_project.fetchall():
                id_axis = row[2]
                str_wkt_geom_axis_linestring = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                                         c.CONST_PFLIPUAV_LAYER_AXIS,
                                                                                         "the_geom",
                                                                                         "name_display_table",
                                                                                         id_axis)
                qgs_geom_axis = QgsGeometry.fromWkt(str_wkt_geom_axis_linestring)  # obtención de QgsGeometry del axis
                qgs_rectangle_axis = qgs_geom_axis.boundingBox()
                x_min_current_axis = qgs_rectangle_axis.xMinimum()
                y_min_current_axis = qgs_rectangle_axis.yMinimum()
                x_max_current_axis = qgs_rectangle_axis.xMaximum()
                y_max_current_axis = qgs_rectangle_axis.xMaximum()

                if x_min_current_axis < x_min_process:
                    x_min_process = x_min_current_axis
                if y_min_current_axis < y_min_process:
                    y_min_process = y_min_current_axis
                if x_max_current_axis > x_max_process:
                    x_max_process = x_max_current_axis
                if y_max_current_axis > y_max_process:
                    y_max_process = y_max_current_axis

                num_axis = num_axis + 1

            if num_axis == 0:  # no hay ejes en la tabla flight_block_c_axis
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "DTM must be overlap axis. Select axis",
                                                    Qgis.Warning,
                                                    10)
                return

        # ZONES (VUELO ZONAL)
        if self.int_photogrammetric_mission_type == 2:  # vuelo zonal
            str_sql = "SELECT * FROM flight_block_c_zone_vector WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
            cursor_db_project.execute(str_sql)

            num_zones = 0  # contador para el número de zonas a procesar
            for row in cursor_db_project.fetchall():
                id_zone = row[2]
                str_wkt_geom_zone_polygon = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                                      c.CONST_PFLIPUAV_LAYER_ZONE,
                                                                                      "the_geom",
                                                                                      "name_display_table",
                                                                                      id_zone)
                qgs_geom_zone = QgsGeometry.fromWkt(str_wkt_geom_zone_polygon)  # obtención de QgsGeometry del zone
                qgs_rectangle_zone = qgs_geom_zone.boundingBox()
                x_min_current_zone = qgs_rectangle_zone.xMinimum()
                y_min_current_zone = qgs_rectangle_zone.yMinimum()
                x_max_current_zone = qgs_rectangle_zone.xMaximum()
                y_max_current_zone = qgs_rectangle_zone.xMaximum()

                if x_min_current_zone < x_min_process:
                    x_min_process = x_min_current_zone
                if y_min_current_zone < y_min_process:
                    y_min_process = y_min_current_zone
                if x_max_current_zone > x_max_process:
                    x_max_process = x_max_current_zone
                if y_max_current_zone > y_max_process:
                    y_max_process = y_max_current_zone

                num_zones = num_zones + 1

            if num_zones == 0:  # no hay ejes en la tabla flight_block_c_zone_vector
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "DTM must be overlap zones. Select zone",
                                                    Qgis.Warning,
                                                    10)
                return

        # tiene en cuenta las coordenadas del tof y lnd
        if x_tof < x_min_process:
            x_min_process = x_tof
        if y_tof < y_min_process:
            y_min_process = y_tof
        if x_tof > x_max_process:
            x_max_process = x_tof
        if y_tof > y_max_process:
            y_max_process = y_tof

        if x_lnd < x_min_process:
            x_min_process = x_lnd
        if y_lnd < y_min_process:
            y_min_process = y_lnd
        if x_lnd > x_max_process:
            x_max_process = x_lnd
        if y_lnd > y_max_process:
            y_max_process = y_lnd

        con_db_project.close()  # cierra la base de datos

        # 2.- ESCALA DEL BOUNDING BOX A PROCESAR
        width = x_max_process - x_min_process
        lenght = y_max_process - y_min_process

        x_min_process = x_min_process - width
        y_min_process = y_min_process - lenght
        x_max_process = x_max_process + width
        y_max_process = y_max_process + lenght

        # 3.- TRANSFORMA EL PUNTO AL CRS DEL DTM
        str_crs_epsg_dtm_strm_90 = 4326

        qgs_point_min = self.q3_api_op.transform_point_coordinates(x_min_process,
                                                                   y_min_process,
                                                                   int(self.str_epsg_crs_project),
                                                                   str_crs_epsg_dtm_strm_90)

        longitude_min = qgs_point_min.x()
        latitude_min = qgs_point_min.y()

        qgs_point_max = self.q3_api_op.transform_point_coordinates(x_max_process,
                                                                   y_max_process,
                                                                   int(self.str_epsg_crs_project),
                                                                   str_crs_epsg_dtm_strm_90)

        longitude_max = qgs_point_max.x()
        latitude_max = qgs_point_max.y()

        # selecciona imágenes a descargar
        int_longitude_min = int(longitude_min)
        int_latitude_min = int(latitude_min)
        int_longitude_max = int(longitude_max)
        int_latitude_max = int(latitude_max)

        list_dir_nivel1 = []
        list_dir_nivel2 = []
        list_filename_hojas = []
        if (int_longitude_min == int_longitude_max and int_latitude_min == int_latitude_max):
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_min,
                                                                                int_longitude_min)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)

        if (int_longitude_min != int_longitude_max and int_latitude_min == int_latitude_max):
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_min,
                                                                                int_longitude_min)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_min,
                                                                                int_longitude_max)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)

        if (int_longitude_min == int_longitude_max and int_latitude_min != int_latitude_max):
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_min,
                                                                                int_longitude_min)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_max,
                                                                                int_longitude_min)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)

        if (int_longitude_min != int_longitude_max and int_latitude_min != int_latitude_max):
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_min,
                                                                                int_longitude_min)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_min,
                                                                                int_longitude_max)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_max,
                                                                                int_longitude_min)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)
            dirn1, dirn2, str_name_hoja = self.generate_dtm_srtm90_get_filename(int_latitude_max,
                                                                                int_longitude_max)
            list_dir_nivel1.append(dirn1)
            list_dir_nivel2.append(dirn2)
            list_filename_hojas.append(str_name_hoja)

        # levanta el diálogo para establecer el path degreestiles y el workspace y continuar con el procesamiento

        lst_path_srtm90 = []  # para almacenar el path del dtm generado en la siguiente clase
        dlg_generate_dtm_srtm = generateDtmSrtm(self.iface,
                                                self.path_db_project,
                                                self.path_plugin,
                                                list_dir_nivel1,
                                                list_dir_nivel2,
                                                list_filename_hojas,
                                                lst_path_srtm90)
        dlg_generate_dtm_srtm.show()
        result = dlg_generate_dtm_srtm.exec_()

        path_srtm90 = lst_path_srtm90[0]
        fileInfo = QtCore.QFileInfo(path_srtm90)
        baseName = fileInfo.baseName()
        qgs_raster_layer = QgsRasterLayer(path_srtm90,
                                          baseName)

        if self.q3_api_op.control_dtm(qgs_raster_layer,
                                      self.str_epsg_crs_project):
            str_internalCrsId_dtm = str(qgs_raster_layer.crs().srsid())
            self.msg_metadata_crs_dtm = self.q3_api_op.metadata_crs_object(str_internalCrsId_dtm)
            self.store_path_dtm_in_db(path_srtm90)
            self.ui.lineEdit_pathDTM.setText(path_srtm90)
        else:
            self.ui.lineEdit_pathDTM.clear()

    def generate_dtm_srtm90_get_filename(self,
                                         int_latitude,
                                         int_longitude):
        """

        :param int_latitude: latitud
        :type int_latitude: int
        :param int_longitude: longitud
        :type int_longitude: int
        :return: nombre del fichero
        :rtype: str
        """
        prefix_filename = "GLSDEM_"
        prefix_north_latitude = "n0"
        prefix_sourth_latitude = "s0"
        prefix_east_longitude = "e"
        prefix_weast_longitude = "w"
        extension_filename = ".tif.gz"

        # parte latitud
        if int_latitude >= 0:
            latitude_filename = prefix_north_latitude
        else:
            int_latitude = (int_latitude - 1) * -1
            latitude_filename = prefix_sourth_latitude

        if int_latitude < 10:
            latitude_filename = latitude_filename + "0" + str(int_latitude)
        else:
            latitude_filename = latitude_filename + str(int_latitude)

        # parte longitud
        if int_longitude >= 0:
            longitude_filename = prefix_east_longitude
        else:
            int_longitude = (int_longitude - 1) * -1
            longitude_filename = prefix_weast_longitude

        if int_longitude < 10:
            longitude_filename = longitude_filename + "00" + str(int_longitude)
        if int_longitude >= 10 and int_longitude < 100:
            longitude_filename = longitude_filename + "0" + str(int_longitude)
        if int_longitude >= 100:
            longitude_filename = longitude_filename + str(int_longitude)

        dirnivel1 = latitude_filename
        dirnivel2 = latitude_filename + longitude_filename
        str_filename = prefix_filename + latitude_filename + longitude_filename + extension_filename
        return dirnivel1, dirnivel2, str_filename

    def generate_mosaic_images(self):
        """
        Brief: levanta panel para herramienta generadora de mosaicos de imágenes
        :return:
        """
        dlg_generate_mosaic_images = generateMosaicImages(self.iface,
                                                          self.current_path_project_directory,
                                                          self.path_plugin)
        dlg_generate_mosaic_images.show()
        result = dlg_generate_mosaic_images.exec_()

    def get_duration_battery(self,
                             str_version_firmware_ui):
        """
        Obtiene la duración de la batería aplicando % cofidence
        :param str_version_firmware_ui: versión uav model
        :type str_version_firmware_ui: str
        :return: duración de la batería aplicando % cofidence
        :rtype: float
        """

        duration_battery = 0  # inicializa a cero

        con_db_template = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_template = con_db_template.cursor()

        # establece la duración máxima de vuelo en función de las baterías
        str_sql = "SELECT battery.'duration_battery', battery.'per_confidence'"
        str_sql += "FROM firmware INNER JOIN (battery INNER JOIN lnk_battery_firmware ON battery.id_battery = lnk_battery_firmware.id_battery) ON firmware.id_firmware = lnk_battery_firmware.id_firmware "
        str_sql += "WHERE (lnk_battery_firmware.'is_active'=1 and firmware.'des_firmware' = '"
        str_sql += str_version_firmware_ui + "');"

        cursor_db_template.execute(str_sql)

        for row in cursor_db_template.fetchall():
            int_duration_battery = row[0]
            float_per_confidence_battery = row[1]

        float_corrected_duration_battery = float(int_duration_battery) * float_per_confidence_battery

        con_db_template.close()
        return float_corrected_duration_battery

    def get_variables_camera(self, str_cod_camera):
        """
        Brief: obtiene las variables de la camara
        """
        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT * FROM camera WHERE cod_camera = '" + str_cod_camera + "';"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            self.str_cam_trademark = str(row[1])
            self.str_cam_rows = str(row[2])
            self.str_cam_columns = str(row[3])
            self.str_cam_focal = str(row[4])
            self.str_cam_geom_resolution = str(row[5])
            self.str_cam_xppa = str(row[6])
            self.str_cam_yppa = str(row[7])

        con_db_project.close()  # cierra la base de datos

    def help(self):
        """
        Brief: Abre el manual de referencia
        """
        path_reference_manual_pdf = self.path_plugin + '/manual/ReferenceManual.pdf'
        os.startfile(path_reference_manual_pdf)

    def initialize(self):
        """
        Initialize task
        """
        # contenedores lista para almacenar parámetros pasados por referencia a paneles
        self.lst_gral_data_prj = []  # panel datos generales del proyecto
        self.lst_flight_block_dlg = []  # panel de código de bloque de vuelo
        self.lst_add_camera_dlg = []  # panel añadir una cámara
        self.lst_add_vector_zone = []  # panel nuevo par vector zona

        # inicialización de variables
        self.link_firmware_cruised_speed = True  # variable para controlar la relación entre versión firmware y cruised speed
        self.link_firmware_ascent_speed = True  # variable para controlar la relación entre versión firmware y ascent speed
        self.link_firmware_descent_speed = True  # variable para controlar la relación entre versión firmware y descent speed
        self.link_gimbal_mount_x_sensor_attitude_acc = True  # variable para controlar relación entre type_gimbal_mount y acc_omega, acc_phi y acc_kappa
        # self.link_trajectory_type_x_was_checked = True # variable para controlar la relación entre trajectory_type x was checked
        # self.link_trajectory_type_x_nbk = True # variable para controlar la relación entre trajectory_type x NBK
        self.path_dtm = None

        self.ui.groupBox_CurrentFlightBlock.setVisible(False)  # Oculta el groupbox del current flight block

        # Habilita / deshabilita widgets al inicio
        self.initialize_enabled_widgets()

        self.initialize_signals_slots_before_enabled_project()  # signal / slots connections

        self.set_minimal_ui()

        self.is_set_ui_behaivor = False

        self.fb_process_status = 0
        self.cod_flight_block_dlg = None

    def intialize_combobox(self):
        #TODOC:

        # Rellena los combobox y establece los diccionarios en orden por la función llamada
        #self.dictionary_eal = self.fill_combo_eal(self.path_db_project)  # rellena combo eal desde la base de datos template
        #self.dictionary_egi = self.fill_combo_egi(self.path_db_project)  # rellena combo egi desde la base de datos template
        #self.dictionary_erc = self.fill_combo_erc(self.path_db_project)  # rellena combo erc desde la base de datos template
        self.dictionary_firmware = self.fill_combo_firmware(self.path_db_project)  # rellena combo firmware desde la base de datos template
        self.dictionary_mounting = self.fill_combo_mounting_type(self.path_db_project)  # Rellena el combo tipo de montaje
        self.dictionary_nbk = self.fill_combo_nbk(self.path_db_project)  # rellena combo no braking desde la base de datos template
        # self.dictionary_shp = self.fill_combo_shp(self.path_db_project) # rellena combo shp desde la base de datos template
        self.dictionary_trajectory_type = self.fill_combo_trajectory_type(self.path_db_project)  # rellena combo trajectory_type desde la base de datos template
        self.dictionary_type_gimbal_mount = self.fill_combo_type_gimbal_mount(self.path_db_project)  # rellena combo type gimbal mount desde la base de datos template

        self.ui.mMapLayerComboBox_DTM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        # self.ui.mMapLayerComboBox_DTM.setAllowEmptyLayer(True)
        self.ui.mMapLayerComboBox_DTM.setShowCrs(True)  # muestra el crs de las capas en el comboBox

    def initialize_domains_steps_from_db(self, path_db_template):
        """
        Brief:     Función inicializadora de los dominios,pasos y default_values de los doubleSpinBox y spinBox
                    que no dependen de valores de otros comboBox desde la base de datos plantilla.

                    Está función es llamada cuando se levanta el panel, se añade un nuevo bloque de vuelo y
                    se crea un nuevo proyecto.

                    Los valores máximos y mínimos de dominios y pasos se encuentran en la tabla [field_descriptions] de
                    la BD Sqlite plantilla.

                    Los valores iniciales por defecto (default values) se pueden encuentrar en la tabla [field_descriptions]
                    de la BD Sqlite plantilla y en el ficheros "qsettings.ini"

        param[in]: Path de la DB Sqlite plantilla
        """
        # self.my_qsettings.beginGroup("parameters_default_values")

        # conexión con la base de datos
        con_db_template = self.db_op.connection_sqlite(path_db_template)
        cursor_db_template = con_db_template.cursor()

        # ejecuta consulta para obtener los datos
        str_sql = "SELECT fieldname, version_firmaware, default_value, max_value, min_value, single_step "
        str_sql += "FROM fields_descriptions "
        str_sql += "WHERE fields_descriptions.'table' = 'flight_block' ORDER BY fieldname ASC"

        cursor_db_template.execute(str_sql)

        for row in cursor_db_template.fetchall():
            field_name = row[0]
            version_firmaware = row[1]
            default_value = row[2]
            max_value = row[3]
            min_value = row[4]
            single_step = row[5]

            if field_name == "ac_gps":
                self.ui.doubleSpinBox_accGps.setMaximum(max_value)
                self.ui.doubleSpinBox_accGps.setMinimum(min_value)
                self.ui.doubleSpinBox_accGps.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_ac_gps"))
                self.ui.doubleSpinBox_accGps.setValue(qsettings_value)

            if field_name == "ac_kap":
                self.ui.doubleSpinBox_accKappa.setMaximum(max_value)
                self.ui.doubleSpinBox_accKappa.setMinimum(min_value)
                self.ui.doubleSpinBox_accKappa.setSingleStep(single_step)
                # qsettings_value = float(self.my_qsettings.value("default_value_ac_kap"))
                # self.ui.doubleSpinBox_accKappa.setValue(qsettings_value)

            if field_name == "ac_omg":
                # self.ui.doubleSpinBox_accOmega.setMaximum(max_value)
                self.ui.doubleSpinBox_accOmega.setMinimum(min_value)
                self.ui.doubleSpinBox_accOmega.setSingleStep(single_step)
                # qsettings_value = float(self.my_qsettings.value("default_value_ac_omg"))
                # self.ui.doubleSpinBox_accOmega.setValue(qsettings_value)

            if field_name == "ac_phi":
                # self.ui.doubleSpinBox_accPhi.setMaximum(max_value)
                self.ui.doubleSpinBox_accPhi.setMinimum(min_value)
                self.ui.doubleSpinBox_accPhi.setSingleStep(single_step)

            if field_name == "ascent_speed":
                self.ui.doubleSpinBox_speedAsc.setMaximum(max_value)
                self.ui.doubleSpinBox_speedAsc.setMinimum(min_value)
                self.ui.doubleSpinBox_speedAsc.setSingleStep(single_step)
                self.default_value_ascent_speed = default_value
                self.ui.doubleSpinBox_speedAsc.setValue(default_value)

            if field_name == "descent_speed":
                self.ui.doubleSpinBox_speedDes.setMaximum(max_value)
                self.ui.doubleSpinBox_speedDes.setMinimum(min_value)
                self.ui.doubleSpinBox_speedDes.setSingleStep(single_step)
                self.default_value_descent_speed = default_value
                self.ui.doubleSpinBox_speedDes.setValue(default_value)

            if field_name == "end_height":
                self.ui.doubleSpinBox_heightEnd.setMaximum(max_value)
                self.ui.doubleSpinBox_heightEnd.setMinimum(min_value)
                self.ui.doubleSpinBox_heightEnd.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_end_height"))
                self.ui.doubleSpinBox_heightEnd.setValue(qsettings_value)

            if field_name == "foward_overlap":
                self.ui.doubleSpinBox_overlapFwd.setMaximum(max_value)
                self.ui.doubleSpinBox_overlapFwd.setMinimum(min_value)
                self.ui.doubleSpinBox_overlapFwd.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_foward_overlap"))
                self.ui.doubleSpinBox_overlapFwd.setValue(qsettings_value)

            if field_name == "fit_axis":
                self.default_value_fit_axis = default_value
                if default_value == 1:
                    self.ui.checkBox_fitAxis.setChecked(True)
                if default_value == -1:
                    self.ui.checkBox_fitAxis.setChecked(False)

            if field_name == "gpa":
                self.ui.doubleSpinBox_GPA.setMaximum(max_value)
                self.ui.doubleSpinBox_GPA.setMinimum(min_value)
                self.ui.doubleSpinBox_GPA.setSingleStep(single_step)
                self.default_value_gpa = default_value
                self.ui.doubleSpinBox_GPA.setValue(default_value)

            if field_name == "gsd":
                self.ui.doubleSpinBox_gsd.setMaximum(max_value)
                self.ui.doubleSpinBox_gsd.setMinimum(min_value)
                self.ui.doubleSpinBox_gsd.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_gsd"))
                self.ui.doubleSpinBox_gsd.setValue(qsettings_value)

            if field_name == "initial_height":
                self.ui.doubleSpinBox_heightStart.setMaximum(max_value)
                self.ui.doubleSpinBox_heightStart.setMinimum(min_value)
                self.ui.doubleSpinBox_heightStart.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_initial_height"))
                self.ui.doubleSpinBox_heightStart.setValue(qsettings_value)

            if field_name == "lea":
                self.ui.doubleSpinBox_linealEnlargement.setMaximum(max_value)
                self.ui.doubleSpinBox_linealEnlargement.setMinimum(min_value)
                self.ui.doubleSpinBox_linealEnlargement.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_lea"))
                self.ui.doubleSpinBox_linealEnlargement.setValue(qsettings_value)

            if field_name == "offset_omega":
                self.ui.doubleSpinBox_offsetOmega.setMaximum(max_value)
                self.ui.doubleSpinBox_offsetOmega.setMinimum(min_value)
                self.ui.doubleSpinBox_offsetOmega.setSingleStep(single_step)
                self.ui.doubleSpinBox_offsetOmega.setValue(default_value)
                self.old_value_offset_omega = default_value  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega

            if field_name == "offset_phi":
                self.ui.doubleSpinBox_offsetPhi.setMaximum(max_value)
                self.ui.doubleSpinBox_offsetPhi.setMinimum(min_value)
                self.ui.doubleSpinBox_offsetPhi.setSingleStep(single_step)
                self.ui.doubleSpinBox_offsetPhi.setValue(default_value)
                self.old_value_offset_phi = default_value  # se almacena valor para restituir si el usuario pasa el dominio phi_angle - offset_phi

            if field_name == "offset_kappa":
                self.ui.doubleSpinBox_offsetKappa.setMaximum(max_value)
                self.ui.doubleSpinBox_offsetKappa.setMinimum(min_value)
                self.ui.doubleSpinBox_offsetKappa.setSingleStep(single_step)
                self.ui.doubleSpinBox_offsetKappa.setValue(default_value)
                self.default_value_offset_kappa = default_value

            if field_name == "omega_angle":
                self.ui.doubleSpinBox_omegaAngle.setMaximum(max_value)
                self.ui.doubleSpinBox_omegaAngle.setMinimum(min_value)
                self.ui.doubleSpinBox_omegaAngle.setSingleStep(single_step)
                self.ui.doubleSpinBox_omegaAngle.setValue(default_value)
                self.old_value_omega_angle = default_value  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega

            if field_name == "phi_angle":
                self.ui.doubleSpinBox_phiAngle.setMaximum(max_value)
                self.ui.doubleSpinBox_phiAngle.setMinimum(min_value)
                self.ui.doubleSpinBox_phiAngle.setSingleStep(single_step)
                self.ui.doubleSpinBox_phiAngle.setValue(default_value)
                self.old_value_phi_angle = default_value  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega

            if field_name == "shot_interval":
                self.ui.doubleSpinBox_shotInterval.setMaximum(max_value)
                self.ui.doubleSpinBox_shotInterval.setMinimum(min_value)
                self.ui.doubleSpinBox_shotInterval.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_shot_interval"))
                self.ui.doubleSpinBox_shotInterval.setValue(qsettings_value)

            if field_name == "side_overlap":
                self.ui.doubleSpinBox_overlapSide.setMaximum(max_value)
                self.ui.doubleSpinBox_overlapSide.setMinimum(min_value)
                self.ui.doubleSpinBox_overlapSide.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_side_overlap"))
                self.ui.doubleSpinBox_overlapSide.setValue(qsettings_value)

            if field_name == "smooth_v":
                self.default_value_smooth_v = default_value
                if default_value == 1:
                    self.ui.checkBox_SmoothV.setChecked(True)
                if default_value == -1:
                    self.ui.checkBox_SmoothV.setChecked(False)

            if field_name == "ssh":
                self.ui.doubleSpinBox_SSH.setMaximum(max_value)
                self.ui.doubleSpinBox_SSH.setMinimum(min_value)
                self.ui.doubleSpinBox_SSH.setSingleStep(single_step)
                self.default_value_ssh = default_value
                self.ui.doubleSpinBox_SSH.setValue(default_value)

            if field_name == "hbl":  # 20170317: Safe Height before Landing (#HBL)
                self.ui.doubleSpinBox_HBL.setMaximum(max_value)
                self.ui.doubleSpinBox_HBL.setMinimum(min_value)
                self.ui.doubleSpinBox_HBL.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_end_height"))
                self.default_value_hbl = qsettings_value
                self.ui.doubleSpinBox_HBL.setValue(qsettings_value)

            if field_name == "tol_gsd":
                self.ui.doubleSpinBox_tolGsd.setMaximum(max_value)
                self.ui.doubleSpinBox_tolGsd.setMinimum(min_value)
                self.ui.doubleSpinBox_tolGsd.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_tol_gsd"))
                self.ui.doubleSpinBox_tolGsd.setValue(qsettings_value)

            if field_name == "wal":
                self.ui.doubleSpinBox_WAL.setMaximum(0.5)
                self.ui.doubleSpinBox_WAL.setMinimum(0.5)
                self.ui.doubleSpinBox_WAL.setSingleStep(single_step)
                self.default_value_wal = default_value
                self.ui.doubleSpinBox_WAL.setValue(0.5)

            if field_name == "was":
                self.ui.doubleSpinBox_WAS.setMaximum(max_value)
                self.ui.doubleSpinBox_WAS.setMinimum(min_value)
                self.ui.doubleSpinBox_WAS.setSingleStep(single_step)
                self.default_value_was = default_value
                self.ui.doubleSpinBox_WAS.setValue(default_value)

            if field_name == "av_height_obj":
                self.ui.doubleSpinBox_averageHeightObject.setMaximum(max_value)
                self.ui.doubleSpinBox_averageHeightObject.setMinimum(min_value)
                self.ui.doubleSpinBox_averageHeightObject.setSingleStep(single_step)
                qsettings_value = float(self.my_qsettings.value("default_value_average_height_object"))
                self.ui.doubleSpinBox_averageHeightObject.setValue(qsettings_value)

        cursor_db_template.close()  # cierra la base de datos

    def initialize_enabled_spins_depends_combo(self):
        """
        Brief: habilita/deshabilita widgets de parámetros dependientes de combobox
        """
        # 20160826. Carga en los combos ERC, EAL y EGI el dicionario correspondiente al UAV+firmware
        # self.dictionary_eal = self.fill_combo_eal(self.path_db_project) # rellena combo eal desde db_template
        # self.dictionary_egi = self.fill_combo_egi(self.path_db_project) # rellena combo egi desde db_template
        # self.dictionary_erc = self.fill_combo_erc(self.path_db_project) # rellena combo erc desde db_template

        if self.ui.comboBox_Firmware.currentIndex() == 0:
            self.ui.doubleSpinBox_speedCruising.setEnabled(False)
            # 20160820 Añadido por Carlos para MavLink
            self.ui.doubleSpinBox_speedAsc.setEnabled(False)  # deshabilita ascent speed.
            self.ui.doubleSpinBox_speedDes.setEnabled(False)  # deshabilita descent speed.
            """
            self.ui.comboBox_EAL.setCurrentIndex(0)  # fija el combo EAL a (index = 0)
            self.ui.comboBox_EGI.setCurrentIndex(0)  # fija el combo EGI a (index = 0)
            self.ui.comboBox_ERC.setCurrentIndex(0)  # fija el combo ERC a (index = 0)
            self.ui.comboBox_EAL.setEnabled(False)  # deshabilita el combo EAL
            self.ui.comboBox_EGI.setEnabled(False)  # deshabilita el combo EGI
            self.ui.comboBox_ERC.setEnabled(False)  # deshabilita el combo ERC
            """
            # self.ui.groupBox_GeneralSecurityParameters.setEnabled(False) # desabilita el groupBox de Safety parameters

        else:
            self.ui.doubleSpinBox_speedCruising.setEnabled(True)
            # 20160820 Añadido por Carlos para MavLink
            self.ui.doubleSpinBox_speedAsc.setEnabled(False)
            self.ui.doubleSpinBox_speedDes.setEnabled(False)
            # 20160820. Habilita EAL, ERC , EGI, solo para firmwares microdrones
            """
            if (self.ui.comboBox_Firmware.currentText() == c.CONST_CARABO_S3_AC_030406):
                self.ui.comboBox_EAL.setCurrentIndex(1)  # fija EAL en index = 1 (Aterriza)
                self.ui.comboBox_EGI.setCurrentIndex(1)  # fija EGI en index = 1 (desciende permitiendo control de dirección)
                self.ui.comboBox_ERC.setCurrentIndex(3)  # fija ERC en index = 3 (vuelta a casa)
                self.ui.comboBox_EAL.setEnabled(False)  # deshabilita el combo EAL
                self.ui.comboBox_EGI.setEnabled(False)  # deshabilita el combo EGI
                self.ui.comboBox_ERC.setEnabled(False)  # deshabilita el combo ERC
            else:
                self.ui.comboBox_EAL.setEnabled(True)  # Habilita el combo EAL
                self.ui.comboBox_EGI.setEnabled(True)  # Habilita el combo EGI
                self.ui.comboBox_ERC.setEnabled(True)  # Habilita el combo ERC
                """

        # default_value depende de type_gimbal_mount
        if self.ui.comboBox_typeGimbalMount.currentIndex() == 0:
            self.ui.doubleSpinBox_accKappa.setEnabled(False)
        else:
            self.ui.doubleSpinBox_accKappa.setEnabled(True)

        #  default_values y max_values de ac_omega y ac_phi dependen de camera, de type_gimbal_mount y del mounting type o yaw angle
         # minimal ui no considera comboBox_typeGimbalMount
        if self.ui.comboBox_Camera.currentIndex() == 0 or self.ui.comboBox_mountingType.currentIndex() == 0:
            self.ui.doubleSpinBox_accOmega.setEnabled(False)
            self.ui.doubleSpinBox_accPhi.setEnabled(False)
            self.ui.doubleSpinBox_accKappa.setEnabled(False)
        else:
            self.ui.doubleSpinBox_accOmega.setEnabled(True)
            self.ui.doubleSpinBox_accPhi.setEnabled(True)
            self.ui.doubleSpinBox_accKappa.setEnabled(True)

    def initialize_enabled_widgets(self):
        """
        Habilita / deshabilita widgets al inicio
        """
        # deshabilita botones al iniciar
        self.ui.toolButton_generateImages.setEnabled(False)
        self.ui.toolButton_ImportProject.setEnabled(True)
        self.ui.toolButton_ExportProject.setEnabled(False)
        self.ui.toolButton_ExportProjects.setEnabled(False)

        self.ui.doubleSpinBox_speedAsc.setEnabled(False)
        self.ui.doubleSpinBox_speedDes.setEnabled(False)

        self.ui.toolButton_generateSRTM.setEnabled(False)

        self.ui.pushButton_processReport.setEnabled(False)

    def initialize_signals_slots_after_enabled_project(self):
        """
        Connect signals / slots
        """
        # SIGNAL/SLOT connections order by slot name:
        self.ui.pushButton_AddSegment.clicked.connect(self.add_axis)
        self.ui.toolButton_AddCamera.clicked.connect(self.add_camera)
        self.ui.pushButton_AddFlightBlock.clicked.connect(self.add_flight_block)
        self.ui.checkBox_HBL.clicked.connect(self.clicked_fit_axis)
        self.ui.checkBox_fitAxis.clicked.connect(self.clicked_hbl)
        self.ui.checkBox_SmoothV.clicked.connect(self.clicked_smooth_v)
        self.ui.checkBox_WAL.clicked.connect(self.clicked_wal)
        self.ui.checkBox_WAS.clicked.connect(self.clicked_was)

        # change combobox
        self.ui.comboBox_segmentsAvailables.currentIndexChanged.connect(self.changed_combo_axis)
        self.ui.comboBox_Camera.currentIndexChanged.connect(self.changed_combo_camera)
        self.ui.mMapLayerComboBox_DTM.layerChanged.connect(self.changed_combo_dtm)
        self.ui.comboBox_EAL.currentIndexChanged.connect(self.changed_combo_eal)
        self.ui.comboBox_EGI.currentIndexChanged.connect(self.changed_combo_egi)
        self.ui.comboBox_ERC.currentIndexChanged.connect(self.changed_combo_erc)
        self.ui.comboBox_Firmware.currentIndexChanged.connect(self.changed_combo_firmware)
        self.ui.comboBox_FlightBlock.currentIndexChanged.connect(self.changed_combo_flight_block)
        self.ui.comboBox_lndPoints.currentIndexChanged.connect(self.changed_combo_lnd)
        self.ui.comboBox_mountingType.currentIndexChanged.connect(self.changed_combo_mounting_type)
        self.ui.comboBox_NBK.currentIndexChanged.connect(self.changed_combo_nbk)
        self.ui.comboBox_numberOfPointsInSideFrame.currentIndexChanged.connect(self.changed_combo_npsf)
        self.ui.comboBox_fileResults.currentIndexChanged.connect(self.changed_combo_report_option)
        self.ui.comboBox_SHP.currentIndexChanged.connect(self.changed_combo_shp)
        self.ui.comboBox_trajectoryType.currentIndexChanged.connect(self.changed_combo_trajectory_type)
        self.ui.comboBox_tofPoints.currentIndexChanged.connect(self.changed_combo_tof)
        # minimal ui no tiene esta funcionalidad
        #self.ui.comboBox_typeGimbalMount.currentIndexChanged.connect(self.changed_combo_type_gimbal_mount)
        self.ui.comboBox_idVector.currentIndexChanged.connect(self.changed_combo_vector)
        self.ui.comboBox_idZone.currentIndexChanged.connect(self.changed_combo_zone)

        # change values spin & double spin box
        self.ui.doubleSpinBox_accGps.valueChanged.connect(self.changed_spin_acc_gps)
        self.ui.doubleSpinBox_accKappa.valueChanged.connect(self.changed_spin_acc_kappa)
        self.ui.doubleSpinBox_accOmega.valueChanged.connect(self.changed_spin_acc_phi)
        self.ui.doubleSpinBox_accPhi.valueChanged.connect(self.changed_spin_acc_omega)
        self.ui.doubleSpinBox_speedAsc.valueChanged.connect(self.changed_spin_ascent_speed)
        self.ui.doubleSpinBox_averageHeightObject.valueChanged.connect(self.changed_spin_average_height_object)
        self.ui.doubleSpinBox_bufferLinealFlight.valueChanged.connect(self.changed_spin_buffer)
        self.ui.doubleSpinBox_speedCruising.valueChanged.connect(self.changed_spin_cruise_speed)
        self.ui.doubleSpinBox_speedDes.valueChanged.connect(self.changed_spin_descent_speed)
        self.ui.doubleSpinBox_overlapFwd.valueChanged.connect(self.changed_spin_fw_ov)
        self.ui.doubleSpinBox_GPA.valueChanged.connect(self.changed_spin_general_pos_accuary)
        self.ui.doubleSpinBox_gsd.valueChanged.connect(self.changed_spin_gsd)
        self.ui.doubleSpinBox_heightEnd.valueChanged.connect(self.changed_spin_landing_height)
        self.ui.doubleSpinBox_linealEnlargement.valueChanged.connect(self.changed_spin_lineal_zone_enlargement)
        self.ui.doubleSpinBox_offsetOmega.valueChanged.connect(self.changed_spin_offset_omega)
        self.ui.doubleSpinBox_offsetPhi.valueChanged.connect(self.changed_spin_offset_phi)
        self.ui.doubleSpinBox_offsetKappa.valueChanged.connect(self.changed_spin_offset_kappa)
        self.ui.doubleSpinBox_omegaAngle.valueChanged.connect(self.changed_spin_omega_angle)
        self.ui.doubleSpinBox_phiAngle.valueChanged.connect(self.changed_spin_phi_angle)
        self.ui.spinBox_nStrips.valueChanged.connect(self.changed_spin_number_strips)
        self.ui.doubleSpinBox_overlapSide.valueChanged.connect(self.changed_spin_sd_ov)
        self.ui.doubleSpinBox_SSH.valueChanged.connect(self.changed_spin_setting_secure_height)
        self.ui.doubleSpinBox_shotInterval.valueChanged.connect(self.changed_spin_shot_interval)
        self.ui.doubleSpinBox_heightStart.valueChanged.connect(self.changed_spin_takeoff_height)
        self.ui.doubleSpinBox_tolGsd.valueChanged.connect(self.changed_spin_tol_gsd)
        self.ui.doubleSpinBox_WAL.valueChanged.connect(self.changed_spin_wp_auto_landing)
        self.ui.doubleSpinBox_WAS.valueChanged.connect(self.changed_spin_wp_auto_start)
        self.ui.doubleSpinBox_HBL.valueChanged.connect(self.changed_spin_height_before_landing)

        # push / tool buttoms
        self.ui.toolButton_CopyParameter.clicked.connect(lambda: self.copy_parameter(self.ui.comboBox_FlightBlock.currentText()))
        self.ui.toolButton_generateSRTM.clicked.connect(self.generate_dtm_srtm90)
        self.ui.pushButton_generateAxisStrips.clicked.connect(self.generate_multiple_axis_strips)
        self.ui.toolButton_generateImages.clicked.connect(self.generate_mosaic_images)
        self.ui.pushButton_showBuffer.clicked.connect(self.load_to_qgis_buffer_to_axis)
        self.ui.toolButton_Planning.clicked.connect(self.process)
        self.ui.toolButton_qutline.clicked.connect(self.qutline_tool)
        self.ui.toolButton_RemoveCamera.clicked.connect(self.remove_camera)
        self.ui.pushButton_RemoveFlightBlock.clicked.connect(self.remove_flight_block)
        self.ui.pushButton_RemoveAxis.clicked.connect(self.remove_axis)
        self.ui.toolButton_EditCamera.clicked.connect(self.update_camera)
        self.ui.toolButton_ViewTableFlightBlock.clicked.connect(self.view_table_flight_block)

    def initialize_signals_slots_before_enabled_project(self):
        """
        Connect signals / slots
        """
        # push / tool buttoms
        self.ui.toolButton_Help.clicked.connect(self.help)
        self.ui.toolButton_virtualSlopeDtm.clicked.connect(self.virtual_slope_dtm_tool)

        self.ui.pushButton_processReport.clicked.connect(self.process_report)
        self.ui.toolButton_ImportProject.clicked.connect(self.project_import)
        self.ui.toolButton_ExportProject.clicked.connect(self.project_export)
        self.ui.toolButton_ExportProjects.clicked.connect(self.projects_exports)

        self.ui.toolButton_editProject.clicked.connect(self.project_edit)
        self.ui.toolButton_NewProject.clicked.connect(self.project_new)
        self.ui.toolButton_OpenProject.clicked.connect(self.project_open)

        self.ui.toolButton_About.clicked.connect(self.show_about_dlg)

    def load_to_qgis_buffer_to_axis(self):
        """
        Brief: pinta en QGIS un capa de polígono con el buffer al axis señalado
        """
        if self.ui.comboBox_segmentsAvailables.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No axis selected",
                                                Qgis.Info,
                                                20)
            self.ui.toolBox_currentFlightBlock.setCurrentIndex(0)  # para ir a la pestaña donde está la selección del axis
            return

        id_entity_to_buffering = int(self.ui.comboBox_segmentsAvailables.currentText())

        # recopila parámetros del buffer
        # lineal_enlargement = self.ui.doubleSpinBox_linealEnlargement.value()
        # distance = (self.ui.doubleSpinBox_bufferLinealFlight.value() / 2.0 ) - lineal_enlargement # la mitad de la traza
        distance = self.ui.doubleSpinBox_bufferLinealFlight.value() / 2.0  # la mitad de la traza
        segments = 5  # For round joins, number of segments to approximate quarter-circle
        end_cap_style = 2  # Round (1) / Flat (2) / Square (3) end cap style
        join_style = 2  # Round (1) / Mitre (inglete) (2) / Bevel (bisel) (3) join style
        mitre_limit = 100.0  # Limit on the mitre ratio used for very sharp corners

        path_symbol_buffer_layer = self.path_plugin + '/templates/qgis_templates/style_buffer.qml'
        self.q3_api_op.buffer_to_entity(self.path_db_project,
                                        c.CONST_PFLIPUAV_LAYER_AXIS,
                                        "the_geom",
                                        "name_display_table",
                                        id_entity_to_buffering,
                                        distance,
                                        segments,
                                        end_cap_style,
                                        join_style,
                                        mitre_limit,
                                        path_symbol_buffer_layer,
                                        self.str_idinternal_crs_proyect)

    def load_to_qgis_output_spatialite_layers(self):
        """
        Brief: carga las capas de salida
        """
        # crea grupo output gis layers qgis 2.6
        root = QgsProject.instance().layerTreeRoot()
        node_group_output_gis_layers = root.insertGroup(0, c.CONST_PFLIPUAV_GROUP_OUPUT_GIS_LAYERS)

        path_symbol_stereo_pairs_geom_2d_fp_m = self.path_plugin + '/templates/qgis_templates/style_stereo_pairs_geom_2d_fp_m.qml'
        path_symbol_images_geom_2d_fp_m = self.path_plugin + '/templates/qgis_templates/style_images_geom_2d_fp_m.qml'
        path_symbol_strips_geom_3d_axis_wkt_m = self.path_plugin + '/templates/qgis_templates/style_strips_geom_3d_axis_m.qml'
        path_simbol_waypoints_memory_layer = self.path_plugin + '/templates/qgis_templates/style_images_pc_layer.qml'

        # 20190405: creación de layer output waypoints
        str_type_geom_with_epsg_code = "Point?crs=EPSG:" + self.str_epsg_crs_project
        memory_layer_waypoints = QgsVectorLayer(str_type_geom_with_epsg_code,
                                                c.CONST_PFLIPUAV_LAYER_WAYPOINTS + " - " + self.cod_flight_block_dlg,
                                                "memory")
        cod_flight_block_fieldname = "cod_flight_block"
        id_segment_fieldname = "id_segment"
        id_number_shot_fieldname = "number_shot"
        id_image_fieldname = "id_image"
        cam_info_fieldname = "sensor_info"
        gsd_theo_fieldname = "gsd_theo"
        crs_code_fieldname = "crs_code"
        pc_fc_fieldname = "pc_fc"
        pc_sc_fieldname = "pc_sc"
        h_pc_fieldname = "pc_H"
        h_nadir_fieldname = "H_nadir"
        height_AGL_fieldname = "height_AGL"
        ppa_dtm_wkt_fieldname = "ppa_dtm_wkt"

        memory_layer_waypoints.startEditing()
        memory_layer_waypoints.addAttribute(QgsField(cod_flight_block_fieldname, QVariant.String))
        memory_layer_waypoints.addAttribute(QgsField(id_segment_fieldname, QVariant.Int))
        memory_layer_waypoints.addAttribute(QgsField(id_number_shot_fieldname, QVariant.Int))
        memory_layer_waypoints.addAttribute(QgsField(id_image_fieldname, QVariant.String))
        memory_layer_waypoints.addAttribute(QgsField(cam_info_fieldname, QVariant.String))
        memory_layer_waypoints.addAttribute(QgsField(gsd_theo_fieldname, QVariant.Double))
        memory_layer_waypoints.addAttribute(QgsField(crs_code_fieldname, QVariant.String))
        memory_layer_waypoints.addAttribute(QgsField(pc_fc_fieldname, QVariant.Double))
        memory_layer_waypoints.addAttribute(QgsField(pc_sc_fieldname, QVariant.Double))
        memory_layer_waypoints.addAttribute(QgsField(h_pc_fieldname, QVariant.Double))
        memory_layer_waypoints.addAttribute(QgsField(h_nadir_fieldname, QVariant.Double))
        memory_layer_waypoints.addAttribute(QgsField(height_AGL_fieldname, QVariant.Double))
        memory_layer_waypoints.addAttribute(QgsField(ppa_dtm_wkt_fieldname, QVariant.String))
        memory_layer_waypoints.commitChanges()

        memory_layer_waypoints.loadNamedStyle(path_simbol_waypoints_memory_layer)
        self.iface.layerTreeView().refreshLayerSymbology(memory_layer_waypoints.id())

        QgsProject.instance().addMapLayer(memory_layer_waypoints, False)
        node_layer_waypoints = node_group_output_gis_layers.addLayer(memory_layer_waypoints)
        memory_layer_waypoints.startEditing()

        # conexión con la BD
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()
        # ejecuta consulta para obtener los datos de output_c_images
        str_sql = "SELECT * FROM output_c_images WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "'"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            if row[1] == self.cod_flight_block_dlg:  #FIXME: 20190208: Para testear nueva estructura Sqlite
                idx_cod_flight_block = row[1]
                idx_strip_cd = row[3]
                idx_code_image = row[4]
                idx_id_image = row[5]
                idx_cam_info = row[12]
                idx_gsd_theo = row[18]
                idx_crs = row[10]
                idx_pc_fc = row[13]
                idx_pc_sc = row[14]
                idx_h_pc = row[15]
                idx_h_nadir = row[26]
                idx_height_AGL = idx_h_pc - idx_h_nadir
                idx_ppa_dtm_wkt = row[17]
            else:  # Estructura Sqlite original
                idx_cod_flight_block = row[6]
                idx_strip_cd = row[32]
                idx_code_image = row[8]
                idx_id_image = row[27]
                idx_cam_info = row[31]
                idx_gsd_theo = row[26]
                idx_crs = row[9]
                idx_pc_fc = row[14]
                idx_pc_sc = row[15]
                idx_h_pc = row[3]
                idx_h_nadir = row[2]
                idx_height_AGL = idx_h_pc - idx_h_nadir
                idx_ppa_dtm_wkt = row[19]

            # graba datos en memory layer WAYPOINT
            fet = QgsFeature()
            fields = memory_layer_waypoints.fields()
            fet.setFields(fields, True)
            qgs_point = QgsPointXY(idx_pc_fc, idx_pc_sc)
            fet.setGeometry(QgsGeometry.fromPointXY(qgs_point))
            fet[cod_flight_block_fieldname] = idx_cod_flight_block
            fet[id_segment_fieldname] = idx_strip_cd
            fet[id_number_shot_fieldname] = idx_code_image
            fet[id_image_fieldname] = idx_id_image
            fet[cam_info_fieldname] = idx_cam_info
            fet[gsd_theo_fieldname] = idx_gsd_theo
            fet[crs_code_fieldname] = idx_crs
            fet[pc_fc_fieldname] = format(idx_pc_fc, '.4f')
            fet[pc_sc_fieldname] = format(idx_pc_sc, '.4f')
            fet[h_pc_fieldname] = format(idx_h_pc, '.4f')
            fet[h_nadir_fieldname] = format(idx_h_nadir, '.2f')
            fet[height_AGL_fieldname] = format(idx_height_AGL, '.2f')
            fet[ppa_dtm_wkt_fieldname] = idx_ppa_dtm_wkt

            memory_layer_waypoints.addFeatures([fet])
            if (memory_layer_waypoints.commitChanges()):
                memory_layer_waypoints.reload()
                memory_layer_waypoints.startEditing()  # para el siguiente punto

        memory_layer_waypoints.commitChanges()  # cierra edición de capa
        memory_layer_waypoints.selectByIds([])

        # Carga resto de capas finales
        geom_fieldname_stereo_pairs = "geom_2d_fp_m"
        geom_fieldname_images = "geom_2d_fp_m"
        geom_fieldname_strips = "geom_3d_axis_m"

        self.q3_api_op.load_to_qgis_output_layer_filtered(self.path_db_project,
                                                          node_group_output_gis_layers,
                                                          c.CONST_PFLIPUAV_LAYER_STRIPS,
                                                          path_symbol_strips_geom_3d_axis_wkt_m,
                                                          geom_fieldname_strips,
                                                          self.cod_flight_block_dlg)

        self.q3_api_op.load_to_qgis_output_layer_filtered(self.path_db_project,
                                                          node_group_output_gis_layers,
                                                          c.CONST_PFLIPUAV_LAYER_STEREO_PAIRS,
                                                          path_symbol_stereo_pairs_geom_2d_fp_m,
                                                          geom_fieldname_stereo_pairs,
                                                          self.cod_flight_block_dlg)

        self.q3_api_op.load_to_qgis_output_layer_filtered(self.path_db_project,
                                                          node_group_output_gis_layers,
                                                          c.CONST_PFLIPUAV_LAYER_IMAGES,
                                                          path_symbol_images_geom_2d_fp_m,
                                                          geom_fieldname_images,
                                                          self.cod_flight_block_dlg)

    def load_to_qgis_polygonal_layers(self):
        """
        """
        # crea grupo aux gis layers versión QGIS 2.6
        root = QgsProject.instance().layerTreeRoot()
        self.node_group_aux_gis_layers = root.insertGroup(0, c.CONST_PFLIPUAV_GROUP_AUX_GIS_LAYERS)

        path_symbol_axis = self.path_plugin + '/templates/qgis_templates/style_axis.qml'
        path_symbol_vector = self.path_plugin + '/templates/qgis_templates/style_vector.qml'
        path_symbol_tof = self.path_plugin + '/templates/qgis_templates/style_tof_points_layer.qml'
        path_symbol_lnd = self.path_plugin + '/templates/qgis_templates/style_lnd_points_layer.qml'

        self.q3_api_op.load_to_qgis(True,
                                    self.path_db_project,
                                    c.CONST_PFLIPUAV_LAYER_AXIS,
                                    "the_geom",
                                    path_symbol_axis,
                                    self.node_group_aux_gis_layers)
        self.q3_api_op.load_to_qgis(True,
                                    self.path_db_project,
                                    c.CONST_PFLIPUAV_LAYER_VECTOR,
                                    "the_geom",
                                    path_symbol_vector,
                                    self.node_group_aux_gis_layers)
        self.q3_api_op.load_to_qgis(True,
                                    self.path_db_project,
                                    c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                    "the_geom",
                                    path_symbol_tof,
                                    self.node_group_aux_gis_layers)
        self.q3_api_op.load_to_qgis(True,
                                    self.path_db_project,
                                    c.CONST_PFLIPUAV_LAYER_LANDING_POINT,
                                    "the_geom",
                                    path_symbol_lnd,
                                    self.node_group_aux_gis_layers)

        # habilita signals de QGIS para refrescar los combobox de las capas cuando editingStopped
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        for layer in layers:
            if (layer.name() == c.CONST_PFLIPUAV_LAYER_LANDING_POINT or layer.name() == c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT):
                layer.editingStopped.connect(self.refresh_combos_tof_lnd)
            if layer.name() == c.CONST_PFLIPUAV_LAYER_AXIS:
                layer.editingStopped.connect(self.refresh_combo_axis)
            if layer.name() == c.CONST_PFLIPUAV_LAYER_VECTOR:
                layer.editingStopped.connect(self.refresh_combo_vector)

        # rellena los combos correspondientes
        self.fill_combo_axis_segments(self.path_db_project)
        self.fill_combo_id_vector(self.path_db_project)

    def load_to_qgis_zonal_layers(self):
        """
        """
        # crea grupo aux gis layers versión QGIS 2.6
        root = QgsProject.instance().layerTreeRoot()
        self.node_group_aux_gis_layers = root.insertGroup(0, c.CONST_PFLIPUAV_GROUP_AUX_GIS_LAYERS)

        path_symbol_axis = self.path_plugin + '/templates/qgis_templates/style_axis.qml'
        path_symbol_zones = self.path_plugin + '/templates/qgis_templates/style_zone.qml'
        path_symbol_vector = self.path_plugin + '/templates/qgis_templates/style_vector.qml'
        path_symbol_tof = self.path_plugin + '/templates/qgis_templates/style_tof_points_layer.qml'
        path_symbol_lnd = self.path_plugin + '/templates/qgis_templates/style_lnd_points_layer.qml'

        self.q3_api_op.load_to_qgis(True,
                                        self.path_db_project,
                                        c.CONST_PFLIPUAV_LAYER_AXIS,
                                        "the_geom",
                                        path_symbol_axis,
                                        self.node_group_aux_gis_layers)
        self.q3_api_op.load_to_qgis(True,
                                        self.path_db_project,
                                        c.CONST_PFLIPUAV_LAYER_ZONE,
                                        "the_geom",
                                        path_symbol_zones,
                                        self.node_group_aux_gis_layers)
        self.q3_api_op.load_to_qgis(True,
                                        self.path_db_project,
                                        c.CONST_PFLIPUAV_LAYER_VECTOR,
                                        "the_geom",
                                        path_symbol_vector,
                                        self.node_group_aux_gis_layers)
        self.q3_api_op.load_to_qgis(True,
                                        self.path_db_project,
                                        c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                        "the_geom",
                                        path_symbol_tof,
                                        self.node_group_aux_gis_layers)
        self.q3_api_op.load_to_qgis(True,
                                        self.path_db_project,
                                        c.CONST_PFLIPUAV_LAYER_LANDING_POINT,
                                        "the_geom",
                                        path_symbol_lnd,
                                        self.node_group_aux_gis_layers)

        # habilita signals de QGIS para refrescar los combobox de las capas cuando editingStopped
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        for layer in layers:
            if (layer.name() == c.CONST_PFLIPUAV_LAYER_LANDING_POINT or layer.name() == c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT):
                layer.editingStopped.connect(self.refresh_combos_tof_lnd)
            if layer.name() == c.CONST_PFLIPUAV_LAYER_AXIS:
                layer.editingStopped.connect(self.refresh_combo_axis)
            if layer.name() == c.CONST_PFLIPUAV_LAYER_VECTOR:
                layer.editingStopped.connect(self.refresh_combo_vector)
            if layer.name() == c.CONST_PFLIPUAV_LAYER_ZONE and self.int_photogrammetric_mission_type == 2:
                layer.editingStopped.connect(self.refresh_combo_zone)

        # rellena los combos correspondientes
        self.fill_combo_axis_segments(self.path_db_project)
        self.fill_combo_id_vector(self.path_db_project)
        if self.int_photogrammetric_mission_type == 2:
            self.fill_combo_id_zone(self.path_db_project)

    def path_dtm_from_database(self,
                               cursor_db_project):
        """
        Brief: carga el path del MDT a partir del valor grabado en el campo correspondiente de la tabla [flight_block]
        """
        # vacia el lineEdit correspondiente
        self.ui.lineEdit_pathDTM.clear()

        # obtiene el valor del path (string) del campo correspondiente de la tabla [flight_block] para el bloque correpondiente
        field = "dtm_path"
        str_sql = "SELECT %s FROM flight_block WHERE cod_flight_block = '%s';" % (field,
                                                                                  self.cod_flight_block_dlg)
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            path_dtm_database = row[0]  # en este caso value y key son lo mismo

        if (path_dtm_database != None and path_dtm_database != ''):  # si hay valor grabado en la BD
            # comprueba existencia del fichero dtm
            if not os.path.exists(path_dtm_database):  # si no existe el path del DTM grabado en la BD
                str_msg = "Path %s doesn't exists. Select valid DTM" % path_dtm_database
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Warning,
                                                    10)
                self.ui.lineEdit_pathDTM.clear()
            else:
                fileInfo = QtCore.QFileInfo(path_dtm_database)
                baseName = fileInfo.baseName()
                qgs_raster_layer = QgsRasterLayer(path_dtm_database,
                                                  baseName)
                if self.q3_api_op.control_dtm(qgs_raster_layer,
                                              self.str_epsg_crs_project):
                    str_internalCrsId_dtm = str(qgs_raster_layer.crs().srsid())
                    self.msg_metadata_crs_dtm = self.q3_api_op.metadata_crs_object(str_internalCrsId_dtm)
                    # busca en la ToC si el path de las capas existe, si no existe carga la capa en el ToC
                    find_path_toc_layer = False
                    layers = [layer for layer in QgsProject.instance().mapLayers().values()]
                    for layer in layers:
                        path_source_in_legend_normalizado = os.path.normcase(layer.source())
                        if path_source_in_legend_normalizado == path_dtm_database:
                            find_path_toc_layer = True
                    if not find_path_toc_layer:
                        QgsProject.instance().addMapLayer(qgs_raster_layer)

                    self.ui.lineEdit_pathDTM.setText(path_dtm_database)
                else:
                    self.ui.lineEdit_pathDTM.clear()
        else:  # path DTM is null
            str_msg = "Path stored in database is null"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            self.ui.lineEdit_pathDTM.clear()

    def project_edit(self):
        """
        Brief:
        """
        list_edit_project = []

        # abre panel para grabación de datos generales del proyecto
        dlg_edit_project = editProjectData(self.iface,
                                           list_edit_project,
                                           self.path_plugin,
                                           self.current_path_project_directory,
                                           self.path_db_project,
                                           self.nemo,
                                           self.title,
                                           self.author,
                                           self.company,
                                           self.path_logo,
                                           self.path_logo_2,
                                           self.str_epsg_crs_project)

        dlg_edit_project.show()  # show the dialog

        result = dlg_edit_project.exec_()  # Run the dialog

        if len(list_edit_project) > 0:
            # recopila variables de la lista
            self.title = list_edit_project[0]
            self.author = list_edit_project[1]
            self.company = list_edit_project[2]
            self.path_logo = list_edit_project[3]
            self.path_logo_2 = list_edit_project[4]
        else:  # no se han introducido datos del proyecto
            return

        if result == 1:
            pass  # to delete

    def project_new(self):
        """
        Brief: abre explorador para selección del espacio de trabajo PLIPUAV,
                abre panel para grabación de datos de proyecto PLIPUAV,
                copia la base de datos template al nuevo espacio de trabajo PLIPUAV,
                copia los valores generales del proyecto en la BD sqlite del proyecto,
                crea capas GIS auxiliares y campos de geometría en las capas de salida sobre la BD del proyecto,
                pone el WindowTitle en el panel principal,
                almacena en variables los datos generales del proyecto
        """
        # deshabilita widgets
        self.ui.groupBox_CurrentFlightBlock.setVisible(False)
        self.ui.pushButton_RemoveFlightBlock.setEnabled(False)
        self.ui.toolButton_Planning.setEnabled(False)
        self.ui.toolButton_CopyParameter.setEnabled(False)
        self.ui.toolButton_editProject.setEnabled(False)  # deshabilita botón para editar los datos del proyecto
        self.ui.toolButton_qutline.setEnabled(False)  # deshabilita qutline tool

        self.ui.mGroupBox_spatialData.setVisible(False)
        self.ui.mGroupBox_imagingAcquisitionParameters.setVisible(False)
        self.ui.mGroupBox_geometricNavigationParameters.setVisible(False)
        self.ui.mGroupBox_processingResults.setVisible(False)
        self.ui.mGroupBox_calculatedParametersGSD.setVisible(False)


        # vacia el contenedor lista que se pasa por referencia para obtener los valores del panel
        del self.lst_gral_data_prj[:]

        # captura a partir de la selección del usuario en el explorador del path workspace
        self.current_path_pflip_projects = \
            QFileDialog.getExistingDirectory(caption="Select path project",
                                             directory=self.my_qsettings.value("default_path_workspace_directory"),
                                             options=QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)

        if len(self.current_path_pflip_projects) == 0:  # si no se introduce ningún path
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select a path for the project",
                                                Qgis.Critical,
                                                10)
            return

        # actualiza el path del workspace en qsetting.ini
        self.my_qsettings.setValue("default_path_workspace_directory",
                                   os.path.normcase(self.current_path_pflip_projects))

        # abre panel para grabación de datos generales del proyecto
        self.dlg_new_project = Projectdata(self.current_path_pflip_projects,
                                           self.path_plugin,
                                           self.iface,
                                           self.lst_gral_data_prj)
        self.dlg_new_project.exec_()  # Run the dialog

        if len(self.lst_gral_data_prj) > 0:
            # recopila variables de la lista
            self.nemo = self.lst_gral_data_prj[0]
            self.title = self.lst_gral_data_prj[1]
            self.author = self.lst_gral_data_prj[2]
            self.str_idinternal_crs_proyect = self.lst_gral_data_prj[3]
            self.path_db_project = self.lst_gral_data_prj[4]
            self.msg_information_crs = self.lst_gral_data_prj[5]
            self.company = self.lst_gral_data_prj[6]
            self.path_logo = self.lst_gral_data_prj[7]
            self.path_logo_2 = self.lst_gral_data_prj[8]
            self.current_path_project_directory = self.lst_gral_data_prj[9]

            path_csv_file = self.path_plugin + '/templates/sensors.csv'
            if os.path.exists(path_csv_file):
                self.fill_sensors_sqlite_from_csv_file(path_csv_file,
                                                       self.path_db_project)
                self.fill_combo_camera(self.path_db_project)

            if not self.is_set_ui_behaivor:
                self.set_ui_behaivor()

            # actualiza el valor del último path del directorio del proyecto qsetting.ini
            self.my_qsettings.setValue("default_path_project_directory",
                                       self.current_path_project_directory)

            self.ui.toolButton_generateImages.setEnabled(True)  # habilita la posibilidad de generar mosaicos de openlayers

            # CRS de proyecto en distintos formatos
            int_idinternal_crs_project = int(self.str_idinternal_crs_proyect)  # ej.: 2103
            qgscrs_project = QgsCoordinateReferenceSystem(int_idinternal_crs_project,
                                                          QgsCoordinateReferenceSystem.InternalCrsId)
            self.str_epsg_crs_project = str(qgscrs_project.postgisSrid())  # ej.: "25830"

            # pone WindowTitle
            self.title_window = c.CONST_PFLIPUAV_TITLE + " project " + self.nemo + ". SpatiaLite database: " + self.path_db_project
            QDialog.setWindowTitle(self.ui,
                                   self.title_window)
            self.fill_combo_nemo_flight_block(self.path_db_project)
            self.fill_combo_camera(self.path_db_project)  # rellena el combo de cameras

            # inicializa los dominios,pasos y default_values de los doubleSpinBox y spinBox que no dependen de valores de otros comboBox desde la base de datos plantilla
            self.initialize_domains_steps_from_db(self.path_db_project)

            # contenedores lista para almacenar parámetros pasados por referencia a paneles
            self.lst_flight_block_dlg = []  # panel de código de bloque de vuelo
            self.lst_add_camera_dlg = []  # panel añadir una cámara
            self.lst_add_vector_zone = []  # panel nuevo par vector zona

            # habilita widgets ui
            self.ui.pushButton_AddFlightBlock.setEnabled(True)  # habilita botón para añadir un nuevo bloque de vuelo
            self.ui.toolButton_ViewTableFlightBlock.setEnabled(True)  # habilita botón para abrir tabla de bloques de vuelos creados en QGIS
            self.ui.toolButton_editProject.setEnabled(True)  # habilita botón para editar los datos del proyecto

            # habilita botones para importar y exportar proyectos
            self.ui.toolButton_ImportProject.setEnabled(True)
            self.ui.toolButton_ExportProject.setEnabled(True)
            self.ui.toolButton_ExportProjects.setEnabled(True)

        else:  # no se han introducido datos del proyecto
            return

    def project_open(self):
        """
        Brief: abre un proyecto PLIPUAV existente
        """
        # deshabilita widgets ui
        self.ui.groupBox_CurrentFlightBlock.setVisible(False)
        self.ui.pushButton_RemoveFlightBlock.setEnabled(False)
        self.ui.toolButton_Planning.setEnabled(False)
        self.ui.toolButton_CopyParameter.setEnabled(False)
        self.ui.toolButton_editProject.setEnabled(False)
        self.ui.toolButton_qutline.setEnabled(False)  # deshabilita qutline tool

        self.ui.mGroupBox_spatialData.setVisible(False)
        self.ui.mGroupBox_imagingAcquisitionParameters.setVisible(False)
        self.ui.mGroupBox_geometricNavigationParameters.setVisible(False)
        self.ui.mGroupBox_processingResults.setVisible(False)
        self.ui.mGroupBox_calculatedParametersGSD.setVisible(False)

        # abre navegador para buscar archivo sqlite
        self.path_db_project, str_filter = QFileDialog.getOpenFileName(caption="Open " + c.CONST_PFLIPUAV_TITLE + " project file",
                                                                       directory=self.my_qsettings.value("default_path_project_directory"),
                                                                       filter="SpatiaLite dataBase (*.sqlite)")
        if len(self.path_db_project) == 0:  # usuario cancela
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select " + c.CONST_PFLIPUAV_TITLE + " project file (.sqlite)",
                                                Qgis.Critical,
                                                10)
            return

        path_csv_file = self.path_plugin + '/templates/sensors.csv'
        if os.path.exists(path_csv_file):
            self.fill_sensors_sqlite_from_csv_file(path_csv_file,
                                                   self.path_db_project)
            self.fill_combo_camera(self.path_db_project)

        if not self.is_set_ui_behaivor:
            self.set_ui_behaivor()

        self.current_path_project_directory = os.path.dirname(self.path_db_project)
        self.my_qsettings.setValue("default_path_project_directory",
                                   self.current_path_project_directory)

        # recupera valores generales del proyecto
        self.path_project_store_in_db, \
        self.nemo, \
        self.title, \
        self.author, \
        self.path_db_project_store_in_db, \
        self.str_idinternal_crs_proyect, \
        self.company, \
        self.path_logo, \
        self.path_logo_2 = self.db_op.get_project_header_data(self.path_db_project)

        self.ui.toolButton_generateImages.setEnabled(True)  # habilita la posibilidad de generar mosaicos de openlayers

        # CRS de proyecto en distintos formatos
        int_idinternal_crs_project = int(self.str_idinternal_crs_proyect)  # ej.: 2103
        qgscrs_project = QgsCoordinateReferenceSystem(int_idinternal_crs_project,
                                                      QgsCoordinateReferenceSystem.InternalCrsId)
        self.str_epsg_crs_project = str(qgscrs_project.postgisSrid())  # ej.: "25830"

        # SEE: Deshabilitar la proyección sobre la marcha ya no es una opción en QGIS 3.0
        # https://issues.qgis.org/issues/11644
        # self.iface.mapCanvas().mapRenderer().setProjectionsEnabled(True)  # Enable on the fly reprojections

        # fija el CRS del mapcavas al CRS del proyecto MFLiP
        int_idinternal_crs_proyect = int(self.str_idinternal_crs_proyect)
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(int_idinternal_crs_proyect,
                                                                  QgsCoordinateReferenceSystem.InternalCrsId))  # Set project coordinate reference system

        # comprobación de rutas seleccionadas por el usuario vs. rutas almacenadas en el proyecto
        normaliza_path_project = os.path.normcase(self.current_path_project_directory)
        normaliza_path_project_store_in_db = os.path.normcase(self.path_project_store_in_db)
        normaliza_path_db_project = os.path.normcase(self.path_db_project)
        normaliza_path_db_project_store_in_db = os.path.normcase(self.path_db_project_store_in_db)

        if (normaliza_path_project != normaliza_path_project_store_in_db):
            str_msg = "Path project file ('%s') is different to path project stored in database ('%s')" % (normaliza_path_project,
                                                                                                           normaliza_path_project_store_in_db)
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            # TODO: UPDATE en la BD con la nueva ruta
            # return

        if (normaliza_path_db_project != normaliza_path_db_project_store_in_db):
            str_msg = "Sqlite file ('%s') is different to path project stored in database ('%s')" % (normaliza_path_db_project,
                                                                                                     normaliza_path_project_store_in_db)
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            # TODO: UPDATE en la BD con la nueva ruta
            # return

        # pone WindowTitle
        self.title_window = c.CONST_PFLIPUAV_TITLE + " project " + self.nemo + ". SpatiaLite database: " + self.path_db_project
        QDialog.setWindowTitle(self.ui,
                               self.title_window)

        self.fill_combo_nemo_flight_block(self.path_db_project)  # rellena el combo con los bloques de vuelo grabados en la base de datos
        self.fill_combo_camera(self.path_db_project)  # rellena el combo de cameras

        # habilita widgets
        self.ui.toolButton_editProject.setEnabled(True)  # habilita botón para editar los datos del proyecto
        self.ui.comboBox_FlightBlock.setEnabled(True)  # habilita el combo para seleccionar un bloque de vuelo
        self.ui.pushButton_AddFlightBlock.setEnabled(True)  # habilita botón para añadir un nuevo bloque de vuelo
        self.ui.toolButton_ViewTableFlightBlock.setEnabled(
            True)  # habilita botón para añadir tabla del bloque de vuelo en QGIS

        # habilita botones para importar y exportar proyectos
        self.ui.toolButton_ImportProject.setEnabled(True)
        self.ui.toolButton_ExportProject.setEnabled(True)
        self.ui.toolButton_ExportProjects.setEnabled(True)



    def project_import(self):
        """

        :return:
        """
        # Seleccion del path del fichero zip a descomprimir
        str_default_path_workspace_directory = self.my_qsettings.value("default_path_workspace_directory")
        path_zip_filename, str_filter = QFileDialog.getOpenFileName(caption=c.CONST_PFLIPUAV_TITLE + "Select project zip file",
                                                                    directory=str_default_path_workspace_directory,
                                                                    filter="ASCII file (*.zip)")

        if (len(path_zip_filename) == 0):
            return
            if not os.path.exist(path_zip_filename):
                return

        # Selección de la carpeta destino a descomprimir
        path_directory_to_descompress = (QFileDialog.getExistingDirectory(self,
                                                                          "Select PLIPUAV flip project directory",
                                                                          str_default_path_workspace_directory,
                                                                          QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks))

        if len(path_directory_to_descompress) == 0:  # si no se introduce ningún path
            return

        fh = open(path_zip_filename, 'rb')
        z = zipfile.ZipFile(fh)
        for name in z.namelist():
            z.extract(name, path_directory_to_descompress)
        fh.close()

        str_msg = "Import project succesfully in directory: " + path_directory_to_descompress
        self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                            str_msg,
                                            Qgis.Info,
                                            20)

    def project_export(self):

        path_directory_src = self.current_path_project_directory
        path_directory_dst_zip_file = path_directory_src
        int_type_export = 1

        self.project_zip_directory(path_directory_src,
                                   path_directory_dst_zip_file,
                                   int_type_export)

        self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                            "Export project succesfuly",
                                            Qgis.Info,
                                            20)

    def projects_exports(self):

        str_default_path_workspace_directory = self.my_qsettings.value("default_path_workspace_directory")

        # Selección de la carpeta origen a comprimir
        path_directory_to_compress = (QFileDialog.getExistingDirectory(caption="Select PLIPUAV project directory",
                                                                       directory=str_default_path_workspace_directory,
                                                                       options=QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks))

        if len(path_directory_to_compress) == 0:  # si no se introduce ningún path
            return

        # TODO: si la carpeta commnon data no tiene ningun fichero no la crea.
        path_directory_dst_zip_file = path_directory_to_compress

        int_type_export = 2

        self.project_zip_directory(path_directory_to_compress,
                                   path_directory_dst_zip_file,
                                   int_type_export)

        self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                            "Export projects succesfuly",
                                            Qgis.Info,
                                            20)

    def project_zip_directory(self,
                              path_directory_src,
                              path_directory_dst_zip_file,
                              int_type_export):
        """

        :param path_directory_src: path del directorio a comprimir
        :param path_directory_dst_zip_file: path del directorio destino del zip file a generar
        :return:
        """
        zf = zipfile.ZipFile("%s.zip" % (path_directory_dst_zip_file), "w", zipfile.ZIP_DEFLATED)
        abs_src = os.path.abspath(path_directory_src)
        for dirname, subdirs, files in os.walk(path_directory_src):
            for filename in files:
                absname = os.path.abspath(os.path.join(dirname, filename))
                if int_type_export == 1:
                    arcname = os.path.join(self.nemo, absname[len(abs_src) + 1:])
                else:
                    arcname = absname[len(abs_src) + 1:]
                # print 'zipping %s as %s' % (os.path.join(dirname, filename),arcname)
                zf.write(absname, arcname)
        zf.close()

    def process(self):
        """
        Brief: Función principal de cálculo de la planificación
        """
        #minimal ui
        self.ui.comboBox_Firmware.setCurrentIndex(1)
        self.ui.comboBox_typeGimbalMount.setCurrentIndex(1)
        self.ui.comboBox_trajectoryType.setCurrentIndex(1)
        self.ui.comboBox_NBK.setCurrentIndex(1)
        self.ui.comboBox_SHP.setCurrentIndex(1)

        result_process = False
        lst_result_process = []
        str_firmware = self.ui.comboBox_Firmware.currentText()

        # path del fichero de resultados = cadena report_prj_
        path_file_results_pdf = self.current_path_project_directory + "\\" + self.cod_flight_block_dlg + "\\" + "report_prj_" + self.nemo + "_fb_" + self.cod_flight_block_dlg + ".pdf"

        if self.int_photogrammetric_mission_type == 3:  # Prepare flight blocks from lineal axis segmentation
            # recuperar los tramos a copy parameter de QSelectedCombobox
            self.str_code_flight_block = self.ui.comboBox_FlightBlock.currentText()
            str_selected_axis = self.ui.mComboBox_checkeableAxis.currentText()
            if len(str_selected_axis) == 0:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Select available axis",
                                                    Qgis.Warning,
                                                    20)
                return

            lst_selected_axis = str_selected_axis.split("||")
            for current_selected_axis in lst_selected_axis:
                lst_current_selected_axis = current_selected_axis.split("#")
                current_cod_fb_segment = lst_current_selected_axis[0]
                current_c_axis_id_qutline = lst_current_selected_axis[1]
                current_segment_count = lst_current_selected_axis[2]

                # conexión con la BD para consulta zoom
                con_db_project = self.db_op.connection_sqlite(self.path_db_project)
                cursor_db_project = con_db_project.cursor()

                # entero con el tipo de mission: [1] - linear route; [2] - polygonal area; [3] - oblique shots
                int_photogrammetric_mission_type = 1

                # crea el directorio del bloque de vuelo en la estructura correspondiente
                str_directory_fb = self.current_path_project_directory + c.CONST_SEPARATOR_DIRECTORIES + current_selected_axis
                self.current_path_flight_block_directory = os.path.normcase(str_directory_fb)
                if not os.path.exists(self.current_path_flight_block_directory):
                    os.makedirs(self.current_path_flight_block_directory)
                else:
                    str_msg = "Directory " + str_directory_fb + " already exists"
                    self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                        str_msg,
                                                        Qgis.Critical,
                                                        10)
                    return

                # Duplica registro en la tabla [flight_block] con el nuevo código de bloque de vuelo y id_proccess a cero
                str_sql = "INSERT into flight_block ("
                str_sql += "cod_flight_block,"
                str_sql += "cod_camera,"
                str_sql += "dtm_path,"
                str_sql += "id_tof,"
                str_sql += "id_lnd,"
                str_sql += "id_firmware,"
                str_sql += "id_fb_type,"
                str_sql += "gsd,"
                str_sql += "tol_gsd,"
                str_sql += "foward_overlap,"
                str_sql += "side_overlap,"
                str_sql += "ac_gps,ac_omg,"
                str_sql += "ac_phi,"
                str_sql += "ac_kap,"
                str_sql += "id_trajectory_type,"
                str_sql += "cruise_speed,"
                str_sql += "ascent_speed,"
                str_sql += "descent_speed,"
                str_sql += "lea,"
                str_sql += "initial_height,"
                str_sql += "id_nbk,end_height,"
                str_sql += "wpb,images_item,"
                str_sql += "shot_interval,"
                str_sql += "omega_angle,"
                str_sql += "phi_angle,"
                str_sql += "id_erc,"
                str_sql += "id_eal,"
                str_sql += "id_egi,"
                str_sql += "id_shp,"
                str_sql += "ssh,"
                str_sql += "gpa,"
                str_sql += "id_wae,"
                str_sql += "wal,"
                str_sql += "was,"
                str_sql += "id_process_st,"
                str_sql += "npsf,"
                str_sql += "id_mounting_type,"
                str_sql += "id_type_gimbel_mount,"
                str_sql += "offset_omega,"
                str_sql += "offset_phi,"
                str_sql += "offset_kappa,"
                str_sql += "av_height_obj) "

                str_sql += "SELECT "
                str_sql += "'" + current_selected_axis + "',"
                str_sql += "cod_camera,"
                str_sql += "dtm_path,"
                str_sql += "id_tof,"
                str_sql += "id_lnd,"
                str_sql += "id_firmware,"
                str_sql += str(int_photogrammetric_mission_type) + ","
                str_sql += "gsd,"
                str_sql += "tol_gsd,"
                str_sql += "foward_overlap,"
                str_sql += "side_overlap,"
                str_sql += "ac_gps,"
                str_sql += "ac_omg,"
                str_sql += "ac_phi,"
                str_sql += "ac_kap,"
                str_sql += "id_trajectory_type,"
                str_sql += "cruise_speed,"
                str_sql += "ascent_speed,"
                str_sql += "descent_speed,"
                str_sql += "lea,"
                str_sql += "initial_height,"
                str_sql += "id_nbk,"
                str_sql += "end_height,"
                str_sql += "wpb,"
                str_sql += "images_item,"
                str_sql += "shot_interval,"
                str_sql += "omega_angle,"
                str_sql += "phi_angle,"
                str_sql += "id_erc,"
                str_sql += "id_eal,"
                str_sql += "id_egi,"
                str_sql += "id_shp,"
                str_sql += "ssh,"
                str_sql += "gpa,"
                str_sql += "id_wae,"
                str_sql += "wal,"
                str_sql += "was,"
                str_sql += "'0',"  # no procesado, string
                str_sql += "npsf,"
                str_sql += "id_mounting_type,"
                str_sql += "id_type_gimbel_mount,"
                str_sql += "offset_omega,"
                str_sql += "offset_phi,"
                str_sql += "offset_kappa,"
                str_sql += "av_height_obj "

                str_sql += "FROM flight_block WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
                self.db_op.execute_query_old(self.path_db_project, str_sql)

                # rellena combo flight block
                self.ui.comboBox_FlightBlock.setEnabled(True)
                self.fill_combo_nemo_flight_block(self.path_db_project)

                # pone el combo nemos bloque de vuelo en el índice del current fb
                value_compare = self.cod_flight_block_dlg
                str_sql = "SELECT cod_flight_block FROM flight_block ORDER by cod_flight_block ASC"
                index_combo_new_fb = self.db_op.get_index_combo(self.path_db_project,
                                                                str_sql,
                                                                value_compare)
                self.ui.comboBox_FlightBlock.setCurrentIndex(index_combo_new_fb)

                # asignar [id_axis] al [cod_flight_block] en la tabla [flight_block_c_axis]
                # obtiene [id_axis] a partir del [cod_segment] de la tabla [c_Axis]
                str_sql = "SELECT id_c_axis FROM c_axis WHERE cod_segment = '"
                str_sql += current_selected_axis + "';"

                cursor_db_project.execute(str_sql)
                for row in cursor_db_project.fetchall():
                    str_id_c_axis = str(row[0])

                # Duplica registro en la tabla [flight_block_c_axis] con el nuevo código de bloque de vuelo
                str_sql = "INSERT into flight_block_c_axis ("
                str_sql += "cod_flight_block,"
                str_sql += "id_axis) "
                str_sql += "VALUES ('" + current_selected_axis + "',"
                str_sql += str_id_c_axis + ");"
                self.db_op.execute_query_old(self.path_db_project, str_sql)

                # Graba registro en la tabla [flight_block_c_axis] con el código de bloque de vuelo plantilla
                str_sql = "INSERT into flight_block_c_axis ("
                str_sql += "cod_flight_block,"
                str_sql += "id_axis) "
                str_sql += "VALUES ('" + self.cod_flight_block_dlg + "',"
                str_sql += str_id_c_axis + ");"
                self.db_op.execute_query_old(self.path_db_project, str_sql)

            self.final_actions_process_ok(is_mission_type_paflr=True)

            # cambiar el estado del bloque de vuelo plantilla a procesado
            str_msg = "Flight block prepared succesfully"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Info,
                                                10)
        else:
            if (self.get_variables_panel()):  # get_variables_panel recupera todas

                # progress dialog
                pg_dialog = progressDialogDlg(self.iface)
                pg_dialog.setModal(True)
                pg_dialog.show()  # show the dialog
                pg_dialog.activateWindow()

                self.q3_api_op.remove_group_gis_layers(c.CONST_PFLIPUAV_GROUP_OUPUT_MEMORY_GIS_LAYERS)  # elimino capas memory layer auxiliares si las hubiere

                qgsgeometry_zone_buffer = None
                if self.int_photogrammetric_mission_type == 2:
                    str_current_id_zone = self.ui.comboBox_idZone.currentText()
                    current_id_zone = int(str_current_id_zone)
                    str_wkt_geom_zone = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                                  c.CONST_PFLIPUAV_LAYER_ZONE,
                                                                                  "the_geom",
                                                                                  "name_display_table",
                                                                                  current_id_zone)
                    qgsgeometry_zone = QgsGeometry.fromWkt(str_wkt_geom_zone)
                    lineal_zone_enlargement = self.ui.doubleSpinBox_linealEnlargement.value()
                    qgsgeometry_zone_buffer = qgsgeometry_zone.buffer(lineal_zone_enlargement, 0)

                if self.ui.checkBox_removeImagesWithoutStereoscopy.isChecked():
                    is_remove_images_without_stereoscopy = True
                else:
                    is_remove_images_without_stereoscopy = False

                # instancia a la clase de cálculo de planificación LINEAL
                self.class_lineal_planning = planning(self.iface,
                                                      self.path_plugin,
                                                      self.current_path_project_directory,
                                                      self.path_db_project,
                                                      self.path_file_results,
                                                      path_file_results_pdf,
                                                      self.path_file_results_csv,
                                                      self.path_uav_navigation_file_name,
                                                      self.str_code_flight_block,
                                                      self.str_idinternal_crs_proyect,
                                                      lst_result_process,
                                                      str_firmware,
                                                      pg_dialog,
                                                      qgsgeometry_zone_buffer,
                                                      is_remove_images_without_stereoscopy)

                result_process_memory = lst_result_process[0]

                if result_process_memory:
                    self.ui.doubleSpinBox_tolGsd.setValue(lst_result_process[1])
                    # creación de combo para grabar o continuar procesando
                    self.q_combo_final_options = QComboBox()
                    self.q_combo_final_options.addItem("--- Select action ---")
                    # self.q_combo_final_options.addItem("Repeat processing by changing parameters")
                    self.q_combo_final_options.addItem("Record results and finish processing")
                    # self.q_combo_final_options.setItemIcon(1,QIcon(":/plugins/pflip_uav_pafyc/icons/processing.png"))
                    self.q_combo_final_options.setItemIcon(1, QIcon(":/plugins/pflip_uav_pafyc/icons/filesave.png"))
                    self.q_combo_final_options.currentIndexChanged.connect(self.changed_combo_final_options_lineal)

                    str_msg = "Processing Lineal Flight Block in memory completed. Select action"
                    widget_msg_store_results = self.iface.messageBar().createMessage(c.CONST_PFLIPUAV_TITLE,
                                                                                     str_msg)
                    widget_msg_store_results.layout().addWidget(self.q_combo_final_options)  # Adds widget w to this layout in a manner specific to the layout
                    qgsmessagebritem_select_action = self.iface.messageBar().pushWidget(widget_msg_store_results,
                                                                                        Qgis.Warning)  # devuelve un objeto del tipo QgsMessageBarItem

                    # habilita el QTimeEdit estableciendo la duración del vuelo calculada en el script de navegación
                    con_db_project = self.db_op.connection_sqlite(self.path_db_project)
                    cursor_db_project = con_db_project.cursor()
                    field = "flight_duration"
                    str_sql = "SELECT " + field + " FROM flight_block WHERE cod_flight_block = '"
                    str_sql += self.cod_flight_block_dlg + "';"
                    cursor_db_project.execute(str_sql)
                    for row in cursor_db_project.fetchall():
                        time_store_in_db = row[0]
                    if time_store_in_db == None:
                        time_store_in_db = 0  # evita excepcion cuando no se envía la llamada al script de navegación
                    self.time_store_in_db = time_store_in_db
                    self.set_time_duration_flight(self.time_store_in_db)  # establece el valor de la duración del vuelo en el widget correspondiente
                    self.set_widget_duration_battery_vs_fly()  # configura el widget duración batería vs. duración del vuelo

                    con_db_project.close()

                """
                if self.int_photogrammetric_mission_type == 2:  # vuelo zonal
                    # stop_calculation = 0 / 0
                    # progress dialog
                    pg_dialog = progressDialogDlg(self.iface)
                    pg_dialog.setModal(True)
                    pg_dialog.show()  # show the dialog
                    pg_dialog.activateWindow()

                    # llamada a la función de cálculo de planificación ZONAL
                    class_zonal_planning = planningZonal(self.iface,
                                                         self.path_plugin,
                                                         self.current_path_project_directory,
                                                         self.path_db_project,
                                                         self.path_file_results,
                                                         path_file_results_pdf,
                                                         self.path_file_results_csv,
                                                         self.path_uav_navigation_file_name,
                                                         self.str_code_flight_block,
                                                         self.str_idinternal_crs_proyect,
                                                         lst_result_process,
                                                         str_firmware,
                                                         pg_dialog)

                    result_process = lst_result_process[0]
                    self.ui.doubleSpinBox_tolGsd.setValue(lst_result_process[1])


                    if (result_process):
                        self.final_actions_process_ok()

                        # habilita el QTimeEdit estableciendo la duración del vuelo calculada en el script de navegación
                        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
                        cursor_db_project = con_db_project.cursor()

                        field = "flight_duration"
                        str_sql = "SELECT " + field + " FROM flight_block WHERE cod_flight_block = '"
                        str_sql += self.cod_flight_block_dlg + "';"

                        cursor_db_project.execute(str_sql)
                        for row in cursor_db_project.fetchall():
                            time_store_in_db = row[0]

                        self.time_store_in_db = time_store_in_db
                        
                        if time_store_in_db == None:
                            time_store_in_db = 0  # evita excepcion cuando no se envía la llamada al script de navegación

                        self.set_time_duration_flight(self.time_store_in_db)  # establece el valor de la duración del vuelo en el widget correspondiente
                        self.set_widget_duration_battery_vs_fly()  # configura el widget duración batería vs. duración del vuelo

                        con_db_project.close()

                    else:
                        self.final_actions_process_ko()
                    """
    def process_report(self):
        """
        Brief:
        """
        current_index_combo_file_results = self.ui.comboBox_fileResults.currentIndex()

        if current_index_combo_file_results == 1:  # Información sobre el procesamiento (.txt)
            os.startfile(self.path_file_results)

        if current_index_combo_file_results == 2:  # Fichero de tiempos (.txt)
            path_uav_navigation_time_file_name_dir = self.path_uav_navigation_file_name + "_time.txt"
            os.startfile(path_uav_navigation_time_file_name_dir)

        if current_index_combo_file_results == 3:  # Información sobre el procesamiento (.csv)
            os.startfile(self.path_file_results_csv)

        if current_index_combo_file_results == 4:  # Scrip de Navegación del drone (.txt)
            path_uav_navigation_file_name_dir = self.path_uav_navigation_file_name + ".txt"
            os.startfile(path_uav_navigation_file_name_dir)

        if current_index_combo_file_results == 5:  # Tablas de SpatiaLite no geométricas (.sqlite)
            self.q3_api_op.load_to_qgis(False,
                                        self.path_db_project,
                                        "output_side_overlap",
                                        "no_spatial",
                                        "",
                                        None)
            self.q3_api_op.load_to_qgis(False,
                                        self.path_db_project,
                                        "output_strips_connections",
                                        "no_spatial",
                                        "",
                                        None)
            self.q3_api_op.load_to_qgis(False,
                                        self.path_db_project,
                                        "output_strips_images",
                                        "no_spatial",
                                        "",
                                        None)

        if current_index_combo_file_results == 6:  # Información sobre el procesamiento (.pdf)
            # abre dialogo previo a la impresion
            str_current_firmware = self.ui.comboBox_Firmware.currentText()
            dlg_parameters_print_map = parametersPrintMap(self.iface,
                                                          self.path_file_map_pdf,
                                                          self.cod_flight_block_dlg,
                                                          self.path_plugin,
                                                          self.path_db_project,
                                                          self.nemo,
                                                          self.title,
                                                          self.author,
                                                          self.company,
                                                          self.path_logo,
                                                          self.path_logo_2,
                                                          self.str_epsg_crs_project,
                                                          str_current_firmware)

            dlg_parameters_print_map.show()  # show the dialog

            result = dlg_parameters_print_map.exec_()  # Run the dialog

    def qutline_tool(self):
        """
        Tool for cut axis
        """
        self.qutline_tool_dlg = QutlineTool(self.iface,
                                            self.my_qsettings,
                                            self.cod_flight_block_dlg,
                                            self.path_plugin,
                                            self.path_db_project,
                                            self.str_epsg_crs_project)
        self.qutline_tool_dlg.show()

    def remove_camera(self):
        """
        Brief: Elimina el sensor seleccionado en el combobox de la tabla camera y actualiza el campo correspondiente
                de la tabla [flight_block] en bloques no procesados
        """
        if self.ui.comboBox_Camera.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No sensor selected",
                                                Qgis.Info,
                                                20)
            return
        else:
            # elimina el sensor de la tabla [camera] tanto de la BD del proyecto como de la BD plantilla
            current_sensor = self.ui.comboBox_Camera.currentText()
            str_sql = "DELETE FROM camera WHERE cod_camera = '" + current_sensor + "';"
            # elimina el sensor de tabla [camera] en la BD del proyecto
            self.db_op.execute_query_old(self.path_db_project,
                                               str_sql)

            # pone a '-1' el valor de cod_camera de la tabla [flight_block] de bloques no procesados
            str_sensor_no_value = "-1"
            str_query = "UPDATE flight_block SET cod_camera = '"
            str_query += str_sensor_no_value + "' "
            str_query += "WHERE ((cod_camera = '" + current_sensor + "') AND (id_process_st = 0));"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query)

            str_msg = "Sensor " + current_sensor + " has been removed from project and template database\n"
            str_msg += "The sensor field in flight blocks no processed has been updated"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Info,
                                                20)

            self.fill_combo_camera(self.path_db_project)  # actualiza combobox camera

    def remove_flight_block(self):
        """
        Brief: Elimina un bloque de vuelo seleccionado
        """
        # Captura el código seleccionado en el combo
        str_flight_block_selected = self.ui.comboBox_FlightBlock.currentText()

        if len(str_flight_block_selected) > 0:
            self.current_index_flight_block = self.ui.comboBox_FlightBlock.currentIndex()

            # CASO VUELO LINEAL. Elimina todos los registros de la tabla [flight_block_c_axis] con codigo seleccionado
            if self.int_photogrammetric_mission_type == 1:  # vuelo lineal
                str_query_del_axis = "DELETE FROM flight_block_c_axis WHERE cod_flight_block = '" + str_flight_block_selected + "'"
                self.db_op.execute_query_old(self.path_db_project,
                                                   str_query_del_axis)

            # Elimina registros de la tabla [output_c_images]
            str_query_del_output_c_images = "DELETE FROM output_c_images WHERE cod_flight_block = '" + str_flight_block_selected + "'"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query_del_output_c_images)

            # Elimina registros de la tabla [output_c_stereo_pairs]
            str_query_del_output_c_stereo_pairs = "DELETE FROM output_c_stereo_pairs WHERE cod_flight_block = '" + str_flight_block_selected + "'"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query_del_output_c_stereo_pairs)

            # Elimina registros de la tabla [output_c_strips]
            str_query_del_output_c_strips = "DELETE FROM output_c_strips WHERE cod_flight_block = '" + str_flight_block_selected + "'"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query_del_output_c_strips)

            # Elimina registros de la tabla [output_side_overlap]
            str_query_del_output_side_overlap = "DELETE FROM output_side_overlap WHERE cod_flight_block = '" + str_flight_block_selected + "'"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query_del_output_side_overlap)

            # Elimina registros de la tabla [output_strips_connections]
            str_query_del_output_strips_connections = "DELETE FROM output_strips_connections WHERE cod_flight_block = '" + str_flight_block_selected + "'"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query_del_output_strips_connections)

            # Elimina registros de la tabla [output_strips_images]
            str_query_del_output_strips_images = "DELETE FROM output_strips_images WHERE cod_flight_block = '" + str_flight_block_selected + "'"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query_del_output_strips_images)

            # Elimina todos los registro de la tabla [flight_block]
            str_query_del_flight_block = "DELETE FROM flight_block WHERE cod_flight_block = '" + str_flight_block_selected + "'"
            self.db_op.execute_query_old(self.path_db_project,
                                               str_query_del_flight_block)

            # Elimina la correspondiente carpeta del bloque de vuelo
            str_path_directory_to_remove = os.path.join(self.current_path_project_directory, str_flight_block_selected)
            if os.path.exists(str_path_directory_to_remove):
                shutil.rmtree(str_path_directory_to_remove)

            self.fill_combo_nemo_flight_block(self.path_db_project)  # Actualiza el combo de bloque de vuelo

            self.ui.groupBox_CurrentFlightBlock.setVisible(False)  # hace invisible el resto del panel

        else:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No flight block selected",
                                                level=Qgis.Critical)

    def remove_axis(self):
        """
        Elimina el axis seleccionado en el tableView
        """
        current_index_table = self.ui.tableView_segments.currentIndex()
        if (not current_index_table.isValid()):
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "No axis selected",
                                                Qgis.Info,
                                                20)
            return
        else:
            registro = self.model_axis.record(current_index_table.row())
            str_id_selected = str(registro.value("id"))
            str_sql = "DELETE FROM flight_block_c_axis WHERE id = " + str_id_selected + ";"
            self.db_op.execute_query_old(self.path_db_project, str_sql)

            self.fill_tableview_axis()  # actualiza table view

    def refresh_combo_axis(self):
        """
        """
        self.fill_combo_axis_segments(self.path_db_project)

        self.fill_combo_axis_paflr(self.path_db_project,
                                   self.cod_flight_block_dlg)

    def refresh_combo_vector(self):
        """
        """
        print("vector")
        self.fill_combo_id_vector(self.path_db_project)

    def refresh_combo_zone(self):
        """
        """
        print("zone")
        self.fill_combo_id_zone(self.path_db_project)

    def refresh_combos_tof_lnd(self):
        """
        """
        self.fill_combo_tof_points(self.path_db_project)
        self.fill_combo_lnd_points(self.path_db_project)
        # self.fill_combo_shp_points(self.path_db_project)

    # DHL: 20150805
    # TODO: meter esta función en Database
    def removeShapefile(self, shapeFileName):
        fileInfo = QtCore.QFileInfo(shapeFileName)
        filePath = fileInfo.absolutePath()
        fileBaseName = fileInfo.baseName()
        shapeFileExtensions = ['shp', 'shx', 'dbf', 'prj', 'qpj', 'cpg']
        for ext in shapeFileExtensions:
            fileNameToDelete = filePath + '/' + fileBaseName + '.' + ext
            QtCore.QFile.remove(fileNameToDelete)


    def set_checkbox_fitAxis(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente checkbox
        """
        field_update = "id_wae"  # TODO: Cambiar id de columna por fit axis
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            int_value = row[0]

        if int_value == 1:
            self.ui.checkBox_fitAxis.setChecked(True)
            if self.ui.comboBox_NBK.currentIndex() == 2:  # 20190109: Tb debe cumplir NBK=ON
                self.ui.doubleSpinBox_shotInterval.setMinimum(0)  # con fitAxis checked -> min_value = 0
                # self.ui.doubleSpinBox_shotInterval.setValue(0) # Propone shotInterval.value = 0 cuando FitAxis = On
        else:
            self.ui.checkBox_fitAxis.setChecked(False)
            if self.control_flightblock_change or self.int_photogrammetric_mission_type == 2:  # vuelo zonal:
                # 20190206: solo se ejecuta si no se está cambiando de flightblock
                self.ui.doubleSpinBox_shotInterval.setMinimum(0.5)  # con fitAxis disabled -> min_value = 0.5

    def set_checkbox_SmoothV(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente checkbox
        """
        field_update = "wpb"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            int_value = row[0]

        if int_value == 1:
            self.ui.checkBox_SmoothV.setChecked(True)
        else:
            self.ui.checkBox_SmoothV.setChecked(False)

    def set_double_spinbox_ac_gps(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "ac_gps"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_accGps.setValue(value_double_spin)

    def set_double_spinbox_ac_kap(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "ac_kap"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_accKappa.setValue(value_double_spin)

    def set_double_spinbox_ac_omega(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "ac_omg"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_accOmega.setValue(value_double_spin)

    def set_double_spinbox_ac_phi(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "ac_phi"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_accPhi.setValue(value_double_spin)

    def set_double_spinbox_ascent_speed(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "ascent_speed"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_speedAsc.setValue(value_double_spin)

    def set_double_spinbox_average_height_object(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "av_height_obj"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_averageHeightObject.setValue(value_double_spin)

    def set_double_spinbox_cruise_speed(self,
                                        cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "cruise_speed"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_speedCruising.setValue(value_double_spin)

    def set_double_spinbox_descent_speed(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "descent_speed"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_speedDes.setValue(value_double_spin)

    def set_double_spinbox_end_height(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "end_height"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_heightEnd.setValue(value_double_spin)

    def set_double_spinbox_foward_overlap(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "foward_overlap"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]
        self.ui.doubleSpinBox_overlapFwd.setValue(value_double_spin)

    def set_double_spinbox_gpa(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "gpa"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]
        self.ui.doubleSpinBox_GPA.setValue(value_double_spin)

    def set_double_spinbox_gsd(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "gsd"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]
        self.ui.doubleSpinBox_gsd.setValue(value_double_spin)

    def set_double_spinbox_initial_height(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "initial_height"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_heightStart.setValue(value_double_spin)

    def set_double_spinbox_lea(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "lea"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_linealEnlargement.setValue(value_double_spin)

    def set_double_spinbox_offset_omega(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "offset_omega"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_offsetOmega.setValue(value_double_spin)
        self.old_value_offset_omega = value_double_spin  # se almacena valor para restituir si el usuario pasa el dominio omega_angle - offset_omega

    def set_double_spinbox_offset_phi(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "offset_phi"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_offsetPhi.setValue(value_double_spin)

    def set_double_spinbox_offset_kappa(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "offset_kappa"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_offsetKappa.setValue(value_double_spin)

    def set_double_spinbox_omega_angle(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "omega_angle"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_omegaAngle.setValue(value_double_spin)

    def set_double_spinbox_phi_angle(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "phi_angle"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_phiAngle.setValue(value_double_spin)

    def set_double_spinbox_shot_interval(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "shot_interval"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        if value_double_spin == 0:
            self.ui.doubleSpinBox_shotInterval.setMinimum(0)
        self.ui.doubleSpinBox_shotInterval.setValue(value_double_spin)

    def set_double_spinbox_side_overlap(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "side_overlap"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_overlapSide.setValue(value_double_spin)

    def set_double_spinbox_ssh(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "ssh"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_SSH.setValue(value_double_spin)

    def set_double_spinbox_tol_gsd(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "tol_gsd"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        self.ui.doubleSpinBox_tolGsd.setValue(value_double_spin)

    def set_double_spinbox_hbl(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "images_item"  # TODO: renombrar en la base de datos
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        if (value_double_spin == c.CONST_DEFAULT_VALUE_KEY_COMBOS):
            self.ui.checkBox_HBL.setChecked(True)
            self.ui.doubleSpinBox_HBL.setEnabled(False)
        else:
            self.ui.checkBox_HBL.setChecked(False)
            self.ui.doubleSpinBox_HBL.setEnabled(True)
        self.ui.doubleSpinBox_HBL.setValue(value_double_spin)

    def set_double_spinbox_wal(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "wal"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        if (value_double_spin == c.CONST_DEFAULT_VALUE_KEY_COMBOS):
            self.ui.checkBox_WAL.setChecked(False)
            self.ui.doubleSpinBox_WAL.setEnabled(False)
        else:
            self.ui.doubleSpinBox_WAL.setValue(value_double_spin)
            self.ui.checkBox_WAL.setChecked(True)
            self.ui.doubleSpinBox_WAL.setEnabled(True)
            # 20170413: permite activar pero con valor fijo 0.5m/s (valor no controlable desde Mavlink protocol)

    def set_double_spinbox_was(self, cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente doubleSpinBox
        """
        field_update = "was"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_double_spin = row[0]

        if (value_double_spin == c.CONST_DEFAULT_VALUE_KEY_COMBOS):
            self.ui.checkBox_WAS.setChecked(True)
            self.ui.doubleSpinBox_WAS.setEnabled(False)
            self.ui.doubleSpinBox_WAS.setValue(self.default_value_was)
        else:
            self.ui.checkBox_WAS.setChecked(False)
            self.ui.doubleSpinBox_WAS.setEnabled(True)
            self.ui.doubleSpinBox_WAS.setValue(value_double_spin)

    def set_index_combo_camera(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "cod_camera"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_db = row[0]  # en este caso value y key son lo mismo

        if (value_db == c.CONST_DEFAULT_VALUE_KEY_COMBOS or value_db == 0 or value_db == "-1" or value_db == "unknown" or value_db == None or len(
                value_db) == 0):  # -1
            self.ui.comboBox_Camera.setCurrentIndex(0)
            self.ui.doubleSpinBox_accKappa.setEnabled(False)
            self.ui.doubleSpinBox_accOmega.setEnabled(False)
            self.ui.doubleSpinBox_accPhi.setEnabled(False)
        else:
            index_combo = self.ui.comboBox_Camera.findText(value_db)
            self.ui.comboBox_Camera.setCurrentIndex(index_combo)
            self.ui.doubleSpinBox_accKappa.setEnabled(True)
            self.ui.doubleSpinBox_accOmega.setEnabled(True)
            self.ui.doubleSpinBox_accPhi.setEnabled(True)

    def set_index_combo_eal(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_eal"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db == None:
            return

        if key_db > c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            # pone el combo en el índice correspondiente
            str_value_dic = self.dictionary_eal[key_db]
            index_combo = self.ui.comboBox_EAL.findText(str_value_dic)
            self.ui.comboBox_EAL.setCurrentIndex(index_combo)
        else:
            self.ui.comboBox_EAL.setCurrentIndex(0)

    def set_index_combo_egi(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_egi"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db == None:
            return

        if key_db > c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            # pone el combo en el índice correspondiente
            str_value_dic = self.dictionary_egi[key_db]
            index_combo = self.ui.comboBox_EGI.findText(str_value_dic)
            self.ui.comboBox_EGI.setCurrentIndex(index_combo)
        else:
            self.ui.comboBox_EGI.setCurrentIndex(0)

    def set_index_combo_erc(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_erc"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db == None:
            return

        if key_db > c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            # pone el combo en el índice correspondiente
            str_value_dic = self.dictionary_erc[key_db]
            index_combo = self.ui.comboBox_ERC.findText(str_value_dic)
            self.ui.comboBox_ERC.setCurrentIndex(index_combo)
        else:
            self.ui.comboBox_ERC.setCurrentIndex(0)

    def set_index_combo_firmware(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field = "id_firmware"
        str_sql = "SELECT " + field + " FROM flight_block "
        str_sql += "WHERE cod_flight_block = '" + self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db == "-1":  # '-1' ojo es una cadena de texto
            self.ui.comboBox_Firmware.setCurrentIndex(0)
        else:
            if (key_db in self.dictionary_firmware):
                value_db = self.dictionary_firmware[key_db]  # valor en tabla maestra [firmware] almacenado previamente en diccionario
                index_combo = self.ui.comboBox_Firmware.findText(value_db)  # obtiene el índice de ese valor en el combo
                self.ui.comboBox_Firmware.setCurrentIndex(index_combo)
            else:
                self.ui.comboBox_Firmware.setCurrentIndex(0)

    def set_index_combo_landing_point(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_lnd"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_db = row[0]  # en este caso value y key son lo mismo

        if value_db == (c.CONST_DEFAULT_VALUE_KEY_COMBOS - 1):  # caso especial Select id landing (valor almacenado = -2)
            self.ui.comboBox_lndPoints.setCurrentIndex(0)
        if value_db == (c.CONST_DEFAULT_VALUE_KEY_COMBOS):  # takeoff point (valor almacenado = -1)
            self.ui.comboBox_lndPoints.setCurrentIndex(1)
        # if value_db == (c.CONST_DEFAULT_VALUE_KEY_COMBOS + 1): # last waypoint (valor almacenado = 0)
        #     self.ui.comboBox_lndPoints.setCurrentIndex(2)
        if value_db > (c.CONST_DEFAULT_VALUE_KEY_COMBOS + 1):  # cualquier id (valor almacenado > 0)
            index_combo = self.ui.comboBox_lndPoints.findText(str(value_db))
            self.ui.comboBox_lndPoints.setCurrentIndex(index_combo)

    def set_index_combo_mounting_type(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_mounting_type"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db != c.CONST_DEFAULT_VALUE_KEY_COMBOS:
            # pone el combo en el índice correspondiente
            str_value_dic = self.dictionary_mounting[key_db]
            index_combo = self.ui.comboBox_mountingType.findText(str_value_dic)
            self.ui.comboBox_mountingType.setCurrentIndex(index_combo)
        else:
            self.ui.comboBox_mountingType.setCurrentIndex(0)  # por defecto +Y axis forward (0 deg.)

    def set_index_combo_nbk(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_nbk"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db != None:
            # pone el combo en el índice correspondiente
            str_value_dic = self.dictionary_nbk[key_db]
            index_combo = self.ui.comboBox_NBK.findText(str_value_dic)
            self.ui.comboBox_NBK.setCurrentIndex(index_combo)
        else:
            self.ui.comboBox_NBK.setCurrentIndex(0)

    def set_index_combo_npsf(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "npsf"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        # pone el combo en el índice correspondiente
        index_combo = self.ui.comboBox_numberOfPointsInSideFrame.findText(str(key_db))
        self.ui.comboBox_numberOfPointsInSideFrame.setCurrentIndex(index_combo)

    def set_index_combo_shp(self, cursor_db_project):
        """
        Brief:
        Recuerda que el valor almacenado en BD -1 hace referencia a landing point y el valor 0 hace referencia a take-off point
        Valores mayores de 0, hacen referencia a códigos de puntos grabados en la capa GIS de landing points
        """

        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_shp"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_db = row[0]  # en este caso value y key son lo mismo

        if value_db == None:
            self.ui.comboBox_SHP.setCurrentIndex(0)
        if value_db == -1:  # takeoff point
            self.ui.comboBox_SHP.setCurrentIndex(1)
        if value_db == 0:  # landing point
            self.ui.comboBox_SHP.setCurrentIndex(2)

    def set_index_combo_takeoff_point(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_tof"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_db = row[0]  # en este caso value y key son lo mismo

        if value_db == c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            self.ui.comboBox_tofPoints.setCurrentIndex(0)
        else:
            index_combo = self.ui.comboBox_tofPoints.findText(str(value_db))
            self.ui.comboBox_tofPoints.setCurrentIndex(index_combo)

    def set_index_combo_trajectory_type(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_trajectory_type"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db > c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            # pone el combo en el índice correspondiente
            str_value_dic = self.dictionary_trajectory_type[key_db]
            index_combo = self.ui.comboBox_trajectoryType.findText(str_value_dic)
            self.ui.comboBox_trajectoryType.setCurrentIndex(index_combo)
            if index_combo <= 2:  # 20170329: Trayectorias tipo 1 y 2: perfil vertical basada en valor de GSD y tolerancia
                self.ui.doubleSpinBox_tolGsd.setEnabled(True)
            else:  # 20170329: Resto de trayectorias. Habituales tramos largos con pendiente uniforme.
                self.ui.doubleSpinBox_tolGsd.setEnabled(False)
                if self.fb_process_status == 0:  # No procesado
                    self.ui.doubleSpinBox_tolGsd.setValue(0)
        else:
            self.ui.comboBox_trajectoryType.setCurrentIndex(0)

    def set_index_combo_type_gimbal_mount(self, cursor_db_project):
        """
        Brief:
        """
        # obtiene valor almacenado en tabla [flight_block]
        field_update = "id_type_gimbel_mount"
        str_sql = "SELECT " + field_update + " FROM flight_block WHERE cod_flight_block = '"
        str_sql += self.cod_flight_block_dlg + "';"
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            key_db = row[0]

        if key_db > c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            # pone el combo en el índice correspondiente
            self.ui.doubleSpinBox_accKappa.setEnabled(True)  # acc_kappa sólo depende del type gimbal mount
            str_value_dic = self.dictionary_type_gimbal_mount[key_db]
            index_combo = self.ui.comboBox_typeGimbalMount.findText(str_value_dic)
            self.ui.comboBox_typeGimbalMount.setCurrentIndex(index_combo)
        else:
            self.ui.comboBox_typeGimbalMount.setCurrentIndex(0)
            self.ui.doubleSpinBox_accKappa.setEnabled(False)  # acc_kappa depende del type gimbal mount


    def set_index_combo_vector(self, cursor_db_project):
        """
        Brief:
        """
        field_name = "id_vector"
        str_sql = "SELECT %s FROM flight_block WHERE cod_flight_block = '%s';" % (field_name, self.cod_flight_block_dlg)
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_db = row[0]

        if value_db == c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            self.ui.comboBox_idVector.setCurrentIndex(0)
        else:
            index_combo = self.ui.comboBox_idVector.findText(str(value_db))
            self.ui.comboBox_idVector.setCurrentIndex(index_combo)

    def set_index_combo_zone(self, cursor_db_project):
        """
        Brief:
        """
        field_name = "id_zone"
        str_sql = "SELECT %s FROM flight_block WHERE cod_flight_block = '%s';" % (field_name, self.cod_flight_block_dlg)
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_db = row[0]

        if value_db == c.CONST_DEFAULT_VALUE_KEY_COMBOS:  # -1
            self.ui.comboBox_idZone.setCurrentIndex(0)
        else:
            index_combo = self.ui.comboBox_idZone.findText(str(value_db))
            self.ui.comboBox_idZone.setCurrentIndex(index_combo)

    def set_lineedit_dtm(self,
                         cursor_db_project):
        """
        brief:
        """
        if self.filling_combo_flight_block or self.fb_process_status == 1:  # a un bloque ya procesado no cambiarle nada
            return

        fieldname = "dtm_path"
        str_sql = "SELECT %s FROM flight_block WHERE cod_flight_block = '%s';" % (fieldname,
                                                                                  self.cod_flight_block_dlg)
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_database = row[0]
        if value_database is not None:
            path_dtm_database = os.path.normcase(value_database)
            if os.path.exists(path_dtm_database):
                self.ui.lineEdit_pathDTM.setText(path_dtm_database)
            else:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "Path DTM store in database %s no exists" % path_dtm_database,
                                                    Qgis.Critical,
                                                    20)
                self.ui.lineEdit_pathDTM.clear()
        else:
            self.ui.lineEdit_pathDTM.clear()

    def set_minimal_ui(self):

        self.ui.toolButton_ImportProject.setVisible(False)
        self.ui.toolButton_ExportProject.setVisible(False)
        self.ui.toolButton_ExportProjects.setVisible(False)
        self.ui.toolButton_generateImages.setVisible(False)
        self.ui.mGroupBox_privateWidgets.setVisible(False)

        self.ui.mGroupBox_spatialData.setVisible(False)
        self.ui.mGroupBox_imagingAcquisitionParameters.setVisible(False)
        self.ui.mGroupBox_geometricNavigationParameters.setVisible(False)
        self.ui.mGroupBox_calculatedParametersGSD.setVisible(False)
        self.ui.mGroupBox_processingResults.setVisible(False)
        self.ui.groupBox_segmentsPaflr.setVisible(False)

        self.ui.frame_fb.setStyleSheet('background-color: rgb(231,237,247)')
        self.ui.frame_project.setStyleSheet('background-color: rgb(231,237,247)')

    def set_spinbox_n_strips(self,
                             cursor_db_project):
        """
        Brief: Pone el valor grabado en la base de datos en el correspondiente spinBox
        """
        fieldname = "n_strips"
        str_sql = "SELECT %s FROM flight_block WHERE cod_flight_block = '%s';" % (fieldname,
                                                                                  self.cod_flight_block_dlg)
        cursor_db_project.execute(str_sql)
        for row in cursor_db_project.fetchall():
            value_spin = row[0]

        self.ui.spinBox_nStrips.setValue(value_spin)

    def set_time_duration_flight(self,
                                 time_store_in_db):
        """
        Brief: Pone la duración del vuelo calculada en el script y grabada en la BD en el QTimeEdit
                en formato horas, minutos y segundos
        param[in]: tiempo grabado en segundos
        """
        horas_decimal = time_store_in_db / 3600.0
        horas_parte_entera = int(horas_decimal)
        horas_parte_decimal = abs(horas_decimal) - abs(int(horas_decimal))

        minutos_decimal = horas_parte_decimal * 60.0
        minutos_parte_entera = int(minutos_decimal)
        minutos_parte_decimal = abs(minutos_decimal) - abs(int(minutos_decimal))

        segundos_decimal = minutos_parte_decimal * 60.0
        segundos_parte_entera = int(segundos_decimal)

        time = QtCore.QTime(horas_parte_entera,
                            minutos_parte_entera,
                            segundos_parte_entera)
        self.ui.timeEdit.setTime(time)

    def set_ui_behaivor(self):
        # inicializa los dominios, pasos y default_values de los doubleSpinBox y spinBox
        # que no dependen de valores de otros comboBox desde la base de datos plantilla
        self.initialize_domains_steps_from_db(self.path_db_project)

        # habilita/deshabilita widgets de parámetros dependientes de combobox
        self.initialize_enabled_spins_depends_combo()

        self.intialize_combobox()  # rellena combobox

        self.initialize_signals_slots_after_enabled_project()

        self.is_set_ui_behaivor = True

    def set_widget_duration_battery_vs_fly(self):
        """
        Brief:
        """
        self.ui.progressBar_battVsDuration.reset()
        self.ui.label_42.setText("(Check always the viability of the Mission)")

        duracion_baterias_seg = self.ui.doubleSpinBox_batteryDuration.value()  # establecido cuando cambia la versión de firmware
        if (self.time_store_in_db > 0):
            porcentaje_duracion = (self.time_store_in_db / duracion_baterias_seg) * 100
            int_porcentaje_duracion = int(round(porcentaje_duracion, 0))
            int_porcentaje_duracion_real = int_porcentaje_duracion
            grad_scale_factor1 = 0.40 * 100 / int_porcentaje_duracion
            grad_scale_factor2 = 0.92 * 100 / int_porcentaje_duracion

            default_style = "QProgressBar{" + "\n"
            default_style += "\tborder: 2px solid grey;" + "\n"
            default_style += "\tborder-radius: 5px;" + "\n"
            default_style += "\ttext-align: center" + "\n"
            default_style += "}" + "\n"
            default_style += "QProgressBar::chunk {" + "\n"
            default_style += "\tbackground-color: qlineargradient(spread:pad, x1:"
            default_style += str(grad_scale_factor1)
            default_style += ", y1:0, x2:"
            default_style += str(grad_scale_factor2)
            default_style += ", y2:0, stop:0 rgba(170, 255, 127, 255), stop:1 rgba(255, 51, 51, 255));" + "\n"
            default_style += "}" + "\n"

            critical_style = "QProgressBar{" + "\n"
            critical_style += "\tbackground-color: rgb(255, 0, 0);" + "\n"
            critical_style += "\tborder: 2px solid yellow;" + "\n"
            critical_style += "\tborder-radius: 5px;" + "\n"
            critical_style += "\ttext-align: center" + "\n"
            critical_style += "}" + "\n"
            critical_style += "QProgressBar::chunk {" + "\n"
            critical_style += "\tbackground-color: rgb(255, 0, 0);" + "\n"
            critical_style += "}" + "\n"

            # habilita la barra de progreso comparando la duración de las baterías
            self.ui.progressBar_battVsDuration.setEnabled(True)

            if int_porcentaje_duracion <= 100:
                self.ui.progressBar_battVsDuration.setStyleSheet(default_style)

            if int_porcentaje_duracion > 100:
                self.ui.progressBar_battVsDuration.setStyleSheet(critical_style)
                self.ui.label_42.setText("CRITICAL WARNING !! Mission not feasible (Too long)")

            if int_porcentaje_duracion > 100:
                int_porcentaje_duracion = -1
            self.ui.progressBar_battVsDuration.setValue(int_porcentaje_duracion)

    def show_about_dlg(self):
        """
        Brief: Levanta el panel acerca de ...
        """
        self.about_qdialog = AboutQDialog()
        self.about_qdialog.show()

    def store_path_dtm_in_db(self,
                             path):
        """
        graba en la base de datos el valor del path
        """
        path_dtm_normalize = os.path.normcase(path)  # normaliza la ruta del path
        str_sql = "UPDATE flight_block SET dtm_path = '%s' WHERE cod_flight_block = '%s'" % (path_dtm_normalize,
                                                                                             self.cod_flight_block_dlg)
        self.db_op.execute_query_old(self.path_db_project,
                                           str_sql)

    def update_camera(self):
        """
        brief:
        """
        # codigo de sensor a modificar
        if self.ui.comboBox_Camera.currentIndex() == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select sensor to edit",
                                                Qgis.Critical,
                                                10)

            return
        cod_sensor = self.ui.comboBox_Camera.currentText()
        self.dlg_update_camera = updateCameraDlg(self.iface,
                                                 self.path_db_project,
                                                 cod_sensor)

        self.dlg_update_camera.show()  # show the dialog
        result = self.dlg_update_camera.exec_()  # Run the dialog

    def view_table_flight_block(self):
        """
        Brief: Abre tabla para visualizar los datos de los bloques de vuelo
        """
        str_pflip_fb_tablename = 'flight_block'

        # borra la tabla si existelegendInterface
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        for layer in layers:
            layer_name = layer.name()
            if ((layer_name == str_pflip_fb_tablename)):
                layer_id = layer.id()
                QgsProject.instance().removeMapLayer(layer_id)

        # carga la tabla en la leyenda
        path_symbol_axis = self.path_plugin + '/templates/qgis_templates/style_flight_block_table_qgis0304.qml'

        self.q3_api_op.load_to_qgis(False,
                                    self.path_db_project,
                                    str_pflip_fb_tablename,
                                    "no_spatial",
                                    path_symbol_axis,
                                    None)
        # abre la tabla de atributos
        self.iface.showAttributeTable(self.iface.activeLayer())

    def virtual_slope_dtm_tool(self):
        """
        """
        self.vitual_slope_dtm_tool_dlg = VirtualSlopeDtmTool(self.iface,
                                                             self.my_qsettings,
                                                             self.path_plugin)
        self.vitual_slope_dtm_tool_dlg.show()