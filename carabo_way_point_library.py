# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PflipUav3
                                 A QGIS plugin
 Photogrammetric and Remote Sensing Flight Planning for unmanned aerial vehicle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-23
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernández López, PAFYC-UCLM
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# import PyQt classes
from PyQt5.QtWidgets import (QMessageBox)

# import PyQGIS classes
from qgis.core import (Qgis)

from math import *

# import self classes
from .PyGeodesy.AngleFunctions.angle_functions import *
from .classes.qgis3_api_operations import Qgis3ApiOperations
from .classes.db_operations import *
from .PyGeodesy.GeodeticCalculations.geodetic_calculations import *
from . import config as c  # constants

# valores constantes
CONST_PI = 4.0 * atan(1.0)
CONST_GEODETIC_CALCULATIONS_NO_ERROR = 0
MAV_CMD_HEADER = "QGC WPL "
MAV_PROTOCOL_VERSION = 110
CONST_MAV_POSTGIS_SRID_CRS_CODE = 4258
MAV_FRAME_GLOBAL = str(0)
MAV_FRAME_GLOBAL_RELATIVE_ALT = str(3)
MAV_CMD_NAV_WAYPOINT = str(16)
MAV_CMD_NAV_RETURN_TO_LAUNCH = str(20)
MAV_CMD_NAV_LAND = str(21)
MAV_CMD_NAV_TAKEOFF = str(22)
MAV_CMD_NAV_SPLINE_WAYPOINT = str(82)
MAV_CMD_CONDITION_DELAY = str(112)
MAV_CMD_CONDITION_CHANGE_ALT = str(113)
MAV_CMD_CONDITION_YAW = str(115)
MAV_CMD_DO_CHANGE_SPEED = str(178)
MAV_CMD_DO_SET_HOME = str(179)
MAV_CMD_DO_DIGICAM_CONTROL = str(203)
MAV_CMD_DO_MOUNT_CONTROL = str(205)
MAV_MOUNT_MODE = str(3)  # parámetro 7
MAV_CMD_DO_SET_CAM_TRIGG_DIST = str(206)

CONST_MAV_CMD_TIME_TO_INITIALIZE_ROUTE = 20.0 # Colchón de tiempo de operación antes del inicio de misión automática.
CONST_MAV_CMD_SYS_DEFAULT_VALUE = 67.5 # deg/sec. DONE: 20161231 Se reduce ACRO_YAW_Z de 4.5 a 1.5.
minimal_safe_hTOF = 5

class CaraboWayPointLibrary:
    def __init__(self,
                 iface,
                 postgis_srid_crs_project_mflip_integer,
                 path_uav_navigation_file_name,
                 path_uav_navigation_time_file_name,
                 angle_advanced_columns_to_axis_flight,
                 x_takeoff,
                 y_takeoff,
                 z_dtm_takeoff_interpolate,
                 x_landing,
                 y_landing,
                 z_dtm_lnd_interpolate,
                 xLs,
                 yLs,
                 zLs,
                 uav_images_by_strip,
                 list_parameter_db_flight_block,
                 path_db_project,
                 str_firmware,
                 str_mission_type,
                 lst_jogs,
                 theoretical_base_length,
                 path_plugin):
        """
        Brief: inicialización del cuerpo de la clase. Crea e imprime el script de navegación
        :param iface: iface - interfaz de usuario QGIS
        :type iface: QgsInterface
        :param postgis_srid_crs_project_mflip_integer: código EPSG del proyecto MFLiP
        :type postgis_srid_crs_project_mflip_integer: int
        :param path_uav_navigation_file_name: ruta del fichero donde se almacenará el script de navegación
        :type path_uav_navigation_file_name: str
        :param path_uav_navigation_time_file_name: ruta del fichero de tiempos
        :type path_uav_navigation_time_file_name: str
        :param angle_advanced_columns_to_axis_flight: Si es 0 o pi el eje de vuelo coincide con las columnas
        :type angle_advanced_columns_to_axis_flight: float
        :param x_takeoff: Primera coordenada del punto de despegue
        :type x_takeoff: float
        :param y_takeoff: Segunda coordenada del punto de despegue
        :type y_takeoff: float
        :param z_dtm_takeoff_interpolate: Altitud ortométrica del punto de despegue, en metros
        :type z_dtm_takeoff_interpolate: float
        :param x_landing: Primera coordenada del punto de aterrizaje
        :type x_landing: float
        :param y_landing: Segunda coordenada del punto de aterrizaje
        :type y_landing: float
        :param z_dtm_lnd_interpolate: Altitud ortométrica del punto de aterrizaje, en metros
        :type z_dtm_lnd_interpolate: float
        :param xLs: Vector con las primeras coordenadas de los puntos de toma
        :type xLs: list
        :param yLs: Vector con las segundas coordenadas de los puntos de toma
        :type yLs: list
        :param zLs: Vector con las altitudes ortométrica de los puntos de toma, en metros
        :type zLs: list
        :param uav_images_by_strip: Diccionario con las imágenes por pasada
        :type uav_images_by_strip: dict
        :param list_parameter_db_flight_block: lista python con todos los parámetros para ese bloque de vuelo
        :type list_parameter_db_flight_block: list
        :param path_db_project: ruta del fichero sqlite del proyecto
        :type path_db_project: str
        :param str_firmware: versión de uav model firmware necesario para distintos comandos
        :type str_firmware: str
        :param str_mission_type: tipo de misión: lineal o zonal
        :type str_mission_type: str
        :return: Falso si se produce algún error.
        """

        self.iface = iface
        self.postgis_srid_crs_project_mflip_integer = postgis_srid_crs_project_mflip_integer
        self.path_uav_navigation_file_name = path_uav_navigation_file_name
        self.path_uav_navigation_time_file_name = path_uav_navigation_time_file_name
        self.angle_advanced_columns_to_axis_flight = angle_advanced_columns_to_axis_flight
        self.x_takeoff = x_takeoff
        self.y_takeoff = y_takeoff
        self.z_dtm_takeoff_interpolate = z_dtm_takeoff_interpolate
        self.x_landing = x_landing
        self.y_landing = y_landing
        self.z_dtm_lnd_interpolate = z_dtm_lnd_interpolate
        self.xLs = xLs
        self.yLs = yLs
        self.zLs = zLs
        self.uav_images_by_strip = uav_images_by_strip
        self.list_parameter_db_flight_block = list_parameter_db_flight_block
        self.path_db_project = path_db_project
        self.str_firmware_version = str_firmware
        self.str_mission_type = str_mission_type
        self.lst_jogs = lst_jogs
        self.theoretical_base_length = theoretical_base_length
        self.path_plugin = path_plugin

        self.q3_api_op = Qgis3ApiOperations(self.iface)
        self.db_op = DbOperations(self.iface)  # new db operations

        self.instance_angle_functions = AngleFunctions()  # instancia a la clase de funciones angulares
        self.instance_geodetic_calculations = GeodeticCalculations(self.iface,
                                                                   self.path_db_project,
                                                                   self.path_plugin)  # instancia a la clase de cálculos geodésicos

        # función impresión script de navegación
        self.print_navigation_file

    def get_check_sum(self,
                      value):
        """
        Brief: Devuelve el valor del CheckSum de una cadena de texto
        :param value: valor cadena de texto
        :type value: str
        :return: Valor del CheckSum
        :rtype: int
        """
        sum = 0
        for i in range(len(value)):
            ascii_value = ord(value[i])
            sum += ascii_value
        while (sum > 256):
            sum -= 256
        int_value = 256 - 1 - sum
        return (int_value)

    @property
    def print_navigation_file(self):
        """
        Brief: función de impresión del script de navegación
        """
        # RECOPILACIÓN DE VARIABLES GRABADAS EN EL DIÁLOGO Y DE CONSTANTES NECESARIAS PARA LA ESCRITURA DEL SCRIPT

        # Función para CARABO_S2_S3 AC 3.#.# Mavlink 110
        int_id_version_firmware = self.list_parameter_db_flight_block[5]
        id_nbk = self.list_parameter_db_flight_block[21]  # no braking

        acceleration_factor = 1.0 # valor por defecto = 1.0

        acceleration = c.CONST_UAV_ACCELERATION_DEFAULT * acceleration_factor
        acceleration_Up = c.CONST_UAV_ACCELERATION_UPWARD_DEFAULT
        acceleration_Down = c.CONST_UAV_ACCELERATION_DOWNWARD_DEFAULT

        decceleration = c.CONST_UAV_DECCELERATION_DEFAULT * acceleration_factor
        decceleration_Up = c.CONST_UAV_DECCELERATION_UPWARD_DEFAULT
        decceleration_Down = c.CONST_UAV_DECCELERATION_DOWNWARD_DEFAULT

        ascend_speed = self.list_parameter_db_flight_block[17] + 1

        id_trajectory_type = self.list_parameter_db_flight_block[15]

        cruising_speed = self.list_parameter_db_flight_block[16]

        decrease_speed = self.list_parameter_db_flight_block[18] * -1

        landing_height = self.list_parameter_db_flight_block[22]

        smooth_V = self.list_parameter_db_flight_block[23] # antiguo campo para wpb (comando obsoleto)

        height_before_landing = self.list_parameter_db_flight_block[24]  # 20170411. (HBL) Altura antes de landing_height

        waiting_time_by_image = self.list_parameter_db_flight_block[25]  # shot interval

        float_sensor_attitude_omega_deg = self.list_parameter_db_flight_block[26]  # omega angle

        float_sensor_attitude_phi_deg = self.list_parameter_db_flight_block[27]  # phi angle

        fit_axis = self.list_parameter_db_flight_block[34]  # 20170411. Ajusta trayectoria a eje (misión lineal)

        float_wal = self.list_parameter_db_flight_block[35] # autolanding parameter

        float_was_value_dialog = self.list_parameter_db_flight_block[36]  # valor WAS introducido en el diálogo

        float_mount_attitude_offset_omega_deg = self.list_parameter_db_flight_block[41]  # offset_omega

        float_mount_attitude_offset_phi_deg = self.list_parameter_db_flight_block[42]  # offset phi
        # Tipo de aterrizaje
        # landing type (-1 - toff point; 0 - end point; > 0 - id del punto digitalizado
        id_lnd = self.list_parameter_db_flight_block[4]  # ojo es un entero

        takeoff_height = self.list_parameter_db_flight_block[20]

        # Comprobación de la coincidencia de las dimensiones de los vectores de coordenadas
        if (len(self.xLs) != len(self.yLs) or len(self.yLs) != len(self.zLs)):
            str_msg = "Dimensions of vectors coordinates don't match"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            return False

        # Control del techo de vuelo
        max_value_roof_height = 2000.0

        print_msg_roof_height = False

        maximum_height = max(self.zLs)
        if maximum_height > max_value_roof_height:
            print_msg_roof_height = True

        if print_msg_roof_height:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("Absolute Altitude: Warning !!          ")
            str_msg_informative_text = "Maximum altitude of the mission:\n" + format(maximum_height, '.1f') + " m AMSL.\n"
            msg.setInformativeText(str_msg_informative_text)
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText("The copter performance could decrease due to lower air density")
            msg.exec_()

        # APERTURA DE LOS FICHEROS DEL SCRIPT Y DE TIEMPOS

        # borra el fichero del script si existe (cálculos realizados y no guardados
        if (os.path.exists(self.path_uav_navigation_file_name)):
            os.remove(self.path_uav_navigation_file_name)

        # apertura para escritura del fichero del script de navegación
        file_uav_navigation_script = open(self.path_uav_navigation_file_name,"a")

        # borra el fichero de tiempos si existe (cálculos realizados y no guardados
        if (os.path.exists(self.path_uav_navigation_time_file_name)):
            os.remove(self.path_uav_navigation_time_file_name)

        # apertura para escritura del fichero de tiempos
        file_uav_navigation_time = open(self.path_uav_navigation_time_file_name,"a")

        # Se definen las coordenadas del punto de despegue como primer punto anterior
        x_last = self.x_takeoff
        y_last = self.y_takeoff
        self.z_takeoff = self.z_dtm_takeoff_interpolate + takeoff_height

        first_height_over_takeoff = self.zLs[0] - self.z_takeoff
        if float_was_value_dialog == -1:
            float_was_value_dialog = first_height_over_takeoff
            # 20180508. Evita vertical inicial <5m. Puede darse en ITH=1stWP y este < Z takeoff
            if first_height_over_takeoff < 5:
                float_was_value_dialog = 5
        # time_to_was = 0

        z_last = self.z_takeoff + float_was_value_dialog

        # cambio a Geodésicas ETRS89 del punto anterior
        if (self.postgis_srid_crs_project_mflip_integer != CONST_MAV_POSTGIS_SRID_CRS_CODE):
            qgs_point_transform = self.q3_api_op.transform_point_coordinates(x_last,
                                                                                   y_last,
                                                                                   self.postgis_srid_crs_project_mflip_integer,
                                                                                   CONST_MAV_POSTGIS_SRID_CRS_CODE)

            first_coordinate_transform = qgs_point_transform.x()
            second_coordinate_transform = qgs_point_transform.y()

        # Paso a ECEF del punto anterior
        control, xct_last_geocentrica, yct_last_geocentrica, zct_last_geocentrica = \
            self.instance_geodetic_calculations.crs_operation_to_geocentric_from_geoid_height(self.postgis_srid_crs_project_mflip_integer,
                                                                                              x_last,
                                                                                              y_last,
                                                                                              z_last,
                                                                                              self.z_dtm_takeoff_interpolate,
                                                                                              # ellipsoid_height_tof,
                                                                                              takeoff_height)
        if (not control):
            str_msg = "Para el punto aterrizaje ha fallado la conversión a coordenadas geocéntricas"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Warning,
                                                10)
            return False

        number_of_points = len(self.xLs)

        # Se pasan las coordenadas a ECEF y se calculan los puntos de parada
        xct_ls = []  # QVector<double> xctLs;
        yct_ls = []  # QVector<double> yctLs;
        zct_ls = []  # QVector<double> zctLs;
        longitudes = []  # QVector<double> longitudes; // En radianes
        latitudes = []  # QVector<double> latitudes; // En radianes
        slope_distances = []  # QVector<double> stopDistances;
        distances = []  # QVector<double> distances;
        # heights = []  # QVector<double> distances;
        azimuths_polar = []  # Polar azimuths from ENU coordinates
        verticals_polar = []  # Polar vertical angles from ENU coordinates
        # distances_to_stop_points = [] #QVector<double> distancesToStopPoints;
        longitude_last = first_coordinate_transform * CONST_PI / 180.0
        latitude_last = second_coordinate_transform * CONST_PI / 180.0
        ascent_gain = []
        descent_gain = []
        cumulative_total_ascent = 0
        cumulative_total_descent = 0

        for n_point in range(number_of_points):  # for(int nPoint=0;nPoint<numberOfPoints;nPoint++)
            # 1. Se obtienen las coordenadas UTM del punto
            x_point = self.xLs[n_point]
            y_point = self.yLs[n_point]
            z_point = self.zLs[n_point]  # Es altitud ortométrica

            # cálculo de las latitudes y longitudes
            if (self.postgis_srid_crs_project_mflip_integer != CONST_MAV_POSTGIS_SRID_CRS_CODE):
                # third_coordinate = 0.0 # Esta no se utiliza porque es transformacion entre geodesicas (long,lat)

                # Paso a geodésicas ETRS89
                qgs_point_transform = self.q3_api_op.transform_point_coordinates(x_point,
                                                                                 y_point,
                                                                                 self.postgis_srid_crs_project_mflip_integer,
                                                                                 CONST_MAV_POSTGIS_SRID_CRS_CODE)

                first_coordinate_transform = qgs_point_transform.x()
                second_coordinate_transform = qgs_point_transform.y()

            longitudes.append(first_coordinate_transform * CONST_PI / 180.0)
            latitudes.append(second_coordinate_transform * CONST_PI / 180.0)

            # Paso de (X,Y,Hdtm) a ECEF
            control, xct_point_geocentrica, yct_point_geocentrica, zct_point_geocentrica = \
                self.instance_geodetic_calculations.crs_operation_to_geocentric_from_geoid_height(self.postgis_srid_crs_project_mflip_integer,
                                                                                                  x_point,
                                                                                                  y_point,
                                                                                                  z_point,
                                                                                                  self.z_dtm_takeoff_interpolate,
                                                                                                  # ellipsoid_height_tof,
                                                                                                  takeoff_height)

            if (not control):
                str_msg = "Para el punto " + str(n_point) + " ha fallado la conversión a coordenadas geocéntricas"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Warning,
                                                    10)
                return False

            xct_ls.append(xct_point_geocentrica)
            yct_ls.append(yct_point_geocentrica)
            zct_ls.append(zct_point_geocentrica)

            # cálculo de las distancias para calcular el tiempo hasta posición del siguiente punto
            inc_xct = xct_point_geocentrica - xct_last_geocentrica
            inc_yct = yct_point_geocentrica - yct_last_geocentrica
            inc_zct = zct_point_geocentrica - zct_last_geocentrica

            control, inc_e, inc_n, inc_u = self.instance_geodetic_calculations.geocentric_2_enu(latitude_last,
                                                                                                longitude_last,
                                                                                                inc_xct,
                                                                                                inc_yct,
                                                                                                inc_zct)

            if (control != 0):  # 0 es el valor GEODETIC_CALCULATIONS_NO_ERROR
                str_msg = "Para el punto " + str(n_point) + " ha fallado la conversión ECEF - ENU del vector con el anterior"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Warning,
                                                    10)
                return False

            control, azimuth_polar, vertical_polar, slope_distance = self.instance_geodetic_calculations.enu_2_polar(
                inc_e,
                inc_n,
                inc_u)

            if (control != 0):  # 0 es el valor GEODETIC_CALCULATIONS_NO_ERROR
                str_msg = "Para el punto " + str(n_point + 1) + " ha fallado la conversión ENU - Polar del vector con el anterior"
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    str_msg,
                                                    Qgis.Warning,
                                                    10)
                return False

            distance2D = sqrt(pow(inc_e, 2.0) + pow(inc_n, 2.0))

            # 2. Se Rellenan las listas de datos geometricos de las pasadas

            distances.append(distance2D)
            slope_distances.append(slope_distance)
            # heights.append(z_point)
            azimuths_polar.append(azimuth_polar)
            verticals_polar.append(vertical_polar)

            longitude_last = first_coordinate_transform * CONST_PI / 180.0
            latitude_last = second_coordinate_transform * CONST_PI / 180.0

            xct_last_geocentrica = xct_point_geocentrica
            yct_last_geocentrica = yct_point_geocentrica
            zct_last_geocentrica = zct_point_geocentrica


        # /// COMIENZA LA ESCRITURA DE COMANDOS ///

        add_script_comments = True # añadir comentarios (true or false)
        home_height_offset = 0  # default = 0 ; if cmd:179 = (z_takeoff - z_landing)
        # k_smooth: Coeficiente de reducción del límite de velocidad vertical
        if smooth_V == 1:
            smooth_vertical = True # Trayectorias verticales spline activada.
            if cruising_speed <= 6:
                cruising_speed_x2 = (cruising_speed - 4) ** 2
                k_smooth_delta = 0.25 * (cruising_speed_x2) / 4
                k_smooth = 1 - k_smooth_delta
            elif cruising_speed < 4:
                k_smooth = 1.0
            else:
                k_smooth = 0.75
        else:
            smooth_vertical = False # Trayectorias verticales spline desactivada.
            k_smooth = 1.0

        # cabecera de fichero
        # QGC WPL + versión del protocolo
        str_line = MAV_CMD_HEADER
        str_line += str(MAV_PROTOCOL_VERSION)
        str_line += "\n"
        file_uav_navigation_script.writelines(str_line)

        id_shp = self.list_parameter_db_flight_block[31]
        line_number = 0

        if id_lnd == -1:  # Landing point = Takeoff point
            x_home = self.x_takeoff
            y_home = self.y_takeoff
            z_landing = self.z_dtm_takeoff_interpolate + takeoff_height
            z_home = z_landing
            home_position = "Landing point = Takeoff point"
        else:
            z_landing = self.z_dtm_lnd_interpolate
            if id_shp == 0:  # Landing Point (default)
                x_home = self.x_landing
                y_home = self.y_landing
                z_home = z_landing
                home_position = "Landing Point"
            if id_shp == -1:  # Take-off Point
                x_home = self.x_takeoff
                y_home = self.y_takeoff
                z_home = self.z_dtm_takeoff_interpolate + takeoff_height
                home_position = "Takeoff Point"

        # paso a Geodetic(deg) del home point
        qgs_point_transform = self.q3_api_op.transform_point_coordinates(x_home,
                                                                         y_home,
                                                                         self.postgis_srid_crs_project_mflip_integer,
                                                                         CONST_MAV_POSTGIS_SRID_CRS_CODE)
        latitude_homing = qgs_point_transform.y()
        longitude_homing = qgs_point_transform.x()

        # Comando SHP
        """
        Label: Homing Position Info
        Description: Linea inicial de script para informar sobre la posición "Home" o
                        punto seguro donde el dron se dirigirá en caso de situación de emergencia, opciones:
                        1.-Punto previsto para el aterrizaje en la ruta programada.
                        2.-Punto previsto de despegue en la ruta programada.
        Changelog:  - 20161215: DONE: Verificado que cmd:16 es sólo informativa.
                      20170111: DONE: Verificado, funciona y usa como Z de referencia la del Landing Point
                                Si Z.landing != Z.takeoff es necesario incluir dicho offset en todos los cmds de altura
                                Para que tenga efecto debe ir en la línea 1 (siguiente a la línea 0 con cmd:16)
        """

        # Initial MAV_CMD_NAV_WAYPOINT cmd:16 
        str_line = ""
        if add_script_comments: # Add comments (Yes or not)
            str_line += "#  Takeoff Point: // X: " + format(self.x_takeoff, '.2f') \
                                       + " // Y: " + format(self.y_takeoff, '.2f') \
                                       + " // H.Takeoff = " + format(self.z_takeoff, '.2f') \
                                       + " / H.dtm = " + format(self.z_dtm_takeoff_interpolate, '.2f') + "\n"
            str_line += "#  Landing Point: // X: " + format(self.x_landing, '.2f') \
                                       + " // Y: " + format(self.y_landing, '.2f') \
                                       + " // H.Landing = " + format(z_landing, '.2f') \
                                       + " / H.dtm = " + format(self.z_dtm_lnd_interpolate, '.2f') + "\n"
            #str_line += "#  Home: " + home_position + "\n"
        str_line += str(line_number) + "\t" + "1" + "\t"
        str_line += MAV_FRAME_GLOBAL + "\t"
        str_line += MAV_CMD_NAV_WAYPOINT + "\t"
        str_line += "0.000000" + "\t"  # Param.#1
        str_line += "0.000000" + "\t"  # Param.#2
        str_line += "0.000000" + "\t"  # Param.#3
        str_line += "0.000000" + "\t"  # Param.#4
        str_line += format(latitude_homing, '.6f') + "\t"
        str_line += format(longitude_homing, '.6f') + "\t"
        str_line += format(z_home, '.6f') + "\t"
        str_line += "1" + "\n"
        file_uav_navigation_script.writelines(str_line)
        line_number = line_number + 1

        # MAV_CMD_DO_SET_HOME - cmd:179
        # 20170125: TODO: Desabilitado hasta modificar para activar solo en caso de HOME diferente a TOF
        str_line = ""
        if (id_lnd != -1 and id_shp == 0):  # Landing point != Takeoff point & SHP = Landing point
            home_height_offset = self.z_takeoff - z_landing
            if add_script_comments: # Add comments (Yes or not)
                str_line += "#  Home: " + home_position + "\n"
            str_line += str(line_number) + "\t" + "0" + "\t"
            # str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
            str_line += MAV_FRAME_GLOBAL + "\t"
            str_line += MAV_CMD_DO_SET_HOME + "\t"
            str_line += "0.000000" + "\t"  # Param.#1 // TODO: verificar si es 0 o 2 (depende de la documentación)
            str_line += "0.000000" + "\t"  # Param.#2
            str_line += "0.000000" + "\t"  # Param.#3
            str_line += "0.000000" + "\t"  # Param.#4
            str_line += format(latitude_homing, '.6f') + "\t"
            str_line += format(longitude_homing, '.6f') + "\t"
            str_line += format(z_home, '.6f') + "\t"  # Param.#7.opc.1
            # str_line += format(self.z_takeoff, '.6f') + "\t"  # Param.#7.opc.2
            str_line += "1" + "\n"
            file_uav_navigation_script.writelines(str_line)
            line_number = line_number + 1

        # Comando GPA
        """
        Label:  General Pos. Accuracy (m) #GPA:
        Description: Parámetro que establece la tolerancia posicional (en metros), para que el dron alcance los Waypoint de la ruta planificada.
        Changelog:  - 20160824: TODO: Sin comando en MAVLink ??? (Diego)
                                      Parametros 2 y 3 del CMD 16 sólo para ala fija
        """
        # float_gpa_value_dialog = self.list_parameter_db_flight_block[33]
        # str_line = CONST_CMD_GPA
        # str_line += "\n"
        # file_uav_navigation_script.writelines(str_line)

        # Comando ERC
        """
        Label: Emergency Radio Control  #ERC
        Description: Parámetro de seguridad que establece la acción a realizar en caso que el dron pierda RC:
            0.- Desciende lentamente hasta llegar al suelo.
            1.- OBSOLETO: Se detiene manteniendo posición y altura, hasta que el nivel de batería sea bajo.
            2.- Continúa la ruta planificada según lo previsto.
            3.- Inicia el procedimiento de vuelta a casa.
            4.- Return following the WP path
        Changelog:  - 20160824: El valor por defecto del Sistema es "3" RTL
        """
        # int_id_erc = self.list_parameter_db_flight_block[28]  # obtiene el valor del diálogo
        # str_line = CONST_CMD_ERC
        # str_line += "\n"
        # file_uav_navigation_script.writelines(str_line)

        # Comando EAL
        """
        Label: Failsafe Low Battery. Low  #FLB
        Description: Establece la acción a realizar en caso de alcanzar nivel de failsafe establecido:
            0.- Desciende lentamente hasta llegar al suelo, permitiendo movimientos posicionales
            2.- Continúa la ruta planificada según lo previsto.
            3.- Inicia el procedimiento de vuelta a casa.
        Changelog:  - 20160824:  El valor por defecto del Sistema es "0"
                      20170111:  El valor por defecto de activación es 21.5V. Se puede anular pasando a alt-Hold
        """
        # int_id_eal = self.list_parameter_db_flight_block[29]  # obtiene el valor del diálogo
        # str_line = CONST_CMD_EAL
        # str_line += "\n"
        # file_uav_navigation_script.writelines(str_line)

        # Comando EGI
        """
        Label: Failsafe GPS Invalid  #FGI
        Description: Parámetro de seguridad que establece la acción a realizar 
                        en caso de pérdida de GPS:
                        0.- Desciende lentamente mientras es arrastrado por el viento hasta llegar al suelo.
                        1.- Mantiene la altitud mientras es arrastrado por el viento.
        Changelog:  - 20160824: El valor por defecto del Sistema es "0"
                      20170111: Se puede anular pasando a alt-Hold
        """
        # int_id_egi = self.list_parameter_db_flight_block[30]
        # str_line = CONST_CMD_EGI
        # str_line += "\n"
        # file_uav_navigation_script.writelines(str_line)

        # Comando SSH
        """
        Label: Setting Secure Height (for Homing)  #SSH
        Description: Parámetro que establece la altura mínima de seguridad en caso de activarse la acción "Homing" 
                        - En caso de activarse el modo HM por debajo de dicha altura.- El dron asciende hasta alcanzarla
                          y entonces inicia la vuelta a casa
                        - En caso de activarse el modo HM por encima de dicha altura.- El dron inicia la vuelta a casa a la altura que tenga.
                        - Sobreescribe el valor por defecto del Sistema hasta el apagado del drone.
        Changelog:  - 20160824:  El valor por defecto del Sistema es entre 30 y 50 m
        """
        # int_id_ssh = self.list_parameter_db_flight_block[32]
        # str_line = CONST_CMD_SSH
        # str_line += "\n"
        # file_uav_navigation_script.writelines(str_line)

        # Comando SVS // ascent_rate / descent_rate
        # Define la velocidad máxima vertical de ascenso y de descenso
        """
        Label:
        Description: En MAVLink afecta sólo a trayectorias verticales ???
                        - Sin comando específico en MAVLnk
                        - Se define dentro de cada comando de cambio de altura CMD_CONDITION_CHANGE_ALT
        Changelog:  - 20160824: TODO: Espécifico para cada comando o para el resto de misión ??
                                      Afecta a la V.vert máxima del sistema en trayectorías diagonales ??
                                      Valores máximos del sistema -1.5/+2.5 ???
                                      Se pueden superar en cambios de altura verticales ???
        """
        # str_line = CMD_SVS_UP
        # str_line += "\n"
        # file_uav_navigation_script.writelines(str_line)

        # str_line = CMD_SVS_DOWN
        # str_line += "\n"
        # file_uav_navigation_script.writelines(str_line)

        total_time = CONST_MAV_CMD_TIME_TO_INITIALIZE_ROUTE

        # COMIENZO DE LA ESCRITURA DEL FICHERO DE TIEMPO ...
        str_title_time_file = "*** KINEMATIC Report ***\n"
        file_uav_navigation_time.write(str_title_time_file)

        file_uav_navigation_time.write("- Time to initialize the route ...................: ")
        file_uav_navigation_time.write(format(CONST_MAV_CMD_TIME_TO_INITIALIZE_ROUTE, '.1f'))
        file_uav_navigation_time.write(" s.\n\n")

        # Comando initial TAKEOFF
        """
        Label: Initial Take-off
        Description: - Comando CMD_NAV_TAKEOFF inicial de referencia hasta una altura de 5 m
                     - Este comando se escribe siempre, indistintamente del tipo de trayectoria seleccionada.
                     - Se ejecuta mediante comando MavLink:22 (param.7:define altura)
                     - Si altura real ya es mayor que la establecida el comando es ignorado y pasa al siguiente
                     - No permite indicar tasa de ascenso, usa por defecto la del sistema
        Changelog:  - 20160824: TODO: Existe el comando 24 CMD_NAV_TAKEOFF_LOCAL que en teoría permite indicar la
                                      tasa de ascenso en el parámetro 3. Poca información al respecto. Verificar.
                      20151215: Actua como comando NAV inicial de referencia para los siguientes "CONDITION" Y "DO". 
                                DONE: CONDITION_CHANGE_ALT (cmd:113) No funciona después de este comando
                      20151230: Ahora se emplea para el ascenso vertical en todos los tipos de trayectoria.
                      20151231: DONE: Ver si hay forma de controlar la velocidad de ascenso con comando mavlink
        """
        if float_was_value_dialog > 0:
            # MAV_CMD_NAV_TAKEOFF - cmd:22
            str_line = ""
            if add_script_comments: # Add comments (Yes or not)
                str_line += "#  Initial Takeoff Ascend: " + format((float_was_value_dialog), '.1f') + " m." \
                                                         + " // X: " + format(self.x_takeoff, '.2f') \
                                                         + " // Y: " + format(self.y_takeoff, '.2f') \
                                                         + " // H: " + format((self.z_takeoff + float_was_value_dialog), '.2f') + "\n"
            str_line += str(line_number) + "\t" + "0" + "\t"
            str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
            str_line += MAV_CMD_NAV_TAKEOFF + "\t"
            str_line += "0.000000" + "\t"  # Param.#1
            str_line += "0.000000" + "\t"  # Param.#2
            str_line += "0.000000" + "\t"  # Param.#3
            str_line += "0.000000" + "\t"  # Param.#4
            str_line += "0.000000" + "\t"  # Param.#5
            str_line += "0.000000" + "\t"  # Param.#6
            str_line += format(float_was_value_dialog + home_height_offset, '.6f') + "\t"
            str_line += "1" + "\n"
            file_uav_navigation_script.writelines(str_line)
            line_number = line_number + 1
            # 20170220: realV_speed = 95% of ascend_speed 
            time_to_was = float_was_value_dialog / (ascend_speed * .95) + 0.5 * (ascend_speed * .95) / acceleration - 0.5 * (ascend_speed * .95) / decceleration

        str_msg_title = "*** PROJECT KINEMATIC DATA ***\n"
        str_msg_cruising_speed = "- Maximum Ground Speed ..........:  " + str(cruising_speed) + " m/s.\n"
        str_msg_ascent_speed = "- Maximum Ascent Speed ..........:  " + str(ascend_speed) + " m/s.\n"
        str_msg_decrease_speed = "- Maximum Descent Speed .........: " + str(decrease_speed) + " m/s.\n"
        str_msg_acceleration = "- Horizontal Acceleration .......:  " + str(acceleration) + " m/s2.\n"
        str_msg_decceleration = "- Horizontal Deceleration .......: " + str(decceleration) + " m/s2.\n"
        str_msg_acceleration_up = "- Ascending Acceleration ........:  " + str(acceleration_Up) + " m/s2.\n"
        str_msg_decceleration_up = "- Ascending Deceleration ........: " + str(decceleration_Up) + " m/s2.\n"
        str_msg_acceleration_down = "- Descending Acceleration .......:  " + str(acceleration_Down) + " m/s2.\n"
        str_msg_decceleration_down = "- Descending Deceleration .......: " + str(decceleration_Down) + " m/s2.\n\n"
        str_msg_was = "- Initial Take-off Height (ITH)....................: " + str(format(float_was_value_dialog , '.2f')) + " m.\n"
        str_msg_varibles_calc_was = str_msg_title + str_msg_cruising_speed + str_msg_ascent_speed + str_msg_decrease_speed \
                                    + str_msg_acceleration + str_msg_decceleration \
                                    + str_msg_acceleration_up + str_msg_decceleration_up \
                                    + str_msg_acceleration_down + str_msg_decceleration_down + str_msg_was 
        file_uav_navigation_time.writelines(str_msg_varibles_calc_was)
        file_uav_navigation_time.write("- Time to reach the initial height of the route ...: ")
        file_uav_navigation_time.write(format(time_to_was, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
        total_time += time_to_was
        file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
        file_uav_navigation_time.write("s.\n")

        ascent_gain.append(["ITH", float_was_value_dialog])
        cumulative_total_ascent += float_was_value_dialog

        """
        Label: GIMBAL attitude
        Description:    - Comandos que controla los ángulos del gimbal        
                        - Ángulo Pitch: Rotación sobre eje X-gimbal. Dominio [-20,+70] CCW, en radianes.
                        - Negativo: vista hacia atrás. Positivo: vista hacia adelante. Nadir=0
                        - Ángulo Roll: Rotación sobre eje Y-gimbal. Dominio [-35,+35] CCW, en radianes.
                        - Negativo: vista hacia la derecha. Positivo: vista hacia la izquierda. Nadir=0
                        - En MAVLink mediante comando 205 CMD_DO_MOUNT_CONTROL (param.1:pitch, param.2:roll, param.3:yaw)
                          Param.#7 especifica el MOUNT_MODE
        """
        # 20180329. Modificados criterios para adaptarse al formtato de cambio de base C.PATB
        dif_omega_offsetomega = float_sensor_attitude_omega_deg - float_mount_attitude_offset_omega_deg  # rango (+70,-20). Nadir = 0
        # Revisar fórmula phi: Criterio de signos izquierda o derecha. 
        dif_phi_offsetphi = float_sensor_attitude_phi_deg - float_mount_attitude_offset_phi_deg  # rango entre +25 y -25. Nadir = 0
        dif_kappa_offsetkappa = 0 # En caso de gimbal de tres ejes habría que incluir fórmula.

        str_line = ""
        if add_script_comments: # Add comments (Yes or not)
            str_line += "#  Mount Control: " + " // Pitch: " + format(float_sensor_attitude_omega_deg, '.3f') \
                                            + " // Roll: " + format(float_sensor_attitude_phi_deg, '.3f') \
                                            + " // Yaw: " + format(0, '.3f') + "\n"
        str_line += str(line_number) + "\t" + "0" + "\t"
        str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
        str_line += MAV_CMD_DO_MOUNT_CONTROL + "\t"
        str_line += format(dif_omega_offsetomega, '.6f') + "\t" # Param.#1
        str_line += format(dif_phi_offsetphi, '.6f') + "\t" # Param.#2
        str_line += format(dif_kappa_offsetkappa, '.6f') + "\t"  # Param.#3 // 2axis gimbal -> kappa=0
        str_line += "0.000000" + "\t"  # Param.#4
        str_line += "0.000000" + "\t"  # Param.#5
        str_line += "0.000000" + "\t"  # Param.#6
        str_line += MAV_MOUNT_MODE + "\t" # Param.#7 // MAV_MOUNT_MODE_RC_TARGETING = 3 ??
        str_line += "1" + "\n"
        file_uav_navigation_script.writelines(str_line)
        line_number = line_number + 1

        # Sube a la altura del primer punto
        dv_from_was2FirstWP = first_height_over_takeoff - float_was_value_dialog
        inc_e_tof2wp1 = self.xLs[0] - self.x_takeoff
        inc_n_tof2wp1 = self.yLs[0] - self.y_takeoff
        dist2d_utm_from_was2FirstWP = sqrt(pow(inc_e_tof2wp1, 2.0) + pow(inc_n_tof2wp1, 2.0))
        dist2d_from_was2FirstWP = distances[0]
        height_over_takeoff_last = first_height_over_takeoff
        minimum_time_btw_shots = 1.2 # default 1.2. PASAR a Config.sys.- Tiempo mínimo necesario para la toma y archivo de imagen entre WPs

        # Establece condiciones para comandos iniciales en caso de bajas trayectorias al primer WP
        if (dv_from_was2FirstWP >= 0 and first_height_over_takeoff >= minimal_safe_hTOF):
            low_initial_trajectory = False
        else:
            low_initial_trajectory = True
            # conforma msg emergente de Alerta por baja trayectoria inicial
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("ALERT by Low Initial Trajectory to WP 1_1 !!          ")
            str_msg_informative_text = ""
            if dv_from_was2FirstWP < 0:
                str_msg_informative_text += "WP 1_1 Height is " + format(abs(dv_from_was2FirstWP), '.2f')
                str_msg_informative_text += " m. below of WAS Height" + "\n"
            if first_height_over_takeoff < minimal_safe_hTOF:
                str_msg_informative_text += "WP 1_1 Height is " + format(first_height_over_takeoff, '.2f')
                str_msg_informative_text += " m. (relative to Takeoff)" + "\n"
            if float_was_value_dialog < minimal_safe_hTOF: ### alerta de bajo WAS para low initial trajectory
                str_msg_informative_text += "initial WAS Height is too Low (" + format(float_was_value_dialog, '.1f')
                str_msg_informative_text += " m.)" + "\n"
            str_msg_informative_text += "\n" + "Check the mission's viability !!" + "\n"
            #str_msg_informative_text += "\n"
            #str_msg_informative_text += "Ignore and continue without changes?" + "\n"
            #str_msg_informative_text += "or..., Abort and change parameters?"
            msg.setInformativeText(str_msg_informative_text)
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText("")
            msg.setStandardButtons(QMessageBox.Ok)
            #msg.setStandardButtons(QMessageBox.Ignore | QMessageBox.Abort)
            #msg.setDefaultButton(QMessageBox.Abort);
            button_answer = msg.exec_()

        """
        Label: initial_Hspeed
        Description:    - Establece la velocidad horizontal para alcanzar el WP 1º.
                        - Genera un comando 178 CMD_DO_CHANGE_SPEED
                        - Tiene en cuenta las limitaciones fisicas de navegación en cuanto a Vertical Speed, aceleraciones y deceleraciones
                          desde el TOF+ITH point, sobre todo en caso de trajectorias diagonales iniciales id_trajectory 1 y 5
        Changelog:      20150521 - Añadido por Carlos. Se establece el concepto "initial_Hspeed"
                        20150704 - Modificado por Carlos. Se modifican fórmulas para adaptar a las distintas trayectorias
                        20150722 - Se revisa la formulación incluyendo cinemática más rigurosa.
                        20160824 - En MAVLink no se puede modificar la velocidad vertical en trayectorias diagonales
        """
        # Cálculo de Initial_Hspeed & Initial_Vspeed
        # /// CINEMATICA VERTICAL ///
        vertical_angle = (verticals_polar[0] * 180.0 / CONST_PI) - 90 # pendiente inicial en deg
        if dv_from_was2FirstWP >= 0:
            acceleration_V = acceleration_Up
            decceleration_V = decceleration_Up
            # 20190116: Vspeed_UP_MaxValue basado basado en curva asintótica de análisis de Log
            Vspeed_logValue = 2 * ascend_speed * atan(vertical_angle / 21.5) / CONST_PI
            # coeficiente cuadrático inversamente proporcional a la pendiente del tramo. Máx 8%(UP)
            k_increasing = 1 + (8.0 * (1 - (vertical_angle / 90) ** 0.2)) / 100
            # Vspeed_Down_Max_Value
            Vspeed_safeValue = Vspeed_logValue * k_increasing
        else: # dv_from_was2FirstWP < 0:
            acceleration_V = acceleration_Down
            decceleration_V = decceleration_Down
            # 20190116: Vspeed_Down_Log_Value basado en curva asintótica de análisis de Log
            Vspeed_logValue = 2 * decrease_speed * atan(vertical_angle / (12.5 + abs(vertical_angle) / 5)) / CONST_PI
            # coeficiente cuadrático inversamente proporcional a la pendiente del tramo. Máx 8%(Down)
            k_increasing = 1 + (8.0 * (1 - (abs(vertical_angle) / 90) ** 0.2)) / 100
            # Vspeed_Down_Max_Value
            Vspeed_safeValue = Vspeed_logValue * k_increasing

        # Cálculo de parámetros máximos con acceleración continua
        maximum_Vspeed_dv1_from_was2FirstWP = sqrt(2 * abs(dv_from_was2FirstWP) * acceleration_V * decceleration_V  / (decceleration_V - acceleration_V))
        maximum_Vspeed = maximum_Vspeed_dv1_from_was2FirstWP
        maximum_initial_Vspeed = maximum_Vspeed

        # /// CINEMATICA HORIZONTAL ///
        maximum_Hspeed_b1_from_was2FirstWP = sqrt(2 * dist2d_from_was2FirstWP * acceleration * decceleration  / (decceleration - acceleration))
        maximum_Hspeed = maximum_Hspeed_b1_from_was2FirstWP

        # else:  # Trayectoria diagonal SHS y SVS relacionadas por la pendiente.
        # /// CINEMATICA COMBINADA (HORIZ + VERT)
        Vspeed_from_Hspeed = maximum_Hspeed * abs(dv_from_was2FirstWP) / dist2d_from_was2FirstWP
        maximum_Hspeed_base = maximum_Hspeed
        if maximum_Vspeed_dv1_from_was2FirstWP > Vspeed_safeValue:
            maximum_Vspeed = Vspeed_safeValue
        if Vspeed_from_Hspeed > maximum_Vspeed:
            maximum_Hspeed_base = maximum_Vspeed / (abs(dv_from_was2FirstWP) / dist2d_from_was2FirstWP)
        maximum_initial_Hspeed = maximum_Hspeed_base * 0.96 # 20170220. Vr = 96% Vt

        # Velocidad Horizontal del vector inicial hacia el primer WP.- para asignar a SHS
        initial_Hspeed = cruising_speed * 0.96 # 20170220. Vr = 96% Vt
        if (cruising_speed * 0.96) > maximum_initial_Hspeed:
            initial_Hspeed = maximum_initial_Hspeed

        # Velocidad Vertical del vector inicial.- para imprimir en fichero de tiempo
        if dv_from_was2FirstWP >= 0: # desnivel positivo
            initial_Vspeed = ascend_speed * 0.95 # 20170220. Vr = 95% Vt
            if ((ascend_speed * 0.95) > maximum_initial_Vspeed):
                initial_Vspeed = maximum_initial_Vspeed
        else: # desnivel negativo
            initial_Vspeed = decrease_speed * 0.95 # 20170220. Vr = 95% Vt
            if ((abs(decrease_speed) * 0.95) > maximum_initial_Vspeed):
                initial_Vspeed = - 1 * maximum_initial_Vspeed
        # else:  # En trayectorias diagonales (tipos 1 ,2(n) y 5) en vector inicial (depende de initial_Hspeed)
        Vspeed_from_initial_Hspeed = initial_Hspeed * dv_from_was2FirstWP / dist2d_from_was2FirstWP
        maximum_Vspeed_initial_base = Vspeed_from_initial_Hspeed

        # vertical_angle_last = verticals_polar[0] * 180.0 / CONST_PI # antes era -999
        inc_h_last = dv_from_was2FirstWP

        # Escribe Comando 178 CMD_DO_CHANGE_SPEED .- Velocidad inicial hasta WP 1º
        str_line = ""
        if add_script_comments: # Add comments (Yes or not)
            str_line += "#  Mission cruising Speed: " + format(cruising_speed, '.1f') + " m/s" + "\n"
        str_line += str(line_number) + "\t" + "0" + "\t"
        str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
        str_line += MAV_CMD_DO_CHANGE_SPEED + "\t"
        str_line += "1.000000" + "\t" # Param.#1 (ignored) // Airspeed:0 / Groundspeed:1
        str_line += format(cruising_speed, '.6f') + "\t" # Param.#2
        str_line += "0.000000" + "\t"  # Param.#3
        str_line += "0.000000" + "\t"  # Param.#4
        str_line += "0.000000" + "\t"  # Param.#5
        str_line += "0.000000" + "\t"  # Param.#6
        str_line += "0.000000" + "\t"  # Param.#7
        str_line += "1" + "\n"
        file_uav_navigation_script.writelines(str_line)
        line_number = line_number + 1

        file_uav_navigation_time.write("+ Info vector:\n")
        file_uav_navigation_time.write("  - Distance (2D) to the first waypoint............: ")
        file_uav_navigation_time.write(format(distances[0], '.2f'))
        file_uav_navigation_time.write(" m.\n")

        file_uav_navigation_time.write("  - Increasing in height to the first waypoint.....: ")
        file_uav_navigation_time.write(format(dv_from_was2FirstWP, '.2f'))
        file_uav_navigation_time.write(" m.\n")

        file_uav_navigation_time.write("  - Slope in degrees for the first vector .........: ")
        file_uav_navigation_time.write(format(vertical_angle, '.1f'))
        file_uav_navigation_time.write(" deg.\n")

        if dv_from_was2FirstWP >= 0:
            ascent_gain.append(["ITH_1", dv_from_was2FirstWP])
            cumulative_total_ascent += dv_from_was2FirstWP
        else:
            descent_gain.append(["ITH_1", dv_from_was2FirstWP])
            cumulative_total_descent += dv_from_was2FirstWP
        """
        Carlos 20160704.
        Función que evita que haya más de 300 metros entre el punto de despegue y el primer waypoint de la pasada
        En tales casos insertará un WP en dicha trayectoria a una distancia de 60 metros del punto de despegue seleccionado
        Dicho punto pertenecerá a la trayectoria original e irá precedido de un comando NBK.
        Con ello no se modificará
        Changelog:      20161230 - TODO: Verificar si esto tiene sentido en APM
        """
        if distances[0] > 300: # Advertencia de seguridad por WP.1º demasiado lejos
            # conforma msg emergente
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("Long distance from Take-off point to Waypoint 1 !!          ")
            str_msg_informative_text = "Distance = " + format(distances[0], '.1f') + " m.\n"
            msg.setInformativeText(str_msg_informative_text)
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText("")
            msg.exec_()

        file_uav_navigation_time.write("  - Maximum Ground Speed for the initial vector ...: ")
        file_uav_navigation_time.write(format(initial_Hspeed, '.2f'))
        file_uav_navigation_time.write(" m/s.\n")

        file_uav_navigation_time.write("  - Vertical Speed for the first vector............: ")
        file_uav_navigation_time.write(format(maximum_Vspeed_initial_base, '.2f'))
        file_uav_navigation_time.write(" m/s.\n")

        time_dist2d_from_was2FirstWP = dist2d_from_was2FirstWP / initial_Hspeed + 0.5 * initial_Hspeed / acceleration - 0.5 * initial_Hspeed / decceleration
        file_uav_navigation_time.write("  - Time to reach the first waypoint ..............: ")
        file_uav_navigation_time.write(format(time_dist2d_from_was2FirstWP, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
        total_time += time_dist2d_from_was2FirstWP
        file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
        file_uav_navigation_time.write("s.\n")


        """
        Realizado por Carlos 20150704.
        Homogeiniza en una misma variable la lista de pasadas y azimuths,
        ya que los self.lst_jogs procedentes de la planificación líneal y zonal no contienen el mismo formato de información
        Con esto se elimina mucho código en el proceso posterior de generación del script de navegación
        """
        if self.str_mission_type == 'lineal':
            lst_strip = self.lst_jogs

        if self.str_mission_type == 'zonal':  # Un único yaw (YSF) para todo el vuelo
            lst_strip = []
            lst_unique_jog_zonal = self.lst_jogs[0]
            azimuth_current_strip_rad = lst_unique_jog_zonal[1]
            key_number = 0
            strip_last_point = 0
            for key in self.uav_images_by_strip.keys():
                key_number = key_number + 1
                images_in_strip = self.uav_images_by_strip[str(key_number)]
                strip_last_point += len(images_in_strip)
                lst_strip_point_azimuth = [strip_last_point,azimuth_current_strip_rad]
                lst_strip.append(lst_strip_point_azimuth)
        number_of_strips = list(self.uav_images_by_strip.keys())
        number_of_strip = 0
        strip_number2print = 1
        n_point_strip_order = 0
        strip_made_length = 0
        mission_made_lenght = dist2d_from_was2FirstWP
        strip_length = 0
        average_Hspeed_by_nbk_base = [] # contenedor para velocidad horizontal inicial de cada base stereo
        strip_Hspeed_Last = 0 # 20181224: Velocidad H inicial de primera base stereo
        strip_Vspeed_Last = 0 # 20181224: Velocidad V inicial de primera base stereo
        slope_change_factor = -9999 # 20190104: Asigna valor absurdo inicial
        images_in_strip = self.uav_images_by_strip[str(strip_number2print)]
        for i in range(len(images_in_strip) - 1):  # 20181220: Calcula longitud segmento/pasada strip = 1
            strip_length += distances[i + 1]
        strip_remaining_length = strip_length  # queda toda la pasada por hacer (strip = 1)
        lst_current_strip = lst_strip[number_of_strip]
        number_point_next_strip = lst_current_strip[0]
        time_to_image_capture = waiting_time_by_image  # waiting time_by_image es el valor de shot_interval del diálogo
        braking_for_shoot = " (STOP for shooting)" # valor por defecto para el primer WP
        yaw_rotation_to_camera_orientation_deg = 0.0  # montaje de cámara tal que en la dirección de la pasada avanzan las filas

        # Factor de reducción de distancia en función de la velocidad del comando CAM_TRIGG_DIST
        distance_factor_reduction = 1
        # TODO: Afinar factor chequeando más vuelos reales
        if cruising_speed > 5:
            distance_factor_reduction = 1 - ((cruising_speed - 5) / 150)

        # 20181227: Define la máxima velocidad final de llegada al último WP de pasada/segmento
        final_strip_Hspeed = 0  # Si tiempo de parada > 0 s.
        if waiting_time_by_image == 0:  # si tiempo de parada es = 0 s.
            final_strip_Hspeed = 5.5  # Máximum Allowed Speed 5.5 m/s en quiebros "No brake".

        # Inicializa contadores para comando YSF y NBK para caso del vuelo lineal y zonal
        write_ysf_comand = True
        write_nbk_comand = False
        previous_ysf_command = False
        control_end_strip = False
        control_slope_break_point = False
        control_begin_strip = True
        control_low_distance = False

        # ***********************************
        # ***  MAIN LOOP: Strip Commands  ***
        # ***********************************
        for n_point in range(number_of_points):
            lat_ct = latitudes[n_point] * 180 / CONST_PI #TODO: Verificar con la función transform_point_coordinates
            lon_ct = longitudes[n_point] * 180 / CONST_PI #TODO: Verificar con la función transform_point_coordinates
            dh_ct = self.zLs[n_point] - self.z_takeoff # Para MAVLink se trabaja en ortométricas.

            # YSF Command - Vuelos Zonal y Lineal
            """
            Label: Yaw del dron
            Description:    - Comando que controla el Yaw del dron y, por tanto, el kappa del sensor.
                            - En vuelos lineales el YSF siempre debe incluirse delante del Primer WP de cada pasada
                              (es decir antes de cada quiebro).
                              El valor YSF= (azimut de cada pasada + Mount attitude offset (Kappa) + yaw_rotation_to_camera_orientation) x 10
            """
            if write_ysf_comand:
                # Código común para tipo de vuelo zonal y líneal (antes era independiente para cada caso)
                lst_current_strip = lst_strip[number_of_strip]
                azimuth_current_strip_rad = lst_current_strip[1]
                azimuth_current_strip_deg = azimuth_current_strip_rad * 180.0 / CONST_PI

                # Calculating YSF value
                # TODO: Recuperar Yaws 0, 90, 180 y -90 deg
                float_mount_attitude_kappa_deg = self.list_parameter_db_flight_block[43]
                # Obsoleto. 90 Deg.- x_forward direction
                # if (self.angle_advanced_columns_to_axis_flight == 0 or self.angle_advanced_columns_to_axis_flight == CONST_PI):
                #     yaw_rotation_to_camera_orientation_deg = 90.0
                if self.str_mission_type == 'zonal' and not number_of_strip == 0:
                    yaw_rotation_to_camera_orientation_deg += 180.0
                    if yaw_rotation_to_camera_orientation_deg >= 360:
                        yaw_rotation_to_camera_orientation_deg -= 360

                acimut_ysf_deg = azimuth_current_strip_deg + float_mount_attitude_kappa_deg + yaw_rotation_to_camera_orientation_deg
            
                azimuth_in_dron_domain = acimut_ysf_deg
                if (azimuth_in_dron_domain > 360.0):
                    azimuth_in_dron_domain = azimuth_in_dron_domain - 360.0
                if (azimuth_in_dron_domain > 180.0):
                    azimuth_in_dron_domain = azimuth_in_dron_domain - 360.0
            
                # Calculating the necessary Time for reaching the strip_Yaw value
                """
                Margen de tiempo para alcanzar el yaw de las pasadas
                En el caso del primer YSF, se calcula el valor máximo para 180º (yaw despegue desconocido)
                Los YSF
                """
                if number_of_strip > 0:
                    yaw_rotate = fabs(azimuth_in_dron_domain_last - azimuth_in_dron_domain)
                if number_of_strip == 0:
                    yaw_rotate = 180
                time_to_yaw_rotate = yaw_rotate / CONST_MAV_CMD_SYS_DEFAULT_VALUE
                if time_to_yaw_rotate < 3:
                    time_to_yaw_rotate = 3
                    if time_to_yaw_rotate < waiting_time_by_image:
                        time_to_yaw_rotate = waiting_time_by_image

                # Gestiona la cota del primer WP en caso de trayectoría inicial a baja altura. 
                z_initial_WP = self.zLs[n_point]
                if (inc_h_last == 0):  # WAS checked o trayectorias diagonales sin cambio de cota)
                    if low_initial_trajectory:
                        z_initial_WP = self.z_takeoff + float_was_value_dialog
                        low_initial_trajectory = False

                # WP inicial de pasada para ejecutar YAW
                # MAVLink MAV_CMD_NAV_WAYPOINT cmd:16 
                if (n_point == 0):
                    str_line = ""
                    if add_script_comments: # Add comments (Yes or not)
                        str_line += "#  Strip No." + str(number_of_strip + 1) + " starts" \
                                                               + " // X: " + format(self.xLs[n_point], '.2f') \
                                                               + " // Y: " + format(self.yLs[n_point], '.2f') \
                                                               + " // H: " + format(z_initial_WP, '.2f') + "\n"
                    str_line += str(line_number) + "\t" + "0" + "\t"
                    str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                    str_line += MAV_CMD_NAV_WAYPOINT + "\t"
                    str_line += "0.000000" + "\t"  # Param.#1
                    str_line += "0.000000" + "\t"  # Param.#2
                    str_line += "0.000000" + "\t"  # Param.#3
                    str_line += "0.000000" + "\t"  # Param.#4
                    str_line += format(lat_ct, '.6f') + "\t"
                    str_line += format(lon_ct, '.6f') + "\t"
                    str_line += format(z_initial_WP + home_height_offset - self.z_takeoff, '.6f') + "\t"
                    str_line += "1" + "\n"
                    file_uav_navigation_script.writelines(str_line)
                    line_number = line_number + 1

                    time_to_image_capture = time_to_yaw_rotate

                    file_uav_navigation_time.write("  - Time to reach the kappa angle .................: ")
                    file_uav_navigation_time.write(format(time_to_yaw_rotate, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
                    total_time += time_to_yaw_rotate
                    file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
                    file_uav_navigation_time.write("s.\n")

                # Writing YSF.- to reach the strip Yaw
                # En MAVLink MAV_CMD_CONDITION_YAW cmd:115_Param#1 
                # 20170411: Yaw al inicio de cada strip en "zonal" y de cada segmento en "lineal"
                if waiting_time_by_image > 0 or n_point == 0:
                    str_line = ""
                    if add_script_comments: # Add comments (Yes or not)
                        str_line += "#  Strip YAW value: " + format(azimuth_in_dron_domain, '.2f') + "\n"
                    str_line += str(line_number) + "\t" + "0" + "\t"
                    str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                    str_line += MAV_CMD_CONDITION_YAW + "\t"
                    str_line += format(azimuth_in_dron_domain, '.4f') + "\t"  # Param.#1: Set yaw angle (deg)
                    str_line += "0.000000" + "\t"  # Param.#2: Yaw speed (ignored)??
                    str_line += "0.000000" + "\t"  # Param.#3
                    str_line += "0.000000" + "\t"  # Param.#4: Yaw angle type: 0.absolute, 1.relative
                    str_line += "0.000000" + "\t"  # Param.#5
                    str_line += "0.000000" + "\t"  # Param.#6
                    str_line += "0.000000" + "\t"  # Param.#7
                    str_line += "1" + "\n"
                    file_uav_navigation_script.writelines(str_line)
                    line_number = line_number + 1

                azimuth_in_dron_domain_last = azimuth_in_dron_domain
                write_ysf_comand = False
                write_nbk_comand = False # Desactiva No Brake delante del primer WP de una pasada
                if waiting_time_by_image == 0 and n_point > 0:  # Si Hold time para disparo = 0, entonces
                    write_nbk_comand = True   # activa NoBrake delante de primer WP de pasada
                previous_ysf_command = True
            else:
                write_nbk_comand = True
                previous_ysf_command = False

            # Determinación de cambio de pasada
            if (n_point + 1 == number_point_next_strip):  # hemos llegado al último punto del segmento
                if (n_point < (number_of_points - 1)):
                    number_of_strip = number_of_strip + 1
                    lst_current_strip = lst_strip[number_of_strip]
                    number_point_next_strip = lst_current_strip[0]
                    write_ysf_comand = True # Activa la escritura de comando YSF al inicio de cada pasada.
                    write_nbk_comand = False  # Desactiva la escritura de NBK en último punto de pasada
                    if waiting_time_by_image == 0:  # Si Hold time para disparo = 0, entonces
                        write_nbk_comand = True  # activa NoBrake delante de primer WP de pasada

            # Determinación condición final para permitir la escritura de comando NBK
            # 20181228: gestión NBK en último punto de la última pasada y cuando nbk = 0 (Stop in All WPs)
            if n_point == number_of_points - 1 or id_nbk == 0:
                write_nbk_comand = False
                #if waiting_time_by_image < minimum_time_btw_shots and id_nbk == 1:
                # 20181228: Asigna 1.2 segundos de parada en el último WP de misión
                # waiting_time_by_image = minimum_time_btw_shots

            # Determinación de cambio de pasada para impresión en ficheros de tiempos y script de navegación
            if (previous_ysf_command and n_point > 0): # Inicia el contador de Nº de punto en pasada
                # strip_number2print = strip_number2print + 1
                strip_number2print = int(number_of_strips[number_of_strip])
                n_point_strip_order = 0
                # Se ponen a 0 las variables de longitud total de pasada y la ejecutada
                strip_length = 0
                strip_made_length = 0
                images_in_strip = self.uav_images_by_strip[str(strip_number2print)]
                for i in range(len(images_in_strip)): # 20181220: Calcula longitud segmento/pasada strip > 1
                    strip_length += distances[i + n_point]
                strip_remaining_length = strip_length # queda toda la pasada por hacer (strip>1)
                if (number_of_strip == len(lst_strip)-1):
                    final_strip_Hspeed = 0  # 20181228: Siempre hay parada al final de la última pasada

            n_point_in_strip = images_in_strip[n_point_strip_order]
            n_point_strip_order = n_point_strip_order + 1
            control_end_strip = False
            control_slope_break_point = False
            if n_point_in_strip == images_in_strip[len(images_in_strip) - 1]:
                control_end_strip = True  # Control de punto final de pasada

            control_begin_strip = True
            if n_point_in_strip > images_in_strip[0]: # 20170623: corrige el BUG, cuando id del primer punto de pasada > 1
                control_begin_strip = False

            """
            Label: Calculos Cinemáticos
            Description:    - Calculo Velocidad Horizontal, Vertical y Tiempos de los distintos eventos en PASADAS y Segmentos,
                            - Tiene en cuenta las limitaciones fisicas de navegación en cuanto a Vertical Speed, aceleraciones, deceleraciones, etc
                            - Tiene en cuenta las diferentes estrategias de misión definidas por el usuario
            Changelog:      20150506 - Añadido por Carlos. Se establece el concepto "strip_Hspeed"
                            20150704 - Carlos. Se modifican fórmulas para adaptar a los distintos vectores entre WP
                            20150709 - Carlos. Se añaden fórmulas rigurosas de cinemática para trayectorias diagonales
                            20190108 - Mejora el cálculo cinemático Vertical. Gestiona la pasada en su conjunto
            """
            # Calculo de la velocidad de Pasada (velocidad de vector entre WPs)
            if (n_point > 0):
                # Vspeed_safeValue = 3 # default = 2. Solo se tiene en cuenta en trayectorias diagonales
                inc_e_base = self.xLs[n_point - 1] - self.xLs[n_point]
                inc_n_base = self.yLs[n_point - 1] - self.yLs[n_point]
                dist2d_base = distances[n_point]
                dist2d_base_check = sqrt(pow(inc_e_base, 2.0) + pow(inc_n_base, 2.0))
                inc_h_base = self.zLs[n_point] - self.zLs[n_point - 1]
                inc_h_last = inc_h_base

                # /// CINEMATICA VERTICAL ///
                # 20190116. Mejora el cálculo cinemático Vertical. Gestiona la pasada en su conjunto
                vertical_angle = (verticals_polar[n_point] * 180.0 / CONST_PI) - 90 # pendiente base actual en deg
                if inc_h_base >= 0:
                    acceleration_V = acceleration_Up
                    decceleration_V = decceleration_Up
                    # 20190116: Vspeed_UP_MaxValue basado basado en curva asintótica de análisis de Log
                    Vspeed_logValue = 2 * ascend_speed * atan(vertical_angle / 21.5) / CONST_PI
                    # coeficiente cuadrático inversamente proporcional a la pendiente del tramo. Máx 8%(UP)
                    k_increasing = 1 + (8.0 * (1 - (vertical_angle / 90) ** 0.2)) / 100
                    # Vspeed_Down_Max_Value
                    Vspeed_safeValue = Vspeed_logValue * k_increasing
                else: # inc_h_base < 0:
                    acceleration_V = acceleration_Down
                    decceleration_V = decceleration_Down
                    # 20190116: Vspeed_Down_Log_Value basado en curva asintótica de análisis de Log
                    Vspeed_logValue = 2 * decrease_speed * atan(vertical_angle / (12.0 + abs(vertical_angle) / 4)) / CONST_PI
                    # coeficiente cuadrático inversamente proporcional a la pendiente del tramo. Máx 8%(Down)
                    k_increasing = 1 + (8.0 * (1 - (abs(vertical_angle) / 90) ** 0.2)) / 100
                    # Vspeed_Down_Max_Value
                    Vspeed_safeValue = Vspeed_logValue * k_increasing

                if abs(vertical_angle) < 1.2:  # < 1ºdeg => se eliminan las restricciones por pendiente de vector
                    Vspeed_safeValue = cruising_speed * abs(inc_h_base) / dist2d_base

                if id_nbk == 1: # No brake condition: Enabled
                    if write_nbk_comand: # En caso de WPs SIN PARADA
                        # 20181227: incluye la gestión de llegada a final de tramos de pendiente continua
                        # Cálculo de ángulo vertical entre vectores en "deg"
                        inc_h_next = self.zLs[n_point + 1] - self.zLs[n_point]
                        vertical_angle_next = (verticals_polar[n_point + 1] * 180.0 / CONST_PI) - 90  # 0deg -> horizontal
                        vertical_angle_change = vertical_angle_next - vertical_angle # En grados Sexa.
                        if abs(vertical_angle_change) > 0.001:  # Base siguiente con la misma pendiente
                            control_slope_break_point = True
                        # else:
                        #    control_slope_break_point = True
                        if vertical_angle_next != 0:
                            slope_change_factor = vertical_angle / vertical_angle_next
                        else:
                            slope_change_factor = vertical_angle
                        if slope_change_factor >= 0:  # Base siguiente con el mismo signo de pendiente
                            maximum_Vspeed_nbk_base = sqrt(strip_Vspeed_Last ** 2 + 2 * acceleration_V * abs(inc_h_base))
                        else:# Base siguiente con distinta pendiente y distinto signo => final_Vspeed = 0
                            maximum_Vspeed_nbk_base = sqrt((decceleration_V * strip_Vspeed_Last ** 2 + 2 * acceleration_V * decceleration_V * abs(inc_h_base)) \
                                                           / (decceleration_V - acceleration_V))
                    else: # 20190104: Inicio y Final de segmentos "CON PARADA".
                        if control_end_strip: # final pasada/segmento CON parada. InitialVspeed >= 0 & FinalVspeed = 0
                            if slope_change_factor < 0: # Entonces Ha cambiado el sentido de pte% entre la base anterior y la actual
                                strip_Vspeed_Last = 0 # => InitialVspeed = 0
                            maximum_Vspeed_nbk_base = sqrt((decceleration_V * strip_Vspeed_Last ** 2 + 2 * acceleration_V * decceleration_V * abs(inc_h_base)) \
                                                           / (decceleration_V - acceleration_V))
                        else: # 20181231: write_nbk_command = False AND control_begin_strip = True  TODO: Verificar toda la casuística
                            # Este caso se puede dar:
                            # En Zonal:  Siempre, ya que siempre para al inicio de la pasada
                            # En Lineal: Si waiting_time_by_image > 0; hay siempre Parada al inicio del siguiente segmento ???
                            # En ambos casos Vo = Vf = 0
                            maximum_Vspeed_inc_h1 = sqrt(2 * abs(inc_h_base) * acceleration_V * decceleration_V / (decceleration_V - acceleration_V))
                            maximum_Vspeed_nbk_base = maximum_Vspeed_inc_h1
                else: # id_nbk = 0: Stop in all WPs. Solo con id_trajectory_type = 1
                    maximum_Vspeed_inc_h1 = sqrt(2 * abs(inc_h_base) * acceleration_V * decceleration_V / (decceleration_V - acceleration_V))
                    maximum_Vspeed_nbk_base = maximum_Vspeed_inc_h1

                maximum_Vspeed = maximum_Vspeed_nbk_base
                
                # /// CINEMATICA HORIZONTAL ///
                # 20181227. Mejora el cálculo cinemático. Gestiona la pasada en su conjunto
                if id_nbk == 1: # No brake condition: Enabled
                    if write_nbk_comand: # En caso de WPs SIN PARADA
                        # 20181227: incluye la gestión de llegada al final de cada pasada
                        slow_down_minimum_distance = (strip_Hspeed_Last ** 2 - final_strip_Hspeed ** 2 + 2 * acceleration * strip_remaining_length) \
                                                     / (2 * (acceleration - decceleration))
                        if (strip_remaining_length - dist2d_base) > slow_down_minimum_distance: # Sin límites por cercanía de fin de pasada/segmento
                            maximum_Hspeed_nbk_base = sqrt(strip_Hspeed_Last ** 2 + 2 * acceleration * dist2d_base)
                            final_Hspeed_nbk_base = maximum_Hspeed_nbk_base
                            if control_end_strip: # siguiente punto es fin de segmento en misión lineal "No brake"
                                final_Hspeed_nbk_base = final_strip_Hspeed  # 20181224: Final de segmento "No brake". FinalSpeed = 5m/s
                                maximum_Hspeed_nbk_base = sqrt((decceleration * strip_Hspeed_Last ** 2 \
                                                                - acceleration * final_strip_Hspeed  ** 2 \
                                                                + 2 * acceleration * decceleration * dist2d_base) \
                                                               / (decceleration - acceleration))
                        else: # Frenado necesario por cercanía de fin de pasada/segmento
                            maximum_Hspeed_nbk_base = sqrt(final_strip_Hspeed ** 2 - 2 * decceleration * (strip_remaining_length - dist2d_base))
                            final_Hspeed_nbk_base = maximum_Hspeed_nbk_base
                    else: # 20190104: Inicio y Final de segmentos "CON PARADA".
                        if control_end_strip: # InitialHspeed > 0 & FinalHspeed = 0
                            final_Hspeed_nbk_base = final_strip_Hspeed  # 20190104: Final de segmento "Brake". FinalSpeed = 0 m/s
                            maximum_Hspeed_nbk_base = sqrt((decceleration * strip_Hspeed_Last ** 2 + 2 * acceleration * decceleration * dist2d_base) \
                                                           / (decceleration - acceleration))
                        else: # 20181231: write_nbk_command = False AND control_begin_strip = True  TODO: Verificar toda la casuística
                            # Este caso se puede dar:
                            # En Zonal:  Siempre, ya que siempre para al inicio de siguiente pasada
                            # En Lineal: Si waiting_time_by_image > 0; hay siempre Parada al inicio del siguiente segmento ???
                            # En ambos casos Vo = Vf = 0
                            maximum_Hspeed_dist_b1 = sqrt(2 * dist2d_base * acceleration * decceleration / (decceleration - acceleration))
                            maximum_Hspeed_nbk_base = maximum_Hspeed_dist_b1
                            final_Hspeed_nbk_base = final_strip_Hspeed  # 20190104: Final de segmento "Brake". FinalSpeed = 0 m/s
                else: # id_nbk = 0: Stop in all WPs. Solo con id_trajectory_type = 1
                    maximum_Hspeed_dist_b1 = sqrt(2 * dist2d_base * acceleration * decceleration  / (decceleration - acceleration))
                    maximum_Hspeed_nbk_base = maximum_Hspeed_dist_b1
                    final_Hspeed_nbk_base = final_strip_Hspeed  # 20190104: Final de segmento "Brake". FinalSpeed = 0 m/s

                maximum_Hspeed = maximum_Hspeed_nbk_base

                # Trayectorias diagonales de pasadas.- SHS y SVS están relacionadas por la pendiente
                # /// CINEMATICA COMBINANADA (HORIZ + VERT)
                Vspeed_from_Hspeed = maximum_Hspeed * abs(inc_h_base) / dist2d_base
                maximum_Hspeed_base = maximum_Hspeed
                if (maximum_Vspeed > Vspeed_safeValue):
                    maximum_Vspeed = Vspeed_safeValue
                if (Vspeed_from_Hspeed > maximum_Vspeed):
                    maximum_Hspeed_base = maximum_Vspeed / (abs(inc_h_base) / dist2d_base)
                maximum_strip_Hspeed = maximum_Hspeed_base

                # Velocidad Horizontal de vector.- para asignar a SHS
                strip_Hspeed = cruising_speed * 0.94 # 20170220. Vr = 94% Vt
                if ((cruising_speed * 0.94) > maximum_strip_Hspeed):
                    strip_Hspeed = maximum_strip_Hspeed
                final_Hspeed = final_Hspeed_nbk_base
                if final_Hspeed_nbk_base > strip_Hspeed: # 20190104: No puede haber un final_Hspeed > maximum_Hspeed
                    final_Hspeed = strip_Hspeed

                # Velocidad Vertical.- para imprimir en fichero de tiempo
                # En trayectorias diagonales depende de strip_Hspeed
                Vspeed_from_strip_Hspeed = strip_Hspeed * inc_h_base / dist2d_base
                maximum_Vspeed_base = Vspeed_from_strip_Hspeed

                # CALCULO DE TIEMPOS hasta posición siguiente punto
                # 20190104: Gestiona el cálculo de tiempo con la misma casuística que el resto de cálculos cinemáticos
                if id_nbk == 1: # No brake condition: Enabled
                    if write_nbk_comand: # En caso de WPs SIN PARADA
                        time_to_point = 2 * dist2d_base / (strip_Hspeed_Last + strip_Hspeed)
                        if control_end_strip: # Final de segmento "No brake". FinalSpeed = 5m/s
                            time_to_point = 2 * dist2d_base / (strip_Hspeed_Last + final_Hspeed)
                    else: # 20190104: Inicio y Final de segmentos "CON PARADA".
                        if control_end_strip and n_point_in_strip > 2: # InitialHspeed > 0 & FinalHspeed = 0 m/s
                            time_to_point = 2 * dist2d_base / (strip_Hspeed_Last + final_Hspeed)
                        else: # 20190104: write_nbk_command = False AND control_begin_strip = True  TODO: Verificar toda la casuística
                            # Este caso se puede dar:
                            # En Zonal:  Siempre, ya que siempre para al inicio de siguiente pasada
                            # En Lineal: Si waiting_time_by_image > 0; hay siempre Parada al inicio del siguiente segmento ???
                            # En ambos casos: Vo = Vf = 0
                            time_to_point = dist2d_base / strip_Hspeed + 0.5 * strip_Hspeed * (1 / acceleration - 1 / decceleration)
                else: # id_nbk = 0: Stop in all WPs. Solo con id_trajectory_type = 1
                    time_to_point = dist2d_base / strip_Hspeed + 0.5 * strip_Hspeed * (1 / acceleration - 1 / decceleration)

                # Escribe en el fichero de tiempos
                file_uav_navigation_time.write("+ Info vector:\n")
                file_uav_navigation_time.write("  - Next waypoint .................................: ")
                file_uav_navigation_time.write(str(strip_number2print) + "_" + str(n_point_in_strip))
                if write_nbk_comand: # TODO: ESTO FUNCIONA EN LINEAL, pero en Zonal asigna máxima posible velocidad al primer WP de la siguiente pasada
                    if control_begin_strip:
                        file_uav_navigation_time.write(": (SPEED UP)")
                    elif control_end_strip:
                        file_uav_navigation_time.write(": (SLOW DOWN)")
                    else:
                        file_uav_navigation_time.write(": (NO STOP)")

                file_uav_navigation_time.write("\n")

                file_uav_navigation_time.write("  - Distance (2D) to the next waypoint ............: ")
                file_uav_navigation_time.write(format(distances[n_point], '.2f'))
                file_uav_navigation_time.write(" m.\n")

                elevation_gain = self.zLs[n_point] - self.zLs[n_point - 1]
                if elevation_gain >= 0:
                    ascent_gain.append([str(n_point) + "_" + str(n_point+1), elevation_gain])
                    cumulative_total_ascent += elevation_gain
                else:
                    descent_gain.append([str(n_point) + "_" + str(n_point+1), elevation_gain])
                    cumulative_total_descent += elevation_gain
                file_uav_navigation_time.write("  - Increasing in height to the next waypoint .....: ")
                file_uav_navigation_time.write(format(elevation_gain, '.2f'))
                file_uav_navigation_time.write(" m.\n")

                file_uav_navigation_time.write("  - Slope in degrees for the current vector........: ")
                file_uav_navigation_time.write(format(verticals_polar[n_point] * 180.0 / CONST_PI - 90, '.1f'))
                file_uav_navigation_time.write(" deg.\n")

                file_uav_navigation_time.write("  - Initial Ground Speed for the current vector....: ")
                file_uav_navigation_time.write(format(strip_Hspeed_Last, '.2f'))
                file_uav_navigation_time.write(" m/s.\n")

                average_Hspeed_by_nbk_base.append((strip_Hspeed_Last + final_Hspeed) / 2)
                infobase_Hspeed = [strip_Hspeed_Last, strip_Hspeed, final_Hspeed]

                file_uav_navigation_time.write("  - Maximum Ground Speed for the current vector....: ")
                file_uav_navigation_time.write(format(max(infobase_Hspeed), '.2f'))
                file_uav_navigation_time.write(" m/s.\n")

                file_uav_navigation_time.write("  - Final Ground Speed for the current vector......: ")
                file_uav_navigation_time.write(format(final_Hspeed, '.2f'))
                file_uav_navigation_time.write(" m/s.\n")

                file_uav_navigation_time.write("  - Vertical Speed for the diagonal vector ........: ")
                file_uav_navigation_time.write(format(maximum_Vspeed_base, '.2f'))
                file_uav_navigation_time.write(" m/s.\n")

                file_uav_navigation_time.write("  - Time to reach the next waypoint ...............: ")
                file_uav_navigation_time.write(format(time_to_point, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
                total_time += time_to_point
                file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
                file_uav_navigation_time.write("s.\n")

                strip_Hspeed_Last = final_Hspeed
                strip_Vspeed_Last = maximum_Vspeed_base
                if slope_change_factor < 0 or not write_nbk_comand and control_begin_strip:
                    # Si Ha cambiado el sentido de pte% entre la base anterior y la actual o...
                    # ... ha sido inicio de pasada en misión con parada en extremo final de segmento:
                    strip_Vspeed_Last = 0  # => InitialVspeed = 0
                strip_made_length += distances[n_point]
                mission_made_lenght += distances [n_point]
                strip_remaining_length = strip_length - strip_made_length

                # Altura ATOF del siguiente punto
                height_over_takeoff = self.zLs[n_point] - (self.z_takeoff)

                # Comando NBK
                """
                Label: Comando NBK (No Braking)
                Description: - Comando que determina la NO parada en los puntos paso.
                Changelog:   - 20160904 Se modifica la lógica para MAVLink. Ahora depende del param.1 del cmd22
                """
                # Writing NBK Command. Verificación del cumplimiento de entre líneas 1059 y 1090
                # En MAVLink no es necesario. Se gestiona con cmd22:Param#1.(tiempo de parada). Si es 0 no para.
                if write_nbk_comand:
                    time_to_image_capture = 0  # No stop in WP.
                    braking_for_shoot = " (NO STOP)"
                else:
                    time_to_image_capture = waiting_time_by_image  # Stop time in WP (user provided)
                    if n_point == number_of_points - 1: # 20190121: si es último punto de misión:
                        time_to_image_capture = minimum_time_btw_shots
                    braking_for_shoot = " (STOP for shooting)"

            if previous_ysf_command:  # Escribe en fichero de tiempo la información de inicio de pasada
                file_uav_navigation_time.write("\n")
                file_uav_navigation_time.write("*** STARTING STRIP No.")
                file_uav_navigation_time.write(str(strip_number2print) + " ***")


            # WayPoint Position Commands
            # MAVLink MAV_CMD_NAV_WAYPOINT cmd:16 
            # MAVLink MAV_CMD_NAV_SPLINE_WAYPOINT cmd:82
            """
            Label:          MAV_CMD_NAV_WAYPOINT & MAV_CMD_NAV_SPLINE_WAYPOINT
            Description:    Comandos de Posición de WP en coordenadas geodésicas con altura relativa
            Changelog:      20160904:   Se define código para MAVLink, con condición nbk asignada a cmd:16 param.1
                            20170112:   Se añade comando de navegación para trayectoria vertical suavizada (spline)
                            20170412:   Escribe comandos NAV_Waypoint adaptados a las nuevas estrategias de trayectoria
                                        CMD:16 en todos los WP si VStrategy=1 ó 2, resto (con pendiente uniforme), escribe solo extremos.
                            20190106:   En Vs=2 ahora solo escribe extremos y puntos intermedios de cambio de pendiente
                            20190119:   Evita escribir el primer WP de segmento si la distancia es muy corta con el anterior
                                        Tiene que cumplirse que dist2d_base < 1m y abs(inc_h_base) < 2m
                            20190120:...Elimina el primer WP de segmento siguiente si VS=4
            """
            if control_begin_strip:  # punto inicial de segmento
                if write_nbk_comand:  # Punto sin parada
                    if self.str_mission_type == 'lineal': # misión lineal
                        if id_trajectory_type == 4: #20190120: Si VS=4, solo escribe las esquinas de misión
                            # TODO: Chequear comportamiento real: "Esquinas en planta muy suavizadas ???"
                            control_low_distance = True
                        else: # 20190119: Control low distance from previous written WP
                            if dist2d_base < 1.0:
                                if abs(inc_h_base) < 2.0:
                                    control_low_distance = True

            if not control_low_distance: # 20190119: cummple distancia mínima con anterior WP
                str_line = ""
                if id_trajectory_type > 1: # 20190106: All except Strategy 1 (GSD & tolerance based)
                    if control_begin_strip or control_end_strip or control_slope_break_point:
                        # 20190106: Escribe WPs de inicio/fin de pasada/segmento y también en quiebros verticales intermedios para S2
                        if add_script_comments: # Add comments (Yes or not)
                            str_line += "#  NAV to Waypoint: " + str(strip_number2print) + "_" + str(n_point_in_strip) \
                                                                   + " // X: " + format(self.xLs[n_point], '.2f') \
                                                                   + " // Y: " + format(self.yLs[n_point], '.2f') \
                                                                   + " // H: " + format(self.zLs[n_point], '.2f') + "\n"
                            if control_slope_break_point:
                                str_line += "#  Slope Break Point" + "\n"
                        str_line += str(line_number) + "\t" + "0" + "\t"
                        str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                        str_line += MAV_CMD_NAV_WAYPOINT + "\t"
                        str_line += format(time_to_image_capture, '.6f') + "\t"  # Param.#1 Hold Time in seconds for tasking
                        # str_line += "0.000000" + "\t"  # Param.#1 Lineal: Hold Time for tasking = 0
                        str_line += "0.000000" + "\t"  # Param.#2
                        str_line += "0.000000" + "\t"  # Param.#3
                        str_line += "0.000000" + "\t"  # Param.#4
                        str_line += format(lat_ct, '.6f') + "\t"
                        str_line += format(lon_ct, '.6f') + "\t"
                        str_line += format(dh_ct + home_height_offset, '.6f') + "\t"
                        str_line += "1" + "\n"
                        file_uav_navigation_script.writelines(str_line)
                        line_number = line_number + 1
                else: # Strategy 1: Se escriben todos los WPs
                    if add_script_comments: # Add comments (Yes or not)
                        str_line += "#  NAV to Waypoint: " + str(strip_number2print) + "_" + str(n_point_in_strip) \
                                                               + " // X: " + format(self.xLs[n_point], '.2f') \
                                                               + " // Y: " + format(self.yLs[n_point], '.2f') \
                                                               + " // H: " + format(self.zLs[n_point], '.2f') + "\n"
                    str_line += str(line_number) + "\t" + "0" + "\t"
                    str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                    if (write_nbk_comand and smooth_vertical): # activa trayectoria vertical suavizada mediante comando spline (cmd:82)
                        str_line += MAV_CMD_NAV_SPLINE_WAYPOINT + "\t"
                    else:
                        str_line += MAV_CMD_NAV_WAYPOINT + "\t"
                    str_line += format(time_to_image_capture, '.6f') + "\t"  # Param.#1 Hold Time in seconds for tasking
                    str_line += "0.000000" + "\t"  # Param.#2
                    str_line += "0.000000" + "\t"  # Param.#3
                    str_line += "0.000000" + "\t"  # Param.#4
                    str_line += format(lat_ct, '.6f') + "\t"
                    str_line += format(lon_ct, '.6f') + "\t"
                    str_line += format(dh_ct + home_height_offset, '.6f') + "\t"
                    str_line += "1" + "\n"
                    file_uav_navigation_script.writelines(str_line)
                    line_number = line_number + 1

            control_low_distance = False

            # Escribe en el fichero de tiempo y script el nº de WP alcanzado.
            file_uav_navigation_time.write("\n")
            file_uav_navigation_time.write("- WP No.")
            file_uav_navigation_time.write(str(strip_number2print) + "_" + str(n_point_in_strip) + "(" + str(n_point + 1) + ")")
            if write_nbk_comand:
                file_uav_navigation_time.write(": (NO STOP)")
            file_uav_navigation_time.write("\n")

            # Photo Tasks
            """
            Label:          MAV_CMD_DO_DIGICAM_CONTROL & MAV_CMD_DO_SET_CAM_TRIGG_DIST
            Description:    cmd:203 Disparos deteniéndose en WP (NBK:Off)
                            cmd:206 Disparos al paso por WP (NBK:ON), controlados por distancia recorrida
            Changelog:      20150728: Se optimiza y simplifica código, para integrarse en la nueva lógica PMH/PMC
                            20160904: Se define código para MAVLink
                            20161204: cmd:206 sustituye a cmd:203 con delay = 0 (que no sincroniza bien)
                            20170412: Disparo vinculado a WP solo en puntos de parada obligatorios.
                                      Se adapta a las nuevas estrategias de trayectoria
            """
            if waiting_time_by_image == 0: # caso especial (solo con fitAxis=ON)
                # Mandatory stops: The first and the last waypoint of the axis
                if n_point == 0: # or n_point == (number_of_points - 1):
                    # MAV_CMD_DO_DIGICAM_CONTROL cmd:203
                    str_line = ""
                    if add_script_comments: # Add comments (Yes or not)
                        str_line += "#  Photo Shot in WP: " + str(strip_number2print) + "_" + str(n_point_in_strip) + braking_for_shoot + "\n"
                    str_line += str(line_number) + "\t" + "0" + "\t"
                    str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                    str_line += MAV_CMD_DO_DIGICAM_CONTROL + "\t"
                    str_line += "0.000000" + "\t"  # Param.#1
                    str_line += "0.000000" + "\t"  # Param.#2
                    str_line += "0.000000" + "\t"  # Param.#3
                    str_line += "0.000000" + "\t"  # Param.#4
                    str_line += "1.000000" + "\t"  # Param.#5. // 1.-Shot
                    str_line += "0.000000" + "\t"  # Param.#6
                    str_line += "0.000000" + "\t"  # Param.#7
                    str_line += "1" + "\n"
                    file_uav_navigation_script.writelines(str_line)
                    line_number = line_number + 1

                if n_point == 0 or n_point == (number_of_points - 1):
                    # MAV_CMD_DO_DIGICAM_CONTROL cmd:206
                    str_line = ""
                    if add_script_comments: # Add comments (Yes or not)
                        if control_end_strip:  # trigger by distance disabled in mandatory stop points
                            str_line += "#  Photo Shot by distance disabled" + "\n"
                        else:
                            str_line += "#  Photo Shot by distance: " + format(self.theoretical_base_length,'.3f') + "\n"
                    str_line += str(line_number) + "\t" + "0" + "\t"
                    str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                    str_line += MAV_CMD_DO_SET_CAM_TRIGG_DIST + "\t"
                    if control_end_strip:  # trigger by distance disabled
                        str_line += "0.000000" + "\t"  # Param.#1: Trigger disabled.
                    else:
                        trigger_distance = self.theoretical_base_length * distance_factor_reduction
                        str_line += format(trigger_distance,'.6f') + "\t"  # Param.#1: Distance to trigger
                    str_line += "0.000000" + "\t"  # Param.#2
                    str_line += "0.000000" + "\t"  # Param.#3
                    str_line += "0.000000" + "\t"  # Param.#4
                    str_line += "0.000000" + "\t"  # Param.#5
                    str_line += "0.000000" + "\t"  # Param.#6
                    str_line += "0.000000" + "\t"  # Param.#7
                    str_line += "1" + "\n"
                    file_uav_navigation_script.writelines(str_line)
                    line_number = line_number + 1

            else:  # resto de casos fitAxis=disabled and waiting_time_by_image >0
                # Only in mandatory stop points
                if control_begin_strip or id_nbk == 0: # 20181228: disparo estático (inicio pasadas + All WP cuando nbk = 0)
                    # MAV_CMD_DO_DIGICAM_CONTROL cmd:203
                    str_line = ""
                    if add_script_comments:  # Add comments (Yes or not)
                        str_line += "#  Photo Shot in WP: " + str(strip_number2print) + "_" + str(
                            n_point_in_strip) + braking_for_shoot + "\n"
                    str_line += str(line_number) + "\t" + "0" + "\t"
                    str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                    str_line += MAV_CMD_DO_DIGICAM_CONTROL + "\t"
                    str_line += "0.000000" + "\t"  # Param.#1
                    str_line += "0.000000" + "\t"  # Param.#2
                    str_line += "0.000000" + "\t"  # Param.#3
                    str_line += "0.000000" + "\t"  # Param.#4
                    str_line += "1.000000" + "\t"  # Param.#5. // 1.-Shot
                    str_line += "0.000000" + "\t"  # Param.#6
                    str_line += "0.000000" + "\t"  # Param.#7
                    str_line += "1" + "\n"
                    file_uav_navigation_script.writelines(str_line)
                    line_number = line_number + 1

                if control_begin_strip or control_end_strip: # 20170626: Mantiene desactivación trigger_distance en final de pasada
                    if id_nbk == 1:
                        # MAV_CMD_DO_DIGICAM_CONTROL cmd:206
                        str_line = ""
                        if add_script_comments:  # Add comments (Yes or not)
                            if control_end_strip:  # trigger by distance disabled in mandatory stop points
                                str_line += "#  Photo Shot by distance disabled" + "\n"
                            else:
                                str_line += "#  Photo Shot by distance: " + format(self.theoretical_base_length,
                                                                                   '.3f') + "\n"
                        str_line += str(line_number) + "\t" + "0" + "\t"
                        str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
                        str_line += MAV_CMD_DO_SET_CAM_TRIGG_DIST + "\t"
                        if control_end_strip:  # trigger by distance disabled
                            str_line += "0.000000" + "\t"  # Param.#1: Trigger disabled.
                        else:
                            trigger_distance = self.theoretical_base_length * distance_factor_reduction
                            str_line += format(trigger_distance, '.6f') + "\t"  # Param.#1: Distance to trigger
                        str_line += "0.000000" + "\t"  # Param.#2
                        str_line += "0.000000" + "\t"  # Param.#3
                        str_line += "0.000000" + "\t"  # Param.#4
                        str_line += "0.000000" + "\t"  # Param.#5
                        str_line += "0.000000" + "\t"  # Param.#6
                        str_line += "0.000000" + "\t"  # Param.#7
                        str_line += "1" + "\n"
                        file_uav_navigation_script.writelines(str_line)
                        line_number = line_number + 1

            # Definición del incremento de tiempo a computar por imagen en el fichero de tiempos,no influye en el fichero de navegación. Se expresa en segundos.
            file_uav_navigation_time.write("- Hold Time to stabilize and trigger a picture ....: ")
            file_uav_navigation_time.write(format(time_to_image_capture, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
            file_uav_navigation_time.write(" s.\n")
            total_time += time_to_image_capture

        # 20190120: Alerta de posible desbordamiento de buffer si el tiempo entre disparos es muy corto
        max_nbk_Hspeed = max(average_Hspeed_by_nbk_base)
        if max_nbk_Hspeed > 0: # Siempre, excepto cuando para en todos los puntos
            minimum_shooting_interval = self.theoretical_base_length / max_nbk_Hspeed
            if minimum_shooting_interval <= minimum_time_btw_shots:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText("Short time interval between shots !!          ")
                msg.setInformativeText("Risk of buffer overflow for storing images")
                msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
                str_msg_informative_text = "Recommended actions:\n" + \
                                           "- Reduce cruising speed and/or \n" + \
                                           "- Reduce forward overlap and/or \n" + \
                                           "- Increase GSD value \n"
                msg.setDetailedText(str_msg_informative_text)
                msg.exec_()

        # **************************
        # ***  LANDING Commands  ***
        # **************************

        # WP FINAL de pasada final (duplicado) sobre el que ajustar YAW hacia el punto de aterrizaje
        # MAV_CMD_NAV_WAYPOINT cmd:16
        # Resuelve el caso en que landing height > z last point.
        # En tal caso primero asciende y luego se mueve a la posición TOF evitando posibles colisiones con obstáculos
        str_line = ""
        if add_script_comments: # Add comments (Yes or not)
            str_line += "#  Final Waypoint // Landing procedure starts" \
                                       + " // X: " + format(self.xLs[n_point], '.2f') \
                                       + " // Y: " + format(self.yLs[n_point], '.2f') \
                                       + " // H: " + format(self.zLs[n_point], '.2f') + "\n"
        str_line += str(line_number) + "\t" + "0" + "\t"
        str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
        str_line += MAV_CMD_NAV_WAYPOINT + "\t"
        str_line += format(time_to_yaw_rotate - 1, '.6f') + "\t"  # Param.#1 Hold Time in seconds
        str_line += "0.000000" + "\t"  # Param.#2
        str_line += "0.000000" + "\t"  # Param.#3
        str_line += "0.000000" + "\t"  # Param.#4
        str_line += format(lat_ct, '.6f') + "\t"
        str_line += format(lon_ct, '.6f') + "\t"
        str_line += format(dh_ct + home_height_offset, '.6f') + "\t"
        str_line += "1" + "\n"
        file_uav_navigation_script.writelines(str_line)
        line_number = line_number + 1

        # MAV_CMD_DO_DIGICAM_CONTROL cmd:203
        str_line = ""
        if add_script_comments:  # Add comments (Yes or not)
            str_line += "#  Photo Shot in Final WP of the mission: " + braking_for_shoot + "\n"
        str_line += str(line_number) + "\t" + "0" + "\t"
        str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
        str_line += MAV_CMD_DO_DIGICAM_CONTROL + "\t"
        str_line += "0.000000" + "\t"  # Param.#1
        str_line += "0.000000" + "\t"  # Param.#2
        str_line += "0.000000" + "\t"  # Param.#3
        str_line += "0.000000" + "\t"  # Param.#4
        str_line += "1.000000" + "\t"  # Param.#5. // 1.-Shot
        str_line += "0.000000" + "\t"  # Param.#6
        str_line += "0.000000" + "\t"  # Param.#7
        str_line += "1" + "\n"
        file_uav_navigation_script.writelines(str_line)
        line_number = line_number + 1

        file_uav_navigation_time.write("\n")
        file_uav_navigation_time.write("*** STARTING PROCEDURE TOWARDS THE LANDING POINT ***\n")
        file_uav_navigation_time.write("- Time to reach the yaw towards the landing point..: ")
        file_uav_navigation_time.write(format(time_to_yaw_rotate - 1, '.1f'))
        total_time += time_to_yaw_rotate - 1
        file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
        file_uav_navigation_time.write("\n\n")

        # cambio de CRS del punto de aterrizaje a geográficas ETRS89
        if (self.postgis_srid_crs_project_mflip_integer != CONST_MAV_POSTGIS_SRID_CRS_CODE):
            qgs_point_transform = self.q3_api_op.transform_point_coordinates(self.x_landing,
                                                                             self.y_landing,
                                                                             self.postgis_srid_crs_project_mflip_integer,
                                                                             CONST_MAV_POSTGIS_SRID_CRS_CODE)
            lon_final_WP = qgs_point_transform.x()
            lat_final_WP = qgs_point_transform.y()

            latitude_landing = lat_final_WP * CONST_PI / 180.0
            longitude_landing = lon_final_WP * CONST_PI / 180.0

        # Paso a ECEF de las coordenadas del punto de aterrizaje
        # Añadido por Carlos 20150502. Corrige el error de no sumar la variable landing_height al punto de aterrizaje
        # landing_height_above_dtm = landing_height
        # if id_lnd == -1: # if landing point = takeoff point
        #     landing_height_above_dtm = landing_height + takeoff_height # pto aterrizaje = pto despegue, debe incluir takeoff_height

        if  height_before_landing == -1:  # -> #HBL: Checked -> The same as the final WP
            z_WP_landing = self.zLs[number_of_points - 1]
            increment_height = (z_landing + landing_height) - z_WP_landing
            if increment_height > 0:  # si z landing point > z last point
                z_WP_landing = z_landing + landing_height
        else:  # -> #HBL: Unchecked
            z_WP_landing = z_landing + height_before_landing
            increment_height = (z_landing + landing_height) - z_WP_landing

        control, xct_landing_geocentrica, yct_landing_geocentrica, zct_landing_geocentrica = \
            self.instance_geodetic_calculations.crs_operation_to_geocentric_from_geoid_height(self.postgis_srid_crs_project_mflip_integer,
                                                                                              self.x_landing,
                                                                                              self.y_landing,
                                                                                              z_WP_landing,
                                                                                              self.z_dtm_takeoff_interpolate,
                                                                                              # ellipsoid_height_tof,
                                                                                              takeoff_height)

        if (not control):
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Para el punto aterrizaje ha fallado la conversión a coordenadas geocéntricas",
                                                Qgis.Warning,
                                                10)
            return False

        xct_last_image_point = xct_ls[number_of_points - 1]
        yct_last_image_point = yct_ls[number_of_points - 1]
        zct_last_image_point = zct_ls[number_of_points - 1]
        inc_xct = xct_landing_geocentrica - xct_last_image_point
        inc_yct = yct_landing_geocentrica - yct_last_image_point
        inc_zct = zct_landing_geocentrica - zct_last_image_point

        control, inc_e, inc_n, inc_u = self.instance_geodetic_calculations.geocentric_2_enu(latitude_landing,
                                                                                            longitude_landing,
                                                                                            inc_xct,
                                                                                            inc_yct,
                                                                                            inc_zct)

        dist2d_to_Landing = sqrt(pow(inc_e, 2.0) + pow(inc_n, 2.0))
        mission_made_lenght += dist2d_to_Landing
        height_over_landing = z_WP_landing - self.z_takeoff

        # Calculo de la velocidad hacia el punto de aterrizaje (velocidad final hacia Landing point)
        # /// CINEMATICA VERTICAL ///
        dv_to_LandingWP = height_over_landing - height_over_takeoff
        vertical_angle = atan(dv_to_LandingWP / dist2d_to_Landing) * 180.0 / CONST_PI # pendiente final en deg
        if dv_to_LandingWP >= 0:
            acceleration_V = acceleration_Up
            decceleration_V = decceleration_Up
            # 20190116: Vspeed_UP_MaxValue basado basado en curva asintótica de análisis de Log
            Vspeed_logValue = 2 * ascend_speed * atan(vertical_angle / 21.5) / CONST_PI
            # coeficiente cuadrático inversamente proporcional a la pendiente del tramo. Máx 8%(UP)
            k_increasing = 1 + (8.0 * (1 - (vertical_angle / 90) ** 0.2)) / 100
            # Vspeed_Down_Max_Value
            Vspeed_safeValue = Vspeed_logValue * k_increasing
        else: # dv_to_LandingWP < 0:
            acceleration_V = acceleration_Down
            decceleration_V = decceleration_Down
            # 20190116: Vspeed_Down_Log_Value basado en curva asintótica de análisis de Log
            Vspeed_logValue = 2 * decrease_speed * atan(vertical_angle / (12.5 + abs(vertical_angle) / 5)) / CONST_PI
            # coeficiente cuadrático inversamente proporcional a la pendiente del tramo. Máx 8%(Down)
            k_increasing = 1 + (8.0 * (1 - (abs(vertical_angle) / 90) ** 0.2)) / 100
            # Vspeed_Down_Max_Value
            Vspeed_safeValue = Vspeed_logValue * k_increasing
        # Cálculo de parámetros máximos con acceleración continua
        maximum_Vspeed_dv1_to_LandingWP = sqrt(2 * abs(dv_to_LandingWP) * acceleration_V * decceleration_V  / (decceleration_V - acceleration_V))
        maximum_Vspeed = maximum_Vspeed_dv1_to_LandingWP

        # /// CINEMATICA HORIZONTAL ///
        maximum_Hspeed_b1_to_LandingWP = sqrt(2 * dist2d_to_Landing * acceleration * decceleration  / (decceleration - acceleration))
        maximum_Hspeed = maximum_Hspeed_b1_to_LandingWP

        # /// CINEMATICA COMBINANADA (HORIZ + VERT)
        Vspeed_from_Hspeed = maximum_Hspeed * abs(dv_to_LandingWP) / dist2d_to_Landing
        maximum_Hspeed_base = maximum_Hspeed
        if maximum_Vspeed_dv1_to_LandingWP > Vspeed_safeValue:
            maximum_Vspeed = Vspeed_safeValue
        if Vspeed_from_Hspeed > maximum_Vspeed:
            maximum_Hspeed_base = maximum_Vspeed / (abs(dv_to_LandingWP) / dist2d_to_Landing)
        maximum_landing_Hspeed = maximum_Hspeed_base * 1.00  # 20170220. Vr=96%Vt // 20180319. Vr=100%Vt

        # Velocidad Horizontal del vector final hacia el Landing Point.- para asignar a SHS
        landing_Hspeed = cruising_speed * 0.95  # 20170220. Vr = 94% Vt // 20190118. Vr = 95% Vt
        if ((cruising_speed * 0.95) > maximum_landing_Hspeed):
            landing_Hspeed = maximum_landing_Hspeed

        # Comando de navegacion hasta el punto de aterrizaje
        # MAVLink MAV_CMD_NAV_WAYPOINT cmd:16
        str_line = ""
        if add_script_comments: # Add comments (Yes or not)
            str_line += "#  NAV to Landing Waypoint: " \
                                                   + " // X: " + format(self.x_landing, '.2f') \
                                                   + " // Y: " + format(self.y_landing, '.2f') \
                                                   + " // H: " + format(z_WP_landing, '.2f') + "\n"
        str_line += str(line_number) + "\t" + "0" + "\t"
        str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
        str_line += MAV_CMD_NAV_WAYPOINT + "\t"
        if not height_before_landing == landing_height: # solo si HBL != height_over_landing
            str_line += "0.000000" + "\t"  # Param.#1
        else:
            str_line += "4.000000" + "\t"  # Param.#1. Hold Time in seconds at the end of the mission
        str_line += "0.000000" + "\t"  # Param.#2
        str_line += "0.000000" + "\t"  # Param.#3
        str_line += "0.000000" + "\t"  # Param.#4
        str_line += format(lat_final_WP, '.6f') + "\t"
        str_line += format(lon_final_WP, '.6f') + "\t"
        str_line += format(z_WP_landing + home_height_offset - self.z_takeoff, '.6f') + "\t"
        str_line += "1" + "\n"
        file_uav_navigation_script.writelines(str_line)
        line_number = line_number + 1

        time_to_landing_point = dist2d_to_Landing / landing_Hspeed + 0.5 * landing_Hspeed / acceleration - 0.5 * landing_Hspeed / decceleration


        # Label: Mount Control
        # MAVLink MAV_CMD_NAV_WAYPOINT cmd:205
        # 20190106. Reset to Roll to 0. Write the command only if Roll value != 0
        if not float_sensor_attitude_phi_deg == 0:
            float_sensor_attitude_phi_deg = 0
            dif_phi_offsetphi = float_sensor_attitude_phi_deg - float_mount_attitude_offset_phi_deg  # rango entre +25 y -25. Nadir = 0
            str_line = ""
            if add_script_comments: # Add comments (Yes or not)
                str_line += "#  Mount Control: " + " // Pitch: " + format(float_sensor_attitude_omega_deg, '.3f') \
                                                + " // Roll: " + format(float_sensor_attitude_phi_deg, '.3f') \
                                                + " // Yaw: " + format(0, '.3f') + "\n"
            str_line += str(line_number) + "\t" + "0" + "\t"
            str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
            str_line += MAV_CMD_DO_MOUNT_CONTROL + "\t"
            str_line += format(dif_omega_offsetomega, '.6f') + "\t" # Param.#1
            str_line += format(dif_phi_offsetphi, '.6f') + "\t" # Param.#2
            str_line += format(dif_kappa_offsetkappa, '.6f') + "\t"  # Param.#3 // 2axis gimbal -> kappa=0
            str_line += "0.000000" + "\t"  # Param.#4
            str_line += "0.000000" + "\t"  # Param.#5
            str_line += "0.000000" + "\t"  # Param.#6
            str_line += MAV_MOUNT_MODE + "\t" # Param.#7 // MAV_MOUNT_MODE_RC_TARGETING = 3 ??
            str_line += "1" + "\n"
            file_uav_navigation_script.writelines(str_line)
            line_number = line_number + 1

        # Vector final hacia Landing Point (depende de landing_Hspeed)
        Vspeed_from_landing_Hspeed = landing_Hspeed * dv_to_LandingWP / dist2d_to_Landing
        maximum_Vspeed_landing_base = Vspeed_from_landing_Hspeed

        file_uav_navigation_time.write("- Distance (2D) to the Landing point ..............: ")
        file_uav_navigation_time.write(format(dist2d_to_Landing, '.2f'))
        file_uav_navigation_time.write(" m.\n")

        file_uav_navigation_time.write("- Difference of height from the final WP ..........: ")
        file_uav_navigation_time.write(format(dv_to_LandingWP, '.2f'))
        file_uav_navigation_time.write(" m.\n")
        if dv_to_LandingWP >= 0:
            ascent_gain.append([str(n_point + 1) + "_VH", dv_to_LandingWP])
            cumulative_total_ascent += dv_to_LandingWP
        else:
            descent_gain.append([str(n_point + 1) + "_VH", dv_to_LandingWP])
            cumulative_total_descent += dv_to_LandingWP

        file_uav_navigation_time.write("- Slope in degrees for the final vector ...........: ")
        file_uav_navigation_time.write(format(vertical_angle, '.1f'))
        file_uav_navigation_time.write(" deg.\n")

        file_uav_navigation_time.write("- Maximum Ground Speed for the final vector .......: ")
        file_uav_navigation_time.write(format(landing_Hspeed, '.2f'))
        file_uav_navigation_time.write(" m/s.\n")

        file_uav_navigation_time.write("- Vertical Speed for the final vector .............: ")
        file_uav_navigation_time.write(format(maximum_Vspeed_landing_base, '.2f'))
        file_uav_navigation_time.write(" m/s.\n")

        file_uav_navigation_time.write("- Time to reach the final point of the route ......: ")
        file_uav_navigation_time.write(format(time_to_landing_point, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
        total_time += time_to_landing_point
        file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
        file_uav_navigation_time.write("s.\n\n")

        # Comando de descenso final.
        # MAV_CMD_NAV_WAYPOINT cmd:16
        if not height_before_landing == landing_height: # solo escribe si HBL != height_over_landing
            final_vertical_height_old = landing_height - height_before_landing
            final_vertical_height = increment_height
            str_line = ""
            if add_script_comments: # Add comments (Yes or not)
                str_line += "#  Final Vertical Descent: " + format(final_vertical_height, '.2f') + " m." \
                                                         + " // X: " + format(self.x_landing, '.2f') \
                                                         + " // Y: " + format(self.y_landing, '.2f') \
                                                         + " // H: " + format(z_landing + landing_height, '.2f') + "\n"
            str_line += str(line_number) + "\t" + "0" + "\t"
            str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
            str_line += MAV_CMD_NAV_WAYPOINT + "\t"
            str_line += "4.000000" + "\t"  # Param.#1. Hold Time in seconds
            str_line += "0.000000" + "\t"  # Param.#2
            str_line += "0.000000" + "\t"  # Param.#3
            str_line += "0.000000" + "\t"  # Param.#4
            str_line += format(lat_final_WP, '.6f') + "\t"  # Param.#5
            str_line += format(lon_final_WP, '.6f') + "\t"  # Param.#6
            str_line += format(z_landing + landing_height - self.z_takeoff + home_height_offset, '.6f') + "\t"  # Param.#7
            str_line += "1" + "\n"
            file_uav_navigation_script.writelines(str_line)
            line_number = line_number + 1

            # Calculo de la velocidad vertical del descenso final. 20180321
            # /// CINEMATICA VERTICAL ///
            acceleration_V = acceleration_Down
            decceleration_V = decceleration_Down
            Vspeed_safeValue = abs(decrease_speed) / 1.15
            # Cálculo de parámetros máximos con acceleración continua
            maximum_Vspeed_final_descent = sqrt(2 * abs(final_vertical_height) * acceleration_V * decceleration_V  / (decceleration_V - acceleration_V))
            landing_Vspeed = -1 * maximum_Vspeed_final_descent
            if maximum_Vspeed_final_descent > Vspeed_safeValue:
                landing_Vspeed = -1 * Vspeed_safeValue

            if landing_Vspeed != 0: # evita división por 0
                time_to_final_height = abs(final_vertical_height) / abs(landing_Vspeed) + 0.5 * abs(landing_Vspeed) / acceleration_V - 0.5 * abs(landing_Vspeed) / decceleration_V
            else: # Si desnivel = 0; tiempo = 0
                time_to_final_height = 0

            file_uav_navigation_time.write("- Difference of height from the final Height ......: ")
            file_uav_navigation_time.write(format(final_vertical_height, '.1f'))
            file_uav_navigation_time.write(" m.\n")
            if final_vertical_height >= 0:
                ascent_gain.append(["VH", final_vertical_height])
                cumulative_total_ascent += final_vertical_height
            else:
                descent_gain.append(["VH", final_vertical_height])
                cumulative_total_descent += final_vertical_height

            file_uav_navigation_time.write("- Vertical Speed for the final vertical vector.....: ")
            file_uav_navigation_time.write(format(landing_Vspeed, '.1f'))
            file_uav_navigation_time.write(" m/s.\n")

            file_uav_navigation_time.write("- Time to reach the height of the final point .....: ")
            file_uav_navigation_time.write(format(time_to_final_height, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
            total_time += time_to_final_height
            file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
            file_uav_navigation_time.write("s.\n")


        # Añade Info fin de ruta
        waiting_time_end_route = 5.0
        str_line = ""
        if add_script_comments: # Add comments (Yes or not)
            str_line += "#  Waiting time to end mission: " + str(waiting_time_end_route) + " sec."
            if id_lnd == -1:
                str_line += " // H.Landing = H.Takeoff = " + format(self.z_takeoff, '.2f') + "\n"
            else:
                str_line += " // H.Landing = H.dtm.Landing = " + format(self.z_dtm_lnd_interpolate, '.2f') + "\n"
        file_uav_navigation_script.writelines(str_line)
        line_number = line_number + 1

        file_uav_navigation_time.write("\n")
        file_uav_navigation_time.write("- Hold Time at the end of the route ...............: ")
        file_uav_navigation_time.write(format(waiting_time_end_route, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
        total_time += waiting_time_end_route
        file_uav_navigation_time.write(" (" + format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f') + ")")
        file_uav_navigation_time.write("s.\n")
        file_uav_navigation_time.write("- Estimated Height over the landing point .........: ")
        file_uav_navigation_time.write(format(landing_height, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
        file_uav_navigation_time.write(" m.\n")

        descent_gain.append(["LND", -landing_height])
        cumulative_total_descent += -landing_height

        # Procedimiento de Auto-aterrizaje. 
        # MAV_CMD_NAV_LAND. cmd:20
        """
        Label: WP AutoLanding (m/s) MAV_CMD_NAV_LAND, #WAL
        Description: Comando especial para que el dron inicie un auto-aterrizaje a la velocidad establecida en el sistema
                        una vez haya finalizado la ruta planificada
        Changelog: - 20150412: En la versión PyQGIS el valor es introducido por el usuario en el diálogo
                   - 20150724: Se corrige error de impresión de comando estando desactivado en el panel
                   - 20160904: TODO: codificar para MAVLink. Hay dos posibles opciones (ver con Diego:
                               MAV_CMD_NAV_RETURN_TO_LAUNCH: cmd:20 - Va a HOME AutoAterriza y apaga motores
                               MAV_CMD_NAV_LAND: cmd:21 - AutoAterriza donde se ejecuta el comando / OJO: NO apaga motores !!!. 
                   - 20160906: TODO: Asignar velocidad de autolanding "float_wal" al sistema (Diego)
        """

        # Tiempo estimado para aterrizar en modo manual
        landing_height_ground_part = 10.0 # (m.) parte final del aterrizaje a baja velocidad
        landing_ground_Vspeed = 0.4  # velocidad promedio estimada de la fase final de aterrizaje
        landing_upper_Vspeed = 1.5  # velocidad promedio estimada de la fase inicial (zona alta) del aterrizaje
        if (landing_height >= landing_height_ground_part): # landing_height min_value = 5 m
            landing_height_upper_part = landing_height - landing_height_ground_part
            estimated_landing_upper_time = landing_height_upper_part / landing_upper_Vspeed \
                                           + 0.5 * landing_upper_Vspeed / acceleration_Down \
                                           - 0.5 * landing_upper_Vspeed / decceleration_Down
        else:
            landing_height_ground_part = landing_height
            estimated_landing_upper_time = 0
        
        estimated_landing_ground_time = landing_height_ground_part / landing_ground_Vspeed \
                                       + 0.5 * landing_ground_Vspeed / acceleration_Down \
                                       - 0.5 * landing_ground_Vspeed / decceleration_Down
        estimated_landing_time = estimated_landing_upper_time + estimated_landing_ground_time

        if float_wal != -1: # Panel WAL Activado.
            # Se establece el comando cmd:20. (mejor opción que cmd:21 ya que este no desarma)
            str_line = ""
            if add_script_comments: # Add comments (Yes or not)
                str_line += "#  Auto Landing enabled:" + "\n"
            str_line += str(line_number) + "\t" + "0" + "\t"
            str_line += MAV_FRAME_GLOBAL_RELATIVE_ALT + "\t"
            str_line += MAV_CMD_NAV_RETURN_TO_LAUNCH + "\t"
            str_line += "0.000000" + "\t"  # Param.#1
            str_line += "0.000000" + "\t"  # Param.#2
            str_line += "0.000000" + "\t"  # Param.#3
            str_line += "0.000000" + "\t"  # Param.#4
            str_line += "0.000000" + "\t"  # Param.#5
            str_line += "0.000000" + "\t"  # Param.#6
            str_line += "0.000000" + "\t"  # Param.#7
            str_line += "1" + "\n"
            file_uav_navigation_script.writelines(str_line)
            line_number = line_number + 1

            # Tiempo estimado para aterrizar en modo Auto Landing
            auto_landing_time = landing_height / float_wal + 0.5 * float_wal / acceleration_Down - 0.5 * float_wal / decceleration_Down
            file_uav_navigation_time.write("\n")
            file_uav_navigation_time.write("- Auto Landing Mode enabled.(descent speed) .......: ")
            file_uav_navigation_time.write(format(float_wal, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
            file_uav_navigation_time.write(" m/s.\n")
            file_uav_navigation_time.write("- Estimated Time for landing in Auto Landing Mode .: ")
            file_uav_navigation_time.write(format(auto_landing_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
            file_uav_navigation_time.write(" s.\n")
            total_time += auto_landing_time

            # Estimación de ahorro de tiempo aterrizando en modo manual.
            estimated_saved_time = auto_landing_time - estimated_landing_time
            if (estimated_landing_time > auto_landing_time):
                estimated_saved_time = 0
            file_uav_navigation_time.write("- Estimated Saving Time in manual mode ............: (")
            file_uav_navigation_time.write(format(estimated_saved_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
            file_uav_navigation_time.write(") s.\n")

        else:  # Panel WAL Desactivado.
            file_uav_navigation_time.write("\n")
            file_uav_navigation_time.write("- Estimated Time for landing in manual mode .......: ")
            file_uav_navigation_time.write(format(estimated_landing_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
            file_uav_navigation_time.write(" s.\n")
            total_time += estimated_landing_time

        # graba en base de datos la duración del vuelo
        str_cod_flight_block = self.list_parameter_db_flight_block[0]
        str_total_time = str(total_time)

        str_sql = "UPDATE flight_block SET flight_duration = "
        str_sql += str_total_time + " "
        str_sql += "WHERE cod_flight_block = '"
        str_sql += str_cod_flight_block + "';"
        self.db_op.execute_query_old(self.path_db_project, str_sql)

        file_uav_navigation_time.write("\n")
        file_uav_navigation_time.write("TOTAL MISSION DISTANCE ...................: ")
        file_uav_navigation_time.write(format(mission_made_lenght, '.1f'))
        file_uav_navigation_time.write(" meters.\n")
        file_uav_navigation_time.write("CUMULATIVE TOTAL ASCENT ..................: ")
        file_uav_navigation_time.write(format(cumulative_total_ascent, '.1f'))
        file_uav_navigation_time.write(" meters.\n")
        file_uav_navigation_time.write("CUMULATIVE TOTAL DESCENT .................: ")
        file_uav_navigation_time.write(format(cumulative_total_descent, '.1f'))
        file_uav_navigation_time.write(" meters.\n")
        file_uav_navigation_time.write("TOTAL TIME FOR THE PLANNED MISSION .......: ")
        file_uav_navigation_time.write(format(total_time, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
        file_uav_navigation_time.write(" seconds.\n")
        file_uav_navigation_time.write("                                            ")
        file_uav_navigation_time.write(format(total_time / 60.0, '.' + c.CONST_MICRODRON_CMD_TIME_PRECISION + 'f'))
        file_uav_navigation_time.write(" minutes.\n")

        file_uav_navigation_script.close()
        file_uav_navigation_time.close()

        return True