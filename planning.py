# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PflipUav3
                                 A QGIS plugin
 Photogrammetric and Remote Sensing Flight Planning for unmanned aerial vehicle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-23
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernández López, PAFYC-UCLM
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# import PyQt classes
from PyQt5.QtCore import (Qt, QVariant, QCoreApplication, QFileInfo)
from PyQt5.QtWidgets import (QMessageBox, QProgressBar)

# import PyQGIS classes
from qgis.core import (Qgis, QgsProject, QgsGeometry, QgsFeature, QgsRasterLayer, QgsVectorLayer, QgsField,
                       QgsFeatureRequest, QgsPointXY)
from qgis.gui import (QgsMessageBar, QgsMapCanvas)

# import Python classes
from math import *
import time
from RasterDEM import RasterDEM

# from qgis.core import Qgis
# qgis_version_number_str = Qgis.QGIS_VERSION.split('-')[0]
# qgis_version_first_number = int(qgis_version_number_str.split('.')[0])
# qgis_version_second_number = int(qgis_version_number_str.split('.')[1])
# qgis_version_third_number = int(qgis_version_number_str.split('.')[2])

# if qgis_version_first_number == 3 and qgis_version_second_number <= 16 and qgis_version_third_number <= 4:
    # from libCpp.libPyPFLIP import IPyPflipProject
# elif qgis_version_first_number == 3 and qgis_version_second_number <= 16 and qgis_version_third_number > 4:
    # from libCppMsi.libPyPFLIP import IPyPflipProject

# # import self classes
# from . import config as c  # constants
# from .classes.qgis3_api_operations import Qgis3ApiOperations
# from .classes.db_operations import *
# from .carabo_way_point_library import *
from .PyGeodesy.GeodeticCalculations.geodetic_calculations import *

# FIXME: pasar a constantes o utilizar math.pi
# valores constantes
CONST_PI = 4.0 * atan(1.0)

# geodetic_calculations
CONST_GEODETIC_CALCULATIONS_NO_ERROR = 0

from qgis.core import Qgis
qgis_version_number_str = Qgis.QGIS_VERSION.split('-')[0]
qgis_version_first_number = int(qgis_version_number_str.split('.')[0])
qgis_version_second_number = int(qgis_version_number_str.split('.')[1])
qgis_version_third_number = int(qgis_version_number_str.split('.')[2])

qgis_version_second_number_change_buffer_parameters = 20

class planning:
    """
    Brief: Clase para el cálculo de la planificación de vuelo lineal
    """
    def __init__(self,
                 iface,
                 path_plugin,
                 path_project,
                 path_db_project,
                 path_file_results,
                 path_file_results_pdf,
                 path_file_results_csv,
                 path_uav_navigation_file_name,
                 str_code_flight_block,
                 str_idinternal_crs_proyect,
                 lst_result_process,
                 str_firmware,
                 pg_dialog,
                 qgsgeometry_zone_buffer,
                 is_remove_images_without_stereoscopy):
        """
        Brief:inicialización del cuerpo de la clase
        """
        # self.iPyProject = iPyProject  #C++: DHL 202003
        # self.useCpp = True  #C++: DHL 202003

        self.iface = iface
        self.path_plugin = path_plugin
        self.path_project = path_project
        self.path_db_project = path_db_project
        self.path_file_results = path_file_results
        self.path_file_results_pdf = path_file_results_pdf
        self.path_file_results_csv = path_file_results_csv
        self.path_uav_navigation_file_name = path_uav_navigation_file_name
        self.str_code_flight_block = str_code_flight_block
        self.lst_result_process = lst_result_process
        self.str_firmware = str_firmware
        self.progress_dialog = pg_dialog
        self.qgsgeometry_zone_buffer = qgsgeometry_zone_buffer
        self.is_remove_images_without_stereoscopy = is_remove_images_without_stereoscopy

        self.instanceGeodeticCalculations = GeodeticCalculations(self.iface,
                                                                 self.path_db_project,
                                                                 self.path_plugin)  # instancia a geodetic_calculations

        self.q3_api_op = Qgis3ApiOperations(self.iface)
        self.db_op = DbOperations(self.iface)  # new db operations

        # EPSG - CRS - code internal QGIS
        self.str_InternalCrsId_code_pry_mflip = str_idinternal_crs_proyect
        self.str_PostgisCrsId_code_pry_mflip = self.q3_api_op.get_strcrscode_InternalCrsId2PostgisCrsId(self.str_InternalCrsId_code_pry_mflip)
        self.int_PostgisCrsId_code_pry_mflip = int(self.str_PostgisCrsId_code_pry_mflip)
        self.str_authid_code_pry_mflip = self.q3_api_op.get_strcrscode_InternalCrsId2authid(self.str_InternalCrsId_code_pry_mflip)

        # recopila variables no introducidas en ningún panel
        self.number_of_initial_strip = 1
        self.increment_in_number_of_strip = 1
        self.number_of_initial_image_in_strip = 1
        self.increment_in_number_of_image = 1

        # self.omega_initial = c.CONST_UAV_OMEGA_INITIAL_DEFAULT * CONST_PI / 180.0
        result_process_in_memory = self.planning
        if (result_process_in_memory):
            self.lst_result_process.append(True)
            self.lst_result_process.append(self.gsd_tolerance)
        else:
            str_msg = "Se encontraron errores en el procesamiento del vuelo lineal"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                20)
            self.lst_result_process.append(False)

    def get_parameter_db_camera(self):
        """
        Brief: obtiene parámetros de la bd tabla [camera] y los pone en variables globales
        :return:
        """
        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos         
        str_sql = "SELECT * FROM camera WHERE cod_camera = '" + self.str_cod_camera + "'"
        cursor_db_project.execute(str_sql)

        for row in cursor_db_project.fetchall():
            self.str_cam_trademark = str(row[1])
            self.rows_digital_sensor = row[2]
            self.columns_digital_sensor = row[3]
            self.focal = row[4]
            self.focal = self.focal / 1000.0  # paso a metros
            self.geometric_resolution = row[5]
            self.geometric_resolution = self.geometric_resolution / 1000.0  # paso a metros
            self.xppa = row[6]
            self.xppa = self.xppa / 1000.0  # paso a metros
            self.yppa = row[7]
            self.yppa = self.yppa / 1000.0  # paso a metros

        con_db_project.close()  # cierra la base de datos

    def get_resection_matrix(self,
                             pitch,
                             roll,
                             yaw):
        """
        Brief: cambio de base angular. Obtiene valores OPK a partir de los valores de Euler (C'PATB)
        :param Pitch: Ángulo Pitch, rotación sobre eje X-gimbal, sentido antihorario, en radianes.
        :type Pitch: float ; dominio [-20,+70]. Negativo: vista hacia atrás. Positivo: vista hacia adelante. Nadir=0
        :param Roll: Ángulo Roll, rotación en torno al eje Y-gimbal, sentido antihorario, en radianes.
        :type Roll: float ; dominio [-35,+35]. Negativo: vista hacia la derecha. Positivo: vista hacia la izquierda. Nadir=0
        :param yaw: Ángulo Yaw (rotación en torno al eje z, sentido antihorario??), en radianes.
        :type yaw: float
        :return: omega, phi, kappa
        :rtype: list
        """

        # p11 = cos(yaw) * cos(roll)
        # p12 = cos(yaw) * sin(pitch) * sin(roll) - sin(yaw) * cos(roll)
        p13 = cos(yaw) * sin(pitch) * cos(roll) + sin(yaw) * sin(roll)
        p21 = sin(yaw) * cos(pitch)
        p22 = sin(yaw) * sin(pitch) * sin(roll) + cos(yaw) * cos(roll)
        p23 = sin(yaw) * sin(pitch) * cos(roll) - cos(yaw) * sin(roll)
        # p31 = -sin(pitch)
        # p32 = cos(pitch) * sin(roll)
        p33 = cos(pitch) * cos(roll)

        omega = atan2(p13,p33)
        phi = asin(p23) * -1
        # TODO: Testear si en resection-matrix, hay que usar Kappa o Yaw? (con DTM de cantera)
        #       para valores grandes de Pitch y/o Roll puede haber varios grados de diferencia
        kappa = atan2(p21,p22) * -1

        """
        Brief: obtiene la resection matrix (opk-rot)
        :param omega: Ángulo omega, rotación en torno al eje X-CRS, sentido antihorario, en radianes.
        :type omega: float ;dominio (-90,+90). Negativo: vista hacia el Sur. Positivo: vista hacia el Norte. Nadir=0
        :param phi: Ángulo phi, rotación en torno al eje Y-CRS, sentido antihorario, en radianes.
        :type phi: float ; dominio (-90,+90). Negativo: vista hacia el Este. Positivo: vista hacia el Oeste. Nadir=0
        :param kappa: Ángulo kappa, rotación en torno al eje Z-CRS, sentido horario, en radianes.
        :type kappa: float
        :return: matriz de resección
        :rtype: list
        """

        r11 = cos(phi) * cos(kappa)
        r12 = -cos(phi) * sin(kappa)
        r13 = sin(phi)
        r21 = cos(omega) * sin(kappa) + sin(omega) * sin(phi) * cos(kappa)
        r22 = cos(omega) * cos(kappa) - sin(omega) * sin(phi) * sin(kappa)
        r23 = -sin(omega) * cos(phi)
        r31 = sin(omega) * sin(kappa) - cos(omega) * sin(phi) * cos(kappa)
        r32 = sin(omega) * cos(kappa) + cos(omega) * sin(phi) * sin(kappa)
        r33 = cos(omega) * cos(phi)

        row1 = []
        row2 = []
        row3 = []
        row1.append(r11)
        row1.append(r12)
        row1.append(r13)
        row2.append(r21)
        row2.append(r22)
        row2.append(r23)
        row3.append(r31)
        row3.append(r32)
        row3.append(r33)

        matriz = []
        matriz.append(row1)
        matriz.append(row2)
        matriz.append(row3)

        return matriz

    def get_strip_type(self, value):
        """
        Brief: Método para obtener el código de tipo de pasada a partir de su azimut
        :param value: Azimut de la pasada en DEG
        :type value: float
        :return: tipo de pasada
        :rtype: str
        """
        if (value >= 350 and value <= 10):
            return "Pasada SN"  # Tipo de pasada de vuelo de Sur a Norte
        if (value > 10 and value < 80):
            return "Pasada NE"  # Tipo de pasada oblicua noreste
        if (value >= 80 and value <= 100):
            return "Pasada OE"  # Tipo de pasada de vuelo de Oeste a Este
        if (value > 100 and value < 170):
            return "Pasada SE"  # Tipo de pasada oblicua sureste
        if (value >= 170 and value <= 190):
            return "Pasada NS"  # Tipo de pasada de vuelo de Norte a Sur
        if (value > 190 and value < 260):
            return "Pasada SO"  # Tipo de pasada oblicua suroeste
        if (value >= 260 and value <= 280):
            return "Pasada EO"  # Tipo de pasada de vuelo de Este a Oeste
        if (value > 280 and value < 350):
            return "Pasada NO"  # Tipo de pasada oblicua noroeste

    @property
    def planning(self):
        """
        Brief: Método para el cálculo de la planificación
        """

        """
        str_msg_log = "CALCULATING FLIGHT PLANNING. LINEAL MISSION TYPE ..."
        QgsMessageLog.logMessage(str_msg_log,c.CONST_PLIPUAV_TITLE,QgsMessageLog.INFO)
        """

        self.progress_dialog.enabled_suprocess(False)
        str_process_title = "Calculating Flight Planning. Mission lineal type"
        self.progress_dialog.set_title_process(0, str_process_title)
        QCoreApplication.processEvents()

        # recupera valores de parámetros grabados en la tabla flight_block de la BD
        self.list_parameter_db_flight_block = self.db_op.get_parameter_db_flight_block(self.path_db_project,
                                                                                       self.str_code_flight_block)

        self.str_cod_flight_block = self.list_parameter_db_flight_block[0]
        self.str_cod_camera = self.list_parameter_db_flight_block[1]
        str_dtm_path = self.list_parameter_db_flight_block[2]

        #C++: DHL 202003
        #dtmEpsgCode = 25830
        dtmEpsgCode = self.int_PostgisCrsId_code_pry_mflip
        dtmNumberOfDecimals = 1
        loadInMemory = True

        # text = 'Before add Dem'
        # text += '\n str_dtm_path = ' + str_dtm_path
        # text += '\n dtmNumberOfDecimals = ' + str(dtmNumberOfDecimals)
        # text += '\n dtmEpsgCode = ' + str(dtmEpsgCode)
        # msgBox = QMessageBox()
        # msgBox.setIcon(QMessageBox.Information)
        # # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setTextFormat(Qt.RichText)
        # msgBox.setText(text)
        # msgBox.exec_()

        raster_dem = RasterDEM(dtmNumberOfDecimals)
        str_error = raster_dem.set_from_file(str_dtm_path, dtmEpsgCode, loadInMemory)
        if str_error:
            str_msg = "Error:\n" + str_error
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Info,
                                                10)
            # self.file_results.close()
            # self.file_results_csv.close()
            return False

        # ret = self.iPyProject.addDem(str_dtm_path,dtmNumberOfDecimals,dtmEpsgCode,loadInMemory)
        # if ret[0] == "False":
        #     str_msg = "Error:\n" + ret[1]
        #     self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
        #                                         str_msg,
        #                                         Qgis.Info,
        #                                         10)
        #     # self.file_results.close()
        #     # self.file_results_csv.close()
        #     return False

        # text = 'After add Dem'
        # msgBox = QMessageBox()
        # msgBox.setIcon(QMessageBox.Information)
        # # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setTextFormat(Qt.RichText)
        # msgBox.setText(text)
        # msgBox.exec_()

        #C++: DHL 202003
        id_tof = self.list_parameter_db_flight_block[3]
        str_id_tof = str(id_tof)
        id_lnd = self.list_parameter_db_flight_block[4]  # landing type (-1 - toff point; 0 - end point; > 0 - id del punto digitalizado
        str_id_lnd = str(id_lnd)
        # self.str_id_fb_type = self.list_parameter_db_flight_block[6]
        gsd = self.list_parameter_db_flight_block[7]
        gsd_tolerance = self.list_parameter_db_flight_block[8]
        gsd_tolerance = gsd_tolerance / 100.0  # paso a tanto por uno
        overlap_fwd = self.list_parameter_db_flight_block[9]
        overlap_fwd = overlap_fwd / 100.0  # paso a tanto por uno
        # overlap_side = self.list_parameter_db_flight_block[10]
        # overlap_side = overlap_side / 100.0 # paso a tanto por uno        
        gps_precision = self.list_parameter_db_flight_block[11]
        omega_precision = self.list_parameter_db_flight_block[12]
        omega_precision = omega_precision * pi / 180.0  # de DEG a RAD
        phi_precision = self.list_parameter_db_flight_block[13]
        phi_precision = phi_precision * CONST_PI / 180.0  # de DEG a RAD
        kappa_precision = self.list_parameter_db_flight_block[14]
        kappa_precision = kappa_precision * CONST_PI / 180.0  # de DEG a RAD
        id_trajectory_type = self.list_parameter_db_flight_block[15]
        # self.cruising_speed = self.list_parameter_db_flight_block[16]
        # self.ascent_speed = self.list_parameter_db_flight_block[17]
        # self.decrease_speed = self.list_parameter_db_flight_block[18]
        lineal_segments_enlargement = self.list_parameter_db_flight_block[19]
        takeoff_height = self.list_parameter_db_flight_block[20]
        # self.id_nbk = self.list_parameter_db_flight_block[21] # no braking
        # landing_height = self.list_parameter_db_flight_block[22]
        # self.smoothV = self.list_parameter_db_flight_block[23] # old field "wpb"
        # self.HBL = self.list_parameter_db_flight_block[24] # old field "images_item"
        hold_time = self.list_parameter_db_flight_block[25]
        self.omega_angle = self.list_parameter_db_flight_block[26] # 20180325. Habilitado
        self.phi_angle = self.list_parameter_db_flight_block[27] # 20180325. Habilitado
        # self.id_erc = self.list_parameter_db_flight_block[28]
        # self.id_eal = self.list_parameter_db_flight_block[29]
        # self.id_egi = self.list_parameter_db_flight_block[30]
        self.id_shp = self.list_parameter_db_flight_block[31]
        ssh = self.list_parameter_db_flight_block[32]
        self.min_value_ground_collision = 10.0
        self.max_value_obstacles_collision = ssh
        # self.gpa = self.list_parameter_db_flight_block[33]
        fitAxis = self.list_parameter_db_flight_block[34]  # old field "id_wae"
        # self.wal = self.list_parameter_db_flight_block[35]
        self.was = self.list_parameter_db_flight_block[36]
        # self.id_process_st = self.list_parameter_db_flight_block[37]
        number_points_by_footprint_side = self.list_parameter_db_flight_block[38]
        cam_id_mounting_type = self.list_parameter_db_flight_block[39]
        # self.id_type_gimbel_mount = self.list_parameter_db_flight_block[40]
        # self.offset_omega = self.list_parameter_db_flight_block[41]
        # self.offset_phi = self.list_parameter_db_flight_block[42]
        # self.offset_kappa = self.list_parameter_db_flight_block[43]
        average_height_object = self.list_parameter_db_flight_block[44]

        if (id_lnd == -1 and id_tof == -1):  # no se ha seleccionado punto de despegue
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Select takeoff point in the corresponding combo",
                                                Qgis.Critical,
                                                10)
            return False

        # parámetros de la cámara
        self.get_parameter_db_camera()
        cam_info_value = self.str_cod_camera + ","
        cam_info_value += str(self.rows_digital_sensor) + "x"
        cam_info_value += str(self.columns_digital_sensor) + ","
        cam_info_value += str(self.focal * 1000) + ","
        cam_info_value += str(self.geometric_resolution * 1000)

        """
        str_msg_log = "Recovered input parameters stored on the BD SpatiaLite"
        QgsMessageLog.logMessage(str_msg_log,c.CONST_PLIPUAV_TITLE,QgsMessageLog.INFO)
        """
        self.progress_dialog.enabled_suprocess(False)
        str_process_text = "Recovered input parameters stored on the BD SpatiaLite"
        self.progress_dialog.insert_text(0, str_process_text)
        QCoreApplication.processEvents()

        # recopilación de otras variables
        """
        Tolerancia angular en el paralelismo entre pasadas.
        Es la máxima diferencia que puede existir en el azimut de dos pasadastakeoff_height
        para que sean consideradas como paralelas
        """
        # parallel_strips_angular_tolerance = c.CONST_PARAMETER_PARALLEL_STRIPS_ANGULAR_TOLERANCE_DEFAULT_VALUE * CONST_PI / 180

        """
        Tolerancia en el desvío angular entre imágenes consecutivas de una pasada.
        Si la diferencia en el azimut de dos imágenes consecutivas es mayor que este valor
        se interrumpe la pasada, fraccionándose en subpasadas.
        """
        angular_strips_tolerance = c.CONST_PARAMETER_PARALLEL_STRIPS_ANGULAR_TOLERANCE_DEFAULT_VALUE * CONST_PI / 180

        """
        Tolerancia lineal en la variación de la base entre imágenes consecutivas de una pasada.
        Se expresa en tanto por cien respecto de la base media en la pasada
        """
        linear_strips_tolerance = c.CONST_STRIPS_LINEAR_TOLERANCE_DEFAULT_VALUE

        # control de existencia del fichero de resultados
        if len(self.path_file_results) == 0:
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "Path filename is empty",
                                                Qgis.Critical,
                                                10)
            return False

        self.file_results = open(self.path_file_results, "a")

        # salida a fichero others parameters
        self.msg_file_results = "\n5.- OTHERS INPUT PARAMETERS\n"
        # en vuelo lineal no se utiliza este parámetro
        self.msg_file_results += "\t- Angular strips tolerance: " + str(angular_strips_tolerance) + " RAD\n"
        self.msg_file_results += "\t- Linear strips tolerance: " + str(linear_strips_tolerance) + " %.\n\n"
        self.file_results.writelines(self.msg_file_results)

        # obtiene cadena wkt del punto de despegue 
        str_wkt_geom_tof_point = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                           c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                                                           "the_geom",
                                                                           "name_display_table",
                                                                           id_tof)

        # salida a fichero de geometrías wkt de capas vectoriales        
        self.msg_file_results = "6.- VECTOR LAYERS (WKT geometry)\n"
        self.msg_file_results += "\t- Takeoff point (id. " + str_id_tof + "): " + str_wkt_geom_tof_point + "\n"

        # obtiene cadena wkt del punto de aterrizaje        
        if id_lnd == -1:  # caso 1: punto de despegue (str_id_lnd == -1)
            str_wkt_geom_lnd_point = str_wkt_geom_tof_point
            self.msg_file_results += "\t- Landing point (Takeoff point id. " + str_id_tof + "): " + str_wkt_geom_lnd_point + "\n"

        if id_lnd == 0:  # caso 2: end point (str_id_lnd == 0)
            # TODO: conseguir cadena wkt
            self.msg_file_results += "\t- Landing point (End point)"

        if id_lnd > 0:  # caso 3: punto especificado por el usuario en capa SpatiaLite
            str_wkt_geom_lnd_point = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                               c.CONST_PFLIPUAV_LAYER_LANDING_POINT,
                                                                               "the_geom", "name_display_table",
                                                                               id_lnd)
            self.msg_file_results += "\t- Landing point (id. " + str_id_lnd + "): " + str_wkt_geom_lnd_point + "\n"

        # conexión con la base de datos
        con_db_project = self.db_op.connection_sqlite(self.path_db_project)
        cursor_db_project = con_db_project.cursor()

        # ejecuta consulta para obtener los datos         
        str_sql = "SELECT * FROM flight_block_c_axis WHERE cod_flight_block = '" + self.str_code_flight_block + "';"
        cursor_db_project.execute(str_sql)

        num_axis = 0  # contador para el número de ejes a procesar
        axis_wkt = []  # contenedor para almacenar el par str id_axis - cadena wkt del axis

        for row in cursor_db_project.fetchall():
            id_axis = row[2]
            str_wkt_geom_axis_linestring = self.q3_api_op.get_wkt_geom_by_feature_id(self.path_db_project,
                                                                                     c.CONST_PFLIPUAV_LAYER_AXIS,
                                                                                     "the_geom",
                                                                                     "name_display_table",
                                                                                     id_axis)
            str_id_axis = str(id_axis)
            self.msg_file_results += "\t- Axis (id." + str_id_axis + "): " + str_wkt_geom_axis_linestring + "\n\n"
            axis_wkt.append(str_id_axis)
            axis_wkt.append(str_wkt_geom_axis_linestring)
            num_axis = num_axis + 1

        con_db_project.close()  # cierra la base de datos

        self.file_results.writelines(self.msg_file_results)  # salida a fichero de los geometry vector layers

        # lectura de parámetros del sensor según el programa c++

        # UAV yaw attitude. angle_advanced_columns_to_axis_flight. 20180324 corregido. Era justo al revés.
        if cam_id_mounting_type == 1:  # 1.- -90 DEG. x forward direction (x columnas avance). Currently n/a
            angle_advanced_columns_to_axis_flight = CONST_PI / 2.0
            image_size_advanced_direction = self.columns_digital_sensor * self.geometric_resolution
        if cam_id_mounting_type == 3:  # 3.- 0 DEG y forward direction (y filas avance)
            angle_advanced_columns_to_axis_flight = 0.0
            image_size_advanced_direction = self.rows_digital_sensor * self.geometric_resolution

        # format image
        if self.rows_digital_sensor > self.columns_digital_sensor:
            format_image = self.rows_digital_sensor
        else:
            format_image = self.columns_digital_sensor

        # no se utiliza ...        
        # image_size = format_image * self.geometric_resolution

        advanced_in_column = True # 20180325. Currently n/a. TODO: Se podría eliminar y el siguiente if
        image_size_longitudinal_direction = self.columns_digital_sensor * self.geometric_resolution
        image_size_transversal_direction = self.rows_digital_sensor * self.geometric_resolution

        if (fabs(self.columns_digital_sensor * self.geometric_resolution - image_size_advanced_direction) > 0.1 * self.geometric_resolution):
            advanced_in_column = False
            image_size_longitudinal_direction = self.rows_digital_sensor * self.geometric_resolution
            image_size_transversal_direction = self.columns_digital_sensor * self.geometric_resolution

        advanced_direction_fov = 2.0 * atan(image_size_longitudinal_direction / (2.0 * self.focal))
        orthogonal_advanced_direction_fov = 2.0 * atan(image_size_transversal_direction / (2.0 * self.focal))
        advanced_direction_fov_deg = advanced_direction_fov * 180.0 / CONST_PI
        orthogonal_advanced_direction_fov_def = orthogonal_advanced_direction_fov * 180.0 / CONST_PI

        # aqui programa c++ lectura Gsd y Tolerancia de las especificaciones técnicas

        max_value_gsd = gsd * (1 + gsd_tolerance)
        # Corregido por Carlos 20150502
        # Se eliminan las siguientes fórmulas que restaban erróneamente la precisión GPS a la altura de vuelo teórica.
        # increment_gsd_by_error_HGps = self.geometric_resolution / self.focal * gps_precision
        # gsd = gsd - increment_gsd_by_error_HGps

        terrain_max_image_size = format_image * gsd
        if (advanced_in_column):
            terrain_advanced_image_size = self.columns_digital_sensor * gsd
            terrain_transverse_image_size = self.rows_digital_sensor * gsd
            longitudinal_rotation_omega_phi_precision = phi_precision
            transversal_rotation_omega_phi_precision = omega_precision
        else:
            terrain_advanced_image_size = self.rows_digital_sensor * gsd
            terrain_transverse_image_size = self.columns_digital_sensor * gsd
            longitudinal_rotation_omega_phi_precision = omega_precision
            transversal_rotation_omega_phi_precision = phi_precision

        image_scale = self.geometric_resolution / gsd
        den_image_scale = 1.0 / image_scale
        height_of_flight = self.focal / image_scale
        # se comenta la siguiente línea de código porque gsd_tolerance puede ser igual a cero y el valor de la variable calculada no se utiliza hacia abajo
        # image_scale_tolerance = self.geometric_resolution / gsd_tolerance
        # H=f*gsd/gr -> derivando con respecto a gsd -> dH=f/gr*d_gsd
        height_of_flight_tolerance = self.focal / self.geometric_resolution * gsd_tolerance * gsd  # porque gsdTolerance está en tpu

        # aquí programa C++ lee recubrimiento longitudinal de las especificaciones técnicas
        longitudinal_covering_tolerance = c.CONST_LONGITUDINAL_CONVERING_TOLERANCE / 100.0  # esta operacion no tiene sentido -> la CONST = 0)
        longitudinal_convering = overlap_fwd * (1.0 + longitudinal_covering_tolerance)  # la tolerancia está en tanto por uno del valor
        # (moved to next if) # dif_terrain_advanced_image_size_by_gps_precision = image_size_longitudinal_direction / self.focal * gps_precision # Efecto altimétrico

        # Cálculo del efecto planimétrico de la incertidumbre GPS. MNodificación Carlos 20150413
        # Corrección de error en fórmula. 20150418
        # La precisión GPS debe tratarse en términos relativos y en función del problema que puede plantear al factor B/H
        if (overlap_fwd < 0.62):  # Se aplica la incertidumbre GPS de forma lineal
            dif_terrain_advanced_image_size_by_gps_precision = image_size_longitudinal_direction / self.focal * gps_precision  # Efecto altimétrico
            dif_terrain_advanced_image_size_by_gps_precision += (gps_precision * sqrt(2.0))
        if (overlap_fwd >= 0.62):  # Se aplica una incertidumbre GPS con reducción exponencial para recubrimiento >62
            relative_gps_precision_overlap_fwd_related = 1 + (((overlap_fwd * 100) - 62) / 12) ** 4
            dif_terrain_advanced_image_size_by_gps_precision = image_size_longitudinal_direction / self.focal * (
            gps_precision / relative_gps_precision_overlap_fwd_related)  # Efecto altimétrico
            dif_terrain_advanced_image_size_by_gps_precision += ((gps_precision * sqrt(2.0)) / relative_gps_precision_overlap_fwd_related)
        increment_longitudinal_covering_by_gps_precision = dif_terrain_advanced_image_size_by_gps_precision / terrain_advanced_image_size
        longitudinal_covering = longitudinal_convering + increment_longitudinal_covering_by_gps_precision  # La tolerancia está en tanto por uno del valor

        decrement_image_size_by_rotation_omega_phi_precision = image_size_longitudinal_direction / 2.0 - self.focal * (
        tan(advanced_direction_fov / 2.0 - longitudinal_rotation_omega_phi_precision))
        dif_terrain_advanced_image_size_by_rotation_omega_phi_precision = height_of_flight / self.focal * decrement_image_size_by_rotation_omega_phi_precision
        increment_longitudinal_covering_by_rotation_omega_phi_precision = dif_terrain_advanced_image_size_by_rotation_omega_phi_precision / terrain_advanced_image_size
        longitudinal_covering = longitudinal_covering + increment_longitudinal_covering_by_rotation_omega_phi_precision  # La tolerancia está en tanto por uno del valor

        decrement_image_size_by_rotation_kappa_precision = image_size_longitudinal_direction / 2.0 \
                                                           - image_size_longitudinal_direction / 2.0 * cos(kappa_precision)
        dif_terrain_advanced_image_size_by_rotation_kappa_precision = height_of_flight / self.focal * decrement_image_size_by_rotation_kappa_precision
        increment_longitudinal_covering_by_rotation_kappa_precision = dif_terrain_advanced_image_size_by_rotation_kappa_precision / terrain_advanced_image_size
        longitudinal_covering = longitudinal_covering + increment_longitudinal_covering_by_rotation_kappa_precision  # La tolerancia está en tanto por uno del valor

        if (longitudinal_covering > 0.95):  # evita que el recubrimiento longitudinal real supere el 95%
            longitudinal_covering = 0.95

        base = 1 - longitudinal_covering  # Overlaps calculated in terms of GPS and INS tolerances and errors
        theoretical_base_length = base * terrain_advanced_image_size
        # Ampliacion de la zona por efecto del error del GPS
        # zoneIncrementByGpsPrecision=gpsPrecision*sqrt(2.0)
        zone_increment = lineal_segments_enlargement

        # aqui programa C++ detecta las zonas a planificar 

        """
        str_msg_log = "Number of axis read in SpatiaLite database: " + str(num_axis)
        QgsMessageLog.logMessage(str_msg_log,c.CONST_PLIPUAV_TITLE,QgsMessageLog.INFO)
        """
        number_of_strips = 0
        precision = c.CONST_PROJECTION_PRECISION_FRAMES

        # TODO: hacerlo con la librería de python import csv
        # self.msg_file_results_csv = "Zona;Pasada;Imagen;CoorX;CoorY;HOrto;IncH.Despegue\n"
        self.file_results_csv = open(self.path_file_results_csv, "w")
        # self.file_results_csv.writelines(self.msg_file_results_csv)

        # rlayer con el DTM
        fileName = str_dtm_path  # extraido del campo correspondiente de la BD
        fileInfo = QFileInfo(fileName)
        baseName = fileInfo.baseName()
        # TODO: aquí pide el CRS del MDT. Ver si se puede meter por código
        rlayer = QgsRasterLayer(fileName, baseName)

        # check rlayer cubre toda la zona
        qgsgeom_axis = QgsGeometry.fromWkt(str_wkt_geom_axis_linestring)
        qgsgeom_buffer_axis = None
        if qgis_version_second_number < qgis_version_second_number_change_buffer_parameters:
            qgsgeom_buffer_axis = qgsgeom_axis.buffer(terrain_transverse_image_size, 5, 2, 2, 100)
        else:
            qgsgeom_buffer_axis = qgsgeom_axis.buffer(terrain_transverse_image_size,
                                                      5,
                                                      Qgis.EndCapStyle.Flat,
                                                      Qgis.JoinStyle.Miter,
                                                      100)
        scale_factor_bb_zone = 1.0  # 20180403. En caso de terrenos muy abruptos y ángulos omega grandes, factor de escala 4
        if not self.q3_api_op.check_rlayer_contains_vector_zone(rlayer,
                                                                qgsgeom_buffer_axis,
                                                                scale_factor_bb_zone):
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                "DTM raster layer [%s] doesn't contain axis bounding box" % str_dtm_path,
                                                Qgis.Critical,
                                                10)
            self.file_results.close()
            self.file_results_csv.close()
            return False

        """
        if not rlayer.isValid():
            self.iface.messageBar().pushMessage(c.CONST_PLIPUAV_TITLE,
                                                "Raster file " + fileName + " is not valid",
                                                Qgis.Critical,
                                                10)
            self.file_results.close()
            self.file_results_csv.close()
            return False
        """

        # cálculo de los pasos de malla
        step_x_dtm = rlayer.rasterUnitsPerPixelX()  # debe ser positivo
        step_y_dtm = -rlayer.rasterUnitsPerPixelY()  # debe ser negativo

        dtm_precision = step_x_dtm / 2.0  # El programa C++ obtenía este valor como la mitad del paso de malla del MDT más preciso
        linear_tolerance = 1.0 / 2.0 * dtm_precision  # La mitad de la precisión del MDT

        # coordenadas del tof 
        list_points_current_tof = self.q3_api_op.get_list_vertex_by_id_entity(self.path_db_project,
                                                                              c.CONST_PFLIPUAV_LAYER_TAKEOFF_POINT,
                                                                              "the_geom",
                                                                              "name_display_table",
                                                                              id_tof)
        x_takeoff = list_points_current_tof[0]
        y_takeoff = list_points_current_tof[1]

        z_dtm_takeoff_interpolate = self.q3_api_op.get_value_from_raster_file_interpolation(rlayer,
                                                                                            x_takeoff,
                                                                                            y_takeoff,
                                                                                            self.int_PostgisCrsId_code_pry_mflip)

        self.msg_file_results = "\n*** FLIGHT BLOCK PLANNING RESULTS ***\n\n"
        self.file_results.write(self.msg_file_results)

        # self.msg_file_results = "3.- Definition takeoff point:\n"
        # self.msg_file_results += "\t- First coordinate .......................................: " + str(x_takeoff) + "\n"
        # self.msg_file_results += "\t- Second coordinate ......................................: " + str(y_takeoff) + "\n"
        # self.msg_file_results += "\t- Z DTM interpolate ......................................: " + str(z_dtm_takeoff_interpolate) + "\n"
        # self.file_results.writelines(self.msg_file_results)

        # coordenadas del lnd            
        # self.msg_file_results = "4.- Definition landing point:\n"

        if id_lnd == -1:  # caso 1: punto de despegue (str_id_lnd == -1)
            x_landing = x_takeoff
            y_landing = y_takeoff
            # self.msg_file_results += "\t- Type of selection of landing point .......................: Takeoff point\n"

        if id_lnd > 0:  # caso 3: punto especificado por el usuario en capa SpatiaLite
            list_points_current_lnd = self.q3_api_op.get_list_vertex_by_id_entity(self.path_db_project,
                                                                                  c.CONST_PFLIPUAV_LAYER_LANDING_POINT,
                                                                                  "the_geom",
                                                                                  "name_display_table",
                                                                                  id_lnd)
            x_landing = list_points_current_lnd[0]
            y_landing = list_points_current_lnd[1]
            # self.msg_file_results += "\t- Type of selection of landing point .......................: From GIS SpatiaLite layer\n"
            # self.msg_file_results += "\t\t- First coordinate .........................................: " + str(x_landing) + "\n"
            # self.msg_file_results += "\t\t- Second coordinate ........................................: " + str(y_landing) + "\n"

        # if id_lnd == 0:
        #     self.msg_file_results += "\t- Type of selection of landing point .......................: End point\n"

        z_dtm_lnd_interpolate = self.q3_api_op.get_value_from_raster_file_interpolation(rlayer,
                                                                                        x_landing,
                                                                                        y_landing,
                                                                                        self.int_PostgisCrsId_code_pry_mflip)

        # self.msg_file_results += "\t- Z DTM interpolate of landing point ................................: " + str(z_dtm_lnd_interpolate) + "\n\n"
        # self.file_results.writelines(self.msg_file_results)

        # *** Formación de las huellas de las imágenes, con el MDT original                            
        image_x = []  # QVector<double>
        image_y = []  # QVector<double>

        # puntos de la imagen:
        # 1-2-3
        # 8-0-4
        # 7-6-5

        if (number_points_by_footprint_side < 3):
            number_points_by_footprint_side = 3

        # Primero se introducen las coordenadas dadas por el formato de la imagen
        # Punto 0
        image_x.append(0.0)
        image_y.append(0.0)

        # Borde superior, de izquierda a derecha, salvo el último punto (esquina superior derecha).
        first_column = - self.columns_digital_sensor / 2.0
        first_row = self.rows_digital_sensor / 2.0

        for i in range(number_points_by_footprint_side - 1):
            column = first_column + i * (self.columns_digital_sensor / (number_points_by_footprint_side - 1))
            row = first_row
            image_x.append(column)
            image_y.append(row)

        # Borde derecho, de arriba a abajo, salvo el último punto (esquina inferior derecha).
        first_column = self.columns_digital_sensor / 2.0
        first_row = self.rows_digital_sensor / 2.0
        for i in range(number_points_by_footprint_side - 1):
            column = first_column
            row = first_row - i * (self.rows_digital_sensor / (number_points_by_footprint_side - 1))
            image_x.append(column)
            image_y.append(row)

            # Borde inferior, de derecha a izquierda, salvo el último punto (esquina inferior izquierda).
        first_column = self.columns_digital_sensor / 2.0
        first_row = -self.rows_digital_sensor / 2.0
        for i in range(number_points_by_footprint_side - 1):
            column = first_column - i * (self.columns_digital_sensor / (number_points_by_footprint_side - 1))
            row = first_row
            image_x.append(column)
            image_y.append(row)

        # Borde izquierdo, de abajo a arriba, salvo el último punto (esquina superior izquierda).
        first_column = - self.columns_digital_sensor / 2.0
        first_row = - self.rows_digital_sensor / 2.0
        for i in range(number_points_by_footprint_side - 1):
            column = first_column
            row = first_row + i * (self.rows_digital_sensor / (number_points_by_footprint_side - 1))
            image_x.append(column)
            image_y.append(row)

        number_of_points = len(image_x)

        # Se pasan las coordenadas a metros
        for i in range(number_of_points):
            image_x[i] = image_x[i] * self.geometric_resolution - self.xppa
            image_y[i] = image_y[i] * self.geometric_resolution - self.yppa

        print_precision = 4
        formateo = '.' + str(print_precision) + 'f'

        # creación memory layer amplied axis origin point
        str_type_geom_with_epsg_code = "Point?crs=" + self.str_authid_code_pry_mflip
        memory_layer_axis_amplied_origin_points = QgsVectorLayer(str_type_geom_with_epsg_code,
                                                                 c.CONST_PFLIPUAV_MEMORY_LAYER_ORIGIN_POINT,
                                                                 "memory")
        id_segment_fieldname = "id_segment"
        memory_layer_axis_amplied_origin_points.startEditing()
        memory_layer_axis_amplied_origin_points.addAttribute(QgsField(id_segment_fieldname, QVariant.Int))
        memory_layer_axis_amplied_origin_points.commitChanges()

        path_simbol_axis_amplied_origin_points_memory_layer = self.path_plugin + '/templates/qgis_templates/style_amplied_axis_origin_point.qml'
        memory_layer_axis_amplied_origin_points.loadNamedStyle(path_simbol_axis_amplied_origin_points_memory_layer)
        self.iface.layerTreeView().refreshLayerSymbology(memory_layer_axis_amplied_origin_points.id())

        # creación memory layer amplied axis end point
        str_type_geom_with_epsg_code = "Point?crs=" + self.str_authid_code_pry_mflip
        memory_layer_axis_amplied_end_points = QgsVectorLayer(str_type_geom_with_epsg_code,
                                                              c.CONST_PFLIPUAV_MEMORY_LAYER_END_POINTS,
                                                              "memory")
        id_segment_fieldname = "id_segment"
        memory_layer_axis_amplied_end_points.startEditing()
        memory_layer_axis_amplied_end_points.addAttribute(QgsField(id_segment_fieldname, QVariant.Int))
        memory_layer_axis_amplied_end_points.commitChanges()

        path_simbol_axis_amplied_end_points_memory_layer = self.path_plugin + '/templates/qgis_templates/style_amplied_axis_end_point.qml'
        memory_layer_axis_amplied_end_points.loadNamedStyle(path_simbol_axis_amplied_end_points_memory_layer)
        self.iface.layerTreeView().refreshLayerSymbology(memory_layer_axis_amplied_end_points.id())

        # creación de memory layer way points                
        str_type_geom_with_epsg_code = "Point?crs=" + self.str_authid_code_pry_mflip
        memory_layer_way_points = QgsVectorLayer(str_type_geom_with_epsg_code,
                                                 c.CONST_PFLIPUAV_MEMORY_LAYER_WAYPOINTS,
                                                 "memory")
        cod_flight_block_fieldname = "cod_flight_block"
        id_axis_fieldname = "id_axis"
        id_segment_fieldname = "id_segment"
        id_number_shot_fieldname = "number_shot"
        x_waypoint_fieldname = "x_waypoint"
        y_waypoint_fieldname = "y_waypoint"
        dtm_height_fieldname = "dtm_height"
        crs_code_fieldname = "crs_code"
        h_fly_fieldname = "h_fly"
        id_shot_fieldname = "id_shot"
        memory_layer_way_points.startEditing()
        memory_layer_way_points.addAttribute(QgsField(cod_flight_block_fieldname, QVariant.String))
        memory_layer_way_points.addAttribute(QgsField(id_axis_fieldname, QVariant.Int))
        memory_layer_way_points.addAttribute(QgsField(id_segment_fieldname, QVariant.Int))
        memory_layer_way_points.addAttribute(QgsField(id_number_shot_fieldname, QVariant.Int))
        memory_layer_way_points.addAttribute(QgsField(x_waypoint_fieldname, QVariant.Double))
        memory_layer_way_points.addAttribute(QgsField(y_waypoint_fieldname, QVariant.Double))
        memory_layer_way_points.addAttribute(QgsField(crs_code_fieldname, QVariant.String))
        memory_layer_way_points.addAttribute(QgsField(dtm_height_fieldname, QVariant.Double))
        memory_layer_way_points.addAttribute(QgsField(h_fly_fieldname, QVariant.Double))
        memory_layer_way_points.addAttribute(QgsField(id_shot_fieldname, QVariant.Int))

        memory_layer_way_points.commitChanges()

        path_simbol_way_points_memory_layer = self.path_plugin + '/templates/qgis_templates/style_waypoints_memory_layer.qml'
        memory_layer_way_points.loadNamedStyle(path_simbol_way_points_memory_layer)
        self.iface.layerTreeView().refreshLayerSymbology(memory_layer_way_points.id())

        # creación de memory layer strips
        str_type_geom_with_epsg_code = "Linestring?crs=" + self.str_authid_code_pry_mflip
        memory_layer_strips = QgsVectorLayer(str_type_geom_with_epsg_code,
                                             c.CONST_PFLIPUAV_MEMORY_LAYER_STRIPS,
                                             "memory")

        cod_flight_block_fieldname = "cod_flight_block"
        id_axis_fieldname = "id_axis"
        id_segment_fieldname = "id_segment"
        g3d_axis_wkt_m_fieldname = "g3d_axis_wkt_m"
        crs_code_fieldname = "crs_code"
        id_strip_fieldname = "id_strip"
        lenght_fielname = "lenght"
        num_imgs_fieldname = "num_imgs"
        azimuth_fieldname = "azimuth"

        memory_layer_strips.startEditing()
        memory_layer_strips.addAttribute(QgsField(cod_flight_block_fieldname, QVariant.String))
        memory_layer_strips.addAttribute(QgsField(id_axis_fieldname, QVariant.Int))
        memory_layer_strips.addAttribute(QgsField(id_segment_fieldname, QVariant.Int))
        memory_layer_strips.addAttribute(QgsField(g3d_axis_wkt_m_fieldname, QVariant.String))
        memory_layer_strips.addAttribute(QgsField(crs_code_fieldname, QVariant.String))
        memory_layer_strips.addAttribute(QgsField(id_strip_fieldname, QVariant.String))
        memory_layer_strips.addAttribute(QgsField(lenght_fielname, QVariant.Double))
        memory_layer_strips.addAttribute(QgsField(num_imgs_fieldname, QVariant.Int))
        memory_layer_strips.addAttribute(QgsField(azimuth_fieldname, QVariant.Double))
        memory_layer_strips.commitChanges()

        path_simbol_strips_memory_layer = self.path_plugin + '/templates/qgis_templates/style_strips_geom_3d_axis_m_memory_layer.qml'
        memory_layer_strips.loadNamedStyle(path_simbol_strips_memory_layer)
        self.iface.layerTreeView().refreshLayerSymbology(memory_layer_strips.id())

        # creación de memory layer footprint (image)
        str_type_geom_with_epsg_code = "Polygon?crs=" + self.str_authid_code_pry_mflip
        memory_layer_footprints = QgsVectorLayer(str_type_geom_with_epsg_code,
                                                 c.CONST_PFLIPUAV_MEMORY_LAYER_FOOTPRNTS,
                                                 "memory")

        cod_flight_block_fieldname = "cod_flight_block"
        id_axis_fieldname = "id_axis"
        # strip_id_fieldname = "strip_id"
        id_segment_fieldname = "id_segment"
        id_number_shot_fieldname = "number_shot"
        id_image_fieldname = "id_image"
        # wkt_footprint_theoretical_fieldname = "wkt_footprint_theoretical"
        wkt_footprint_fieldname = "wkt_footprint"
        wkt_footprint_3d_fieldname = "wkt_footprint_3D"
        wkt_g3d_pc_fieldname = "wkt_g3d_pc"
        wkt_g3d_ndir_fieldname = "wkt_g3d_ppa_dtm"
        crs_code_fieldname = "crs_code"
        azimuth_fieldname = "azimuth"
        cam_info_fieldname = "sensor_info"
        pc_fc_fieldname = "pc_fc"
        pc_sc_fieldname = "pc_sc"
        h_pc_fieldname = "pc_H"
        yaw_fieldname = "yaw"
        pitch_fieldname = "pitch"
        roll_fieldname = "roll"
        gsd_theo_fieldname = "gsd_theo"
        gsd_pc_fieldname = "gsd_pc"
        gsd_max_fieldname = "gsd_max"
        gsd_mean_fieldname = "gsd_mean"
        gsd_min_fieldname = "gsd_min"
        h_max_fieldname = "H_max"
        h_min_fieldname = "H_min"
        h_nadir_fieldname = "H_nadir"
        ppa_dtm_fc_fieldname = "ppa_dtm_fc"
        ppa_dtm_sc_fieldname = "ppa_dtm_sc"
        ppa_dtm_h_fieldname = "ppa_dtm_H"
        height_AGL_fieldname = "height_AGL"
        dist_ppa_dtm_fieldname = "Dist_ppa_dtm"

        memory_layer_footprints.startEditing()
        memory_layer_footprints.addAttribute(QgsField(cod_flight_block_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(id_axis_fieldname, QVariant.Int))
        #memory_layer_footprints.addAttribute(QgsField(strip_id_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(id_segment_fieldname, QVariant.Int)) # se corresponde con strip_cd del vuelo zonal
        memory_layer_footprints.addAttribute(QgsField(id_number_shot_fieldname, QVariant.Int))
        memory_layer_footprints.addAttribute(QgsField(id_image_fieldname, QVariant.String))
        # memory_layer_footprints.addAttribute(QgsField(wkt_footprint_theoretical_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(wkt_footprint_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(wkt_footprint_3d_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(wkt_g3d_pc_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(wkt_g3d_ndir_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(crs_code_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(azimuth_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(cam_info_fieldname, QVariant.String))
        memory_layer_footprints.addAttribute(QgsField(pc_fc_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(pc_sc_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(h_pc_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(yaw_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(pitch_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(roll_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(gsd_theo_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(gsd_pc_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(gsd_max_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(gsd_mean_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(gsd_min_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(h_max_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(h_min_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(h_nadir_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(ppa_dtm_fc_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(ppa_dtm_sc_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(ppa_dtm_h_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(height_AGL_fieldname, QVariant.Double))
        memory_layer_footprints.addAttribute(QgsField(dist_ppa_dtm_fieldname, QVariant.Double))
        memory_layer_footprints.commitChanges()

        path_simbol_footprints_memory_layer = self.path_plugin + '/templates/qgis_templates/style_images_geom_2d_fp_m.qml'
        memory_layer_footprints.loadNamedStyle(path_simbol_footprints_memory_layer)
        self.iface.layerTreeView().refreshLayerSymbology(memory_layer_footprints.id())

        # creación de memory layer stereo pairs
        str_type_geom_with_epsg_code = "Polygon?crs=" + self.str_authid_code_pry_mflip
        memory_layer_stereopairs = QgsVectorLayer(str_type_geom_with_epsg_code,
                                                  c.CONST_PFLIPUAV_MEMORY_LAYER_STEREO_PAIRS,
                                                  "memory")

        cod_flight_block_fieldname = "cod_flight_block"
        id_axis_fieldname = "id_axis"
        id_segment_fieldname = "id_segment"
        id_stereopair_fieldname = "id_stereopair"
        id_img_before_fieldname = "id_img_before"
        id_img_after_fieldname = "id_img_after"
        cd_img_before_fieldname = "cd_img_before"
        cd_img_after_fieldname = "cd_img_after"
        wkt_stereopair_fieldname = "g2d_fp_wkt_m"
        crs_code_fieldname = "crs_code"
        area_intersection_fieldname = "area_intersection"
        area_image_before_fieldname = "area_image_before"
        area_image_after_fieldname = "area_image_after"
        rec_long_image_before_fieldname = "rec_long_image_before"
        rec_long_image_after_fieldname = "rec_long_image_after"

        memory_layer_stereopairs.startEditing()
        memory_layer_stereopairs.addAttribute(QgsField(cod_flight_block_fieldname, QVariant.String))
        memory_layer_stereopairs.addAttribute(QgsField(id_axis_fieldname, QVariant.Int))
        memory_layer_stereopairs.addAttribute(QgsField(id_segment_fieldname, QVariant.Int))
        memory_layer_stereopairs.addAttribute(QgsField(id_stereopair_fieldname, QVariant.String))
        memory_layer_stereopairs.addAttribute(QgsField(id_img_before_fieldname, QVariant.String))
        memory_layer_stereopairs.addAttribute(QgsField(id_img_after_fieldname, QVariant.String))
        memory_layer_stereopairs.addAttribute(QgsField(cd_img_before_fieldname, QVariant.Int))
        memory_layer_stereopairs.addAttribute(QgsField(cd_img_after_fieldname, QVariant.Int))
        memory_layer_stereopairs.addAttribute(QgsField(wkt_stereopair_fieldname, QVariant.String))
        memory_layer_stereopairs.addAttribute(QgsField(crs_code_fieldname, QVariant.String))
        memory_layer_stereopairs.addAttribute(QgsField(area_intersection_fieldname, QVariant.Double))
        memory_layer_stereopairs.addAttribute(QgsField(area_image_before_fieldname, QVariant.Double))
        memory_layer_stereopairs.addAttribute(QgsField(area_image_after_fieldname, QVariant.Double))
        memory_layer_stereopairs.addAttribute(QgsField(rec_long_image_before_fieldname, QVariant.Double))
        memory_layer_stereopairs.addAttribute(QgsField(rec_long_image_after_fieldname, QVariant.Double))
        memory_layer_stereopairs.commitChanges()

        path_simbol_stereopairs_memory_layer = self.path_plugin + '/templates/qgis_templates/style_stereo_pairs_geom_2d_fp_m.qml'
        memory_layer_stereopairs.loadNamedStyle(path_simbol_stereopairs_memory_layer)
        self.iface.layerTreeView().refreshLayerSymbology(memory_layer_stereopairs.id())

        # creación del grupo aux memory layers
        root = QgsProject.instance().layerTreeRoot()
        node_group_aux_memory_layers = root.insertGroup(0, c.CONST_PFLIPUAV_GROUP_OUPUT_MEMORY_GIS_LAYERS)

        # carga de las memory layers in order
        QgsProject.instance().addMapLayer(memory_layer_axis_amplied_origin_points, False)
        QgsProject.instance().addMapLayer(memory_layer_stereopairs, False)
        QgsProject.instance().addMapLayer(memory_layer_footprints, False)
        QgsProject.instance().addMapLayer(memory_layer_strips, False)
        QgsProject.instance().addMapLayer(memory_layer_way_points, False)
        QgsProject.instance().addMapLayer(memory_layer_axis_amplied_end_points, False)

        node_layer_origin_point = node_group_aux_memory_layers.addLayer(memory_layer_axis_amplied_origin_points)
        node_layer_waypoints = node_group_aux_memory_layers.addLayer(memory_layer_way_points)
        node_layer_strips = node_group_aux_memory_layers.addLayer(memory_layer_strips)
        node_layer_stereopairs_point = node_group_aux_memory_layers.addLayer(memory_layer_stereopairs)
        node_layer_footprints = node_group_aux_memory_layers.addLayer(memory_layer_footprints)
        node_layer_end_point = node_group_aux_memory_layers.addLayer(memory_layer_axis_amplied_end_points)

        # inicializa contenedores
        # list_axis = []
        # list_segments = []
        # list_height_projection_center_image_in_segment = []
        list_image_geometry_foot_prints_in_segment = []
        xLs = []  # Vector con las primeras coordenadas de los puntos de toma
        yLs = []  # Vector con las segundas coordenadas de los puntos de toma
        zLs = []  # Vector con las altitudes ortométrica de los puntos de toma

        image_codes_by_strip = {}  # QMap<QString,QVector<QString>
        dtm_height_image_by_strip = {}  # QMap<QString,QVector<double>
        height_over_ground_image_by_strip = {}  # QMap<QString,QVector<double>
        height_over_takeoff_image_by_strip = {}  # QMap<QString,QVector<double>
        height_projection_center_image_by_strip = {}  # QMap<QString,QVector<double>
        height_projection_center_image_by_strip_origin = {}  # QMap<QString,QVector<double>

        strip_codes = []  # QString
        diff_of_height_agl_max = []

        # empieza edición de capas en memoría
        memory_layer_way_points.startEditing()
        memory_layer_strips.startEditing()
        memory_layer_footprints.startEditing()
        memory_layer_stereopairs.startEditing()
        memory_layer_axis_amplied_origin_points.startEditing()
        memory_layer_axis_amplied_end_points.startEditing()

        # INICIO PROCESAMIENTO AXIS. PARA CADA EJE ...

        # inicializa la progress bar
        progressMessageBar = self.iface.messageBar().createMessage("Progress lineal...")
        progress = QProgressBar()
        default_style = "QProgressBar{" + "\n"
        default_style += "\ttext-align: center" + "\n"
        default_style += "}" + "\n"
        default_style += "QProgressBar::chunk {"+ "\n"
        default_style += "\tbackground-color: lightgrey;"
        default_style += "\twidth: 10 px;"
        default_style += "\tmargin: 1 px;"
        default_style += "}" + "\n"
        progress.setStyleSheet(default_style)
        progress.setMaximum(100)
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        self.iface.messageBar().pushWidget(progressMessageBar,
                                           Qgis.Info)

        # inicialización para mensaje de advertencia para puntos con riesgo de colisión con el suelo o con obstáculos
        control_msg_ground_collision_risk_AGL = False
        control_msg_obstacles_collision_risk_AGL = False
        control_msg_ground_collision_risk_TOF = False
        control_msg_obstacles_collision_risk_TOF = False
        str_list_points_ground_collision_risk_AGL = ""
        str_list_points_obstacles_collision_risk_AGL = ""
        str_list_points_ground_collision_risk_TOF = ""
        str_list_points_obstacles_collision_risk_TOF = ""

        for i in range(num_axis):
            indice_axis = i * 2
            str_current_id_axis = axis_wkt[indice_axis]
            str_current_axis_wkt = axis_wkt[indice_axis + 1]

            # obtención de lista de vértices del axis
            list_vertex_current_axis = self.q3_api_op.get_list_vertex_by_id_entity(self.path_db_project,
                                                                                   c.CONST_PFLIPUAV_LAYER_AXIS,
                                                                                   "the_geom",
                                                                                   "name_display_table",
                                                                                   str_current_id_axis)

            # current_axis_geometry = QgsGeometry.fromWkt(str_current_axis_wkt)  # obtención de QgsGeometry del axis

            self.progress_dialog.enabled_suprocess(False)
            str_process_text = "Processing axis [" + str_current_id_axis + "]"
            self.progress_dialog.insert_text(0, str_process_text)
            QCoreApplication.processEvents()

            # comparación del CRS de la capa de ejes con el CRS del proyecto MFLiP
            str_InternalCrsId_code_axis_layer = self.q3_api_op.get_crs_vector_layer(self.path_db_project,
                                                                                    c.CONST_PFLIPUAV_LAYER_AXIS,
                                                                                    "the_geom",
                                                                                    "name_display_table")

            if self.str_InternalCrsId_code_pry_mflip != str_InternalCrsId_code_axis_layer:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "CRS project and CRS layer axis are different",
                                                    Qgis.Critical,
                                                    10)
                self.file_results.close()
                self.file_results_csv.close()
                return False

            # TODO: comparación del CRS de la capa de tof y lnd con el CRS del proyecto MFLiP

            # comparación del CRS del mapcanvas vs. CRS del proyecto MFLiP
            qgs_current_crs_map_canvas = self.iface.mapCanvas().mapSettings().destinationCrs()  # devuelve un QgsCoordinateReferenceSystem con crs del mapcanvas
            str_InternalCrsId_code_current_crs_map_canvas = str(qgs_current_crs_map_canvas.srsid())
            if str_InternalCrsId_code_current_crs_map_canvas != str_InternalCrsId_code_axis_layer:
                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                    "CRS project PLIPUAV and CRS mapcanvas are different",
                                                    Qgis.Critical,
                                                    5)
                self.file_results.close()
                self.file_results_csv.close()
                return False

            # inicializa contadores bucle
            number_vertex_axis = len(list_vertex_current_axis)
            num_segment = 0
            qgs_polygon_geometry_stereoscopic_zone = None

            self.strip_g3d_axis_wkt_m_by_strip = []
            self.strip_g2d_ndax_wkt_by_strip = []
            self.strip_g3d_ndax_wkt_by_strip = []

            uav_images_by_segment = {}
            lst_jogs = []
            slope_vertical_breaks_in_strip = []  # double
            constant_slope_distance_in_WP = []
            dtm_height_image_in_axis = []

            constant_slope_distance = 0
            incHeight = 0
            num_shot_absolute = 1
            nis_absolute_previous = 0
            control_new_segment = True
            # control_int_vertex = False # 20190125: if True => vértice interior de un eje

            # *********************************************************
            # *** PROCESAMIENTO INICIAL DE GEOMETRIA DE FOTOCENTROS ***
            # *********************************************************
            # Inicio procesamiento por segmento (STRIP). Para cada segmento (Tramo de Linestring) ...
            for current_vertex in range(number_vertex_axis - 1):
                # progress bar
                time.sleep(0.2)
                percent = 20.0 * (float(current_vertex + 1) / (float(number_vertex_axis) - 1))
                # self.iface.mainWindow().statusBar().showMessage("Processed {} %".format(int(percent)))
                progress.setValue(round(percent))

                num_segment = num_segment + 1
                # self.msg_file_results = "\t- Definition segment code " + str(num_segment) + "\n"

                # progress dialog
                self.progress_dialog.enabled_suprocess(False)
                str_process_text = "Processing trajectory segment [" + str(num_segment) + "] ..."
                self.progress_dialog.insert_text(0, str_process_text)
                QCoreApplication.processEvents()

                # habilita subprocess
                self.progress_dialog.set_title_process(1, str_process_text)
                QCoreApplication.processEvents()
                self.progress_dialog.enabled_suprocess(True)

                str_process_text = "...Segment [" + str(num_segment) + "]..."
                self.progress_dialog.insert_text(1, str_process_text)
                QCoreApplication.processEvents()

                num_vertex_initial = current_vertex
                num_vertex_end = current_vertex + 1

                initial_point_segment = list_vertex_current_axis[num_vertex_initial]  # punto inicial
                end_point_segment = list_vertex_current_axis[num_vertex_end]  # punto final

                first_coordinate_begin_segment = initial_point_segment[0]  # x inicio
                second_coordinate_begin_segment = initial_point_segment[1]  # y inicio
                first_coordinate_end_segment = end_point_segment[0]  # x final
                second_coordinate_end_segment = end_point_segment[1]  # y fina
                # cálculo del azimuth directo e inverso del segmento
                # segment_azimuth_direct = 0.0
                state_error, segment_azimuth_direct = self.instanceGeodeticCalculations.azimuth(first_coordinate_begin_segment,
                                                                                                second_coordinate_begin_segment,
                                                                                                first_coordinate_end_segment,
                                                                                                second_coordinate_end_segment)
                if (state_error != CONST_GEODETIC_CALCULATIONS_NO_ERROR):
                    str_msg = "Failed azimuth calculation axis " + str_current_id_axis + "segment " + str(num_segment)
                    self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                        str_msg,
                                                        Qgis.Critical,
                                                        10)
                    # cierre ficheros de resultados .txt y .csv
                    self.file_results.close()
                    self.file_results_csv.close()
                    return False

                segment_distance = sqrt(pow(first_coordinate_begin_segment - first_coordinate_end_segment, 2.0) +
                                        pow(second_coordinate_begin_segment - second_coordinate_end_segment, 2.0))

                # crea listas para vértices por segmento
                image_codes_in_strip = []  # QString en C++
                base_lenght_in_WP =[]  # double
                dtm_height_image_in_strip = []  # double
                height_over_ground_image_in_strip = []  # double
                height_over_takeoff_image_in_strip = []  # double
                height_projection_center_image_in_strip = []  # double
                height_projection_center_image_in_strip_origin = []  # double

                # inicializa contadores bucle
                num_shot = 1
                distancia_acumulada = 0.0
                control_new_image = True
                sum_h_strip_fly = 0
                sum_h_strip_fly_atof = 0
                sum_distance_strip = 0
                sum_dist_height_strip = 0
                sum_dist2_strip = 0
                base_length = 0
                distance_to_origin = 0

                # INICIO PROCESAMIENTO PARA CADA WAYPOINT o SHOT (IMAGES) ...
                #while (segment_distance > distancia_acumulada) or num_shot == 2:
                while control_new_image:
                    str_process_text = "Num. WP: " + str(num_shot)
                    self.progress_dialog.insert_text(1, str_process_text)
                    QCoreApplication.processEvents()

                    # Calculating images projection centers ...
                    if fitAxis == 1:  # fit axis Enabled
                        if num_shot == 1 and current_vertex == 0:
                            distancia_acumulada = 0  # first shot = Initial vertex of the segment
                        elif num_shot == 1 and current_vertex > 0 and hold_time == 0:
                            distancia_acumulada += (base * terrain_advanced_image_size) - previous_base_length
                        else:
                            distancia_acumulada += base * terrain_advanced_image_size
                        # Condición que determina el último punto de segmento
                        if distancia_acumulada > segment_distance:
                            control_new_image = False
                    else:  # fit axis Disabled
                        if num_shot == 1:
                            distancia_acumulada = (0.5 - base) * terrain_advanced_image_size
                        else:
                            distancia_acumulada += base * terrain_advanced_image_size
                        # Condición que determina el último punto de segmento
                        if distancia_acumulada > segment_distance and not num_shot == 1:
                            control_new_image = False

                    # Condición que determina el último punto del eje
                    if not control_new_image and current_vertex == (number_vertex_axis - 2):
                        control_new_segment = False


                    if not control_new_image and fitAxis == 1:   # final segment shot & fit axis enabled
                        x_current_shot = first_coordinate_end_segment
                        y_current_shot = second_coordinate_end_segment
                    else:  # intermediate segment shot & fit axis disabled.
                        x_current_shot = first_coordinate_begin_segment + distancia_acumulada * sin(segment_azimuth_direct)
                        y_current_shot = second_coordinate_begin_segment + distancia_acumulada * cos(segment_azimuth_direct)

                    dtm_height_current_shot = self.q3_api_op.get_value_from_raster_file_interpolation(rlayer,
                                                                                                      x_current_shot,
                                                                                                      y_current_shot,
                                                                                                      self.int_PostgisCrsId_code_pry_mflip)
                    dtm_height_current_shot += average_height_object

                    image_codes_in_strip.append(num_shot)
                    xLs.append(x_current_shot)
                    yLs.append(y_current_shot)
                    dtm_height_image_in_strip.append(dtm_height_current_shot)
                    dtm_height_image_in_axis.append(dtm_height_current_shot)

                    h_fly_current_shot = dtm_height_current_shot + height_of_flight
                    image_height_of_flight = height_of_flight
                    nis_absolute = num_shot_absolute - 1
                    # Guarda lista con las altitudes de pasada originales (equivalentes a Tipo 1 con Toler.GSD = 0%)
                    height_projection_center_image_in_strip_origin.append(h_fly_current_shot)

                    if not num_segment == 1 or not num_shot == 1:
                        diff_h_fly_to_previous = fabs(h_fly_current_shot - h_fly_previous)
                        if diff_h_fly_to_previous < height_of_flight_tolerance:
                            h_fly_current_shot = h_fly_previous
                            image_height_of_flight = h_fly_current_shot - dtm_height_current_shot
                        incHeight = h_fly_current_shot - h_fly_previous
                        base_length = sqrt(pow(xLs[nis_absolute] - xLs[nis_absolute - 1], 2.0) +
                                           pow(yLs[nis_absolute] - yLs[nis_absolute - 1], 2.0))
                        constant_slope_distance += base_length

                    zLs.append(h_fly_current_shot)

                    # Calculo inicial. Valido para estrategia vertical 1
                    height_over_ground_image_in_strip.append(image_height_of_flight)
                    height_over_takeoff_image_in_strip.append(h_fly_current_shot - (z_dtm_takeoff_interpolate + takeoff_height))
                    height_projection_center_image_in_strip.append(h_fly_current_shot)

                    constant_slope_distance_in_WP.append(constant_slope_distance) # para estrategia vertical tipo 2 y 4
                    if id_trajectory_type == 2:  # 20170405: Simplified GSD & Tolerance Based
                        if incHeight != 0 or not control_new_segment:
                            vector_slope = incHeight / constant_slope_distance
                            slope_vertical_breaks = [nis_absolute, h_fly_current_shot, incHeight, constant_slope_distance, vector_slope]
                            slope_vertical_breaks_in_strip.append(slope_vertical_breaks)
                            constant_slope_distance = 0

                    if id_trajectory_type == 4:  # 20170405: Constant Slope
                        if not control_new_image:
                            incHeight = h_fly_current_shot - zLs[nis_absolute_previous]
                            vector_slope = incHeight / constant_slope_distance
                            slope_vertical_breaks = [nis_absolute, h_fly_current_shot, incHeight, constant_slope_distance, vector_slope]
                            slope_vertical_breaks_in_strip.append(slope_vertical_breaks)
                            nis_absolute_previous = nis_absolute
                            constant_slope_distance = 0

                    if id_trajectory_type == 3 or id_trajectory_type == 5:  # 20170406: Horizontal Averaged & Best Constant Slope
                        sum_h_strip_fly += h_fly_current_shot
                        sum_h_strip_fly_atof += h_fly_current_shot - (z_dtm_takeoff_interpolate + takeoff_height)
                        distance_to_origin += base_length
                        sum_distance_strip += distance_to_origin
                        sum_dist_height_strip += distance_to_origin * h_fly_current_shot
                        sum_dist2_strip += distance_to_origin ** 2

                    base_lenght_in_WP.append(distance_to_origin) # para estrategia vertical tipo  5
                    h_fly_previous = h_fly_current_shot
                    num_shot += 1  # incremento contador de disparos
                    num_shot_absolute += 1 # incremento contador absoluto disparos
                    previous_base_length = base_length

                    # ... FINAL PROCESAMIENTO INICIAL POR SEGMENTO (Basado en estrategia 1.- GSD & Tolerance based)

                # INICIO cálculo de altura de vuelo basado en estrategia vertical seleccionada
                temp_height_projection_center_image_in_strip = []
                temp_height_over_takeoff_image_in_strip = []
                temp_height_over_ground_image_in_strip = []
                diff_of_height_agl_calculated_vs_strategy = []

                if id_trajectory_type == 1:  # 20170405: GSD & Tolerance Based
                    temp_height_projection_center_image_in_strip = height_projection_center_image_in_strip
                    temp_height_over_ground_image_in_strip = height_over_ground_image_in_strip
                    temp_height_over_takeoff_image_in_strip = height_over_takeoff_image_in_strip
                    diff_of_height_agl_calculated_vs_strategy.append(0)

                if id_trajectory_type == 3:  # 20170405: Averaged Altitude Horizontal Strip
                    number_of_heights_per_segment = len(height_projection_center_image_in_strip)
                    if not num_segment == 1:  # En segmentos > 1 tiene en cuenta el último WP del segmento anterior
                        number_of_heights_per_segment += 1
                        sum_h_strip_fly += average_h_strip_fly
                    average_h_strip_fly = sum_h_strip_fly / number_of_heights_per_segment
                    average_h_strip_fly_atof = sum_h_strip_fly_atof / number_of_heights_per_segment
                    for i in range(len(height_projection_center_image_in_strip)):
                        h_strip_fly_agl = average_h_strip_fly - dtm_height_image_in_strip[i]
                        temp_height_projection_center_image_in_strip.append(average_h_strip_fly)
                        temp_height_over_ground_image_in_strip.append(h_strip_fly_agl)
                        temp_height_over_takeoff_image_in_strip.append(average_h_strip_fly_atof)
                        diff_of_height_agl_calculated_vs_strategy.append(abs(h_strip_fly_agl - height_over_ground_image_in_strip[i]))

                if id_trajectory_type == 5:  # 20170405: Best Constant Slope. Linear regression
                    number_of_heights_per_segment = len(height_projection_center_image_in_strip)
                    if not num_segment == 1:# En segmentos > 1 tiene en cuenta el último WP del segmento anterior
                        number_of_heights_per_segment += 1
                        sum_h_strip_fly += projection_center_altitude
                    average_distance_strip = sum_distance_strip / number_of_heights_per_segment
                    average_h_strip_fly = sum_h_strip_fly / number_of_heights_per_segment
                    SumXiYi = sum_dist_height_strip
                    SumXi2 = sum_dist2_strip
                    SumXi_SumYi_by_n = sum_distance_strip * sum_h_strip_fly / number_of_heights_per_segment
                    SumXi2_by_n = (sum_distance_strip ** 2) / number_of_heights_per_segment
                    b1_term = (SumXiYi - SumXi_SumYi_by_n) / (SumXi2 - SumXi2_by_n)
                    b0_term = average_h_strip_fly - (b1_term * average_distance_strip)
                    for i in range(len(height_projection_center_image_in_strip)):
                        projection_center_altitude = b0_term + b1_term * base_lenght_in_WP[i]
                        projection_center_height_agl = projection_center_altitude - dtm_height_image_in_strip[i]
                        projection_center_height_atof = (projection_center_altitude - (z_dtm_takeoff_interpolate + takeoff_height))
                        temp_height_projection_center_image_in_strip.append(projection_center_altitude)
                        temp_height_over_ground_image_in_strip.append(projection_center_height_agl)
                        temp_height_over_takeoff_image_in_strip.append(projection_center_height_atof)
                        diff_of_height_agl_calculated_vs_strategy.append(abs(projection_center_height_agl - height_over_ground_image_in_strip[i]))
                    constant_slope_distance = 0

                # Actualiza lista original con los valores de pasada calculados según estrategia tipo seleccionada
                if id_trajectory_type == 1 or id_trajectory_type == 3 or id_trajectory_type == 5:
                    height_projection_center_image_in_strip = temp_height_projection_center_image_in_strip
                    height_over_ground_image_in_strip = temp_height_over_ground_image_in_strip
                    height_over_takeoff_image_in_strip = temp_height_over_takeoff_image_in_strip

                    # Guarda diccionario completo con los valores calculados para estrategias 1, 3 y 5
                    height_projection_center_image_by_strip[str(num_segment)] = height_projection_center_image_in_strip
                    height_over_ground_image_by_strip[str(num_segment)] = height_over_ground_image_in_strip
                    height_over_takeoff_image_by_strip[str(num_segment)] = height_over_takeoff_image_in_strip
                    # Maxima diferencia entre altura de estrategia y calculada por pasada
                    diff_of_height_agl_max.append(max(diff_of_height_agl_calculated_vs_strategy))

                # Guarda diccionario completo con los valores originales (equivalentes a Tipo 1)
                strip_codes.append(str(num_segment))
                image_codes_by_strip[str(num_segment)] = image_codes_in_strip
                dtm_height_image_by_strip[str(num_segment)] = dtm_height_image_in_strip
                height_projection_center_image_by_strip_origin[str(num_segment)] = height_projection_center_image_in_strip_origin


            # PROCESAMIENTO DE ESTRATEGIAS 2 Y 4. (no dependen del segmento)
            if id_trajectory_type == 2 or id_trajectory_type == 4:  # 20170405: Sacado fuera del Loop por segmentos
                vector = 0
                slope_value_vertex_previous = 0
                nis_absolute = 0
                for order_segment in range(len(strip_codes)):
                    temp_height_projection_center_image_in_strip = []
                    temp_height_over_takeoff_image_in_strip = []
                    temp_height_over_ground_image_in_strip = []
                    diff_of_height_agl_calculated_vs_strategy = []
                    for waypoint_in_segment in range(len(image_codes_by_strip[strip_codes[order_segment]])):
                        slope_vertical_breaks = slope_vertical_breaks_in_strip[vector]  # informacion geom. quiebros
                        slope_value_vertex = slope_vertical_breaks[0]  # siguiente vértice de quiebro
                        slope_value_slope = slope_vertical_breaks[4]  # pendiente de llegada
                        projection_center_altitude = zLs[slope_value_vertex_previous] + slope_value_slope * constant_slope_distance_in_WP[nis_absolute]
                        projection_center_height_agl = projection_center_altitude - dtm_height_image_in_axis[nis_absolute]
                        projection_center_height_atof = (projection_center_altitude - (z_dtm_takeoff_interpolate + takeoff_height))
                        temp_height_projection_center_image_in_strip.append(projection_center_altitude)
                        temp_height_over_ground_image_in_strip.append(projection_center_height_agl)
                        temp_height_over_takeoff_image_in_strip.append(projection_center_height_atof)
                        diff_of_height_agl_calculated_vs_strategy.append(abs(projection_center_height_agl - height_of_flight))
                        if nis_absolute == slope_value_vertex:
                            vector += 1
                            slope_value_vertex_previous = slope_value_vertex
                        nis_absolute += 1
                    # Guarda diccionario completo con los valores calculados para estrategias 2 y 4
                    height_projection_center_image_by_strip[strip_codes[order_segment]] = temp_height_projection_center_image_in_strip
                    height_over_ground_image_by_strip[strip_codes[order_segment]] = temp_height_over_ground_image_in_strip
                    height_over_takeoff_image_by_strip[strip_codes[order_segment]] = temp_height_over_takeoff_image_in_strip
                    diff_of_height_agl_max.append(max(diff_of_height_agl_calculated_vs_strategy))

            height_of_flight_tolerance = max(diff_of_height_agl_max)
            # Error en GSD(%) debido a estrategia vertical
            gsd_tolerance_output = (height_of_flight_tolerance * self.geometric_resolution / (self.focal * gsd))
            if id_trajectory_type > 2:
                gsd_tolerance = gsd_tolerance_output
            self.gsd_tolerance = gsd_tolerance * 100

            self.msg_file_results = "1.- Overlaps calculated in terms of GPS and INS tolerances and errors\n"
            self.msg_file_results += "\t- Forward overlap ...........................:" + str(format(longitudinal_covering * 100, '.1f')) + "%\n\n"
            self.msg_file_results += "2.- GSD tolerance calculated in terms of the selected vertical strategy\n"
            self.msg_file_results += "\t- GSD tolerance output.......................:" + str(format(gsd_tolerance_output * 100, '.1f')) + "%\n\n"
            self.msg_file_results += "3.- Processing the axis geometry\n"
            self.msg_file_results += "\tProcessing axis code:" + str_current_id_axis + "\n"
            self.file_results.writelines(self.msg_file_results)

            self.initial_height = self.was
            if self.was == -1:
                height_over_takeoff_initial_segment = height_over_takeoff_image_by_strip[strip_codes[0]]
                self.initial_height = height_over_takeoff_initial_segment[0]
            # stop_calculation = 0 / 0

            # **************************************************************
            # *** INICIO PROCESAMIENTO FINAL COMPLETO GENERANDO GRÁFICOS ***
            # **************************************************************
            nis_absolute = 0
            num_total_shots = 0
            zLs_new = []
            lst_images_to_keep = []
            # shots_3d__axis_wkt = "POINT("  # geometría wkt de fotocentros 3D
            for current_vertex in range(number_vertex_axis - 1):
                num_segment = current_vertex + 1
                num_segment_check = int(strip_codes[current_vertex])

                image_codes_in_strip = image_codes_by_strip[str(num_segment)]
                height_projection_center_image_in_strip = height_projection_center_image_by_strip[str(num_segment)]
                height_over_ground_image_in_strip = height_over_ground_image_by_strip[str(num_segment)]
                height_over_takeoff_image_in_strip = height_over_takeoff_image_by_strip[str(num_segment)]

                # progress bar
                time.sleep(0.0)
                percent = 20 + 60 * float(num_segment) / float(len(strip_codes))
                # self.iface.mainWindow().statusBar().showMessage("Processed {} %".format(int(percent)))
                progress.setValue(round(percent))

                del list_image_geometry_foot_prints_in_segment[:]
                self.msg_file_results = "\t- Definition segment code " + str(num_segment) + "\n"

                # progress dialog
                self.progress_dialog.enabled_suprocess(False)
                str_process_text = "Processing graphic results segment [" + str(num_segment) + "] ..."
                self.progress_dialog.insert_text(0, str_process_text)
                QCoreApplication.processEvents()

                # habilita subprocess
                self.progress_dialog.set_title_process(1, str_process_text)
                QCoreApplication.processEvents()
                self.progress_dialog.enabled_suprocess(True)

                num_vertex_initial = current_vertex
                num_vertex_end = current_vertex + 1

                initial_point_segment = list_vertex_current_axis[num_vertex_initial]  # punto inicial
                end_point_segment = list_vertex_current_axis[num_vertex_end]  # punto final

                first_coordinate_begin_segment = initial_point_segment[0]  # x inicio
                second_coordinate_begin_segment = initial_point_segment[1]  # y inicio
                first_coordinate_end_segment = end_point_segment[0]  # x final
                second_coordinate_end_segment = end_point_segment[1]  # y final

                self.msg_file_results += "\t\t- Initial vertex\n"
                self.msg_file_results += "\t\t\t- First coordinate .........................................: " + str(first_coordinate_begin_segment) + "\n"
                self.msg_file_results += "\t\t\t- Second coordinate ........................................: " + str(second_coordinate_begin_segment) + "\n"
                self.msg_file_results += "\t\t- End vertex\n"
                self.msg_file_results += "\t\t\t- First coordinate .........................................: " + str(first_coordinate_end_segment) + "\n"
                self.msg_file_results += "\t\t\t- Second coordinate ........................................: " + str(second_coordinate_end_segment) + "\n"
                self.file_results.writelines(self.msg_file_results)

                # cálculo del azimuth directo e inverso del segmento
                # segment_azimuth_direct = 0.0
                state_error, segment_azimuth_direct = self.instanceGeodeticCalculations.azimuth(first_coordinate_begin_segment,
                                                                                                second_coordinate_begin_segment,
                                                                                                first_coordinate_end_segment,
                                                                                                second_coordinate_end_segment)
                if (state_error != CONST_GEODETIC_CALCULATIONS_NO_ERROR):
                    str_msg = "Failed azimuth calculation axis " + str_current_id_axis + "segment " + str(num_segment)
                    self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                        str_msg,
                                                        Qgis.Critical,
                                                        10)
                    # cierre ficheros de resultados .txt y .csv
                    self.file_results.close()
                    self.file_results_csv.close()
                    return False

                self.msg_file_results = "\t\t- Azimuth segment direct (" + str(num_vertex_initial) + " - " + \
                                        str(num_vertex_end) + ")(RAD): " + str(segment_azimuth_direct) + "\n"
                self.file_results.write(self.msg_file_results)

                segment_azimuth_geodetic_direct_deg = \
                    self.instanceGeodeticCalculations.azimuth_geodesico(first_coordinate_begin_segment,
                                                                        second_coordinate_begin_segment,
                                                                        first_coordinate_end_segment,
                                                                        second_coordinate_end_segment,
                                                                        self.int_PostgisCrsId_code_pry_mflip)

                # cálculo de la distancia del segmento
                segment_distance = sqrt(pow(first_coordinate_begin_segment - first_coordinate_end_segment, 2.0) +
                                        pow(second_coordinate_begin_segment - second_coordinate_end_segment, 2.0))

                self.msg_file_results = "\t\t- Distance segment " + str(num_vertex_initial) + " - " + str(num_vertex_end) + "(m.): " + str(segment_distance) + "\n"
                self.file_results.write(self.msg_file_results)

                fet = QgsFeature()
                #SEE: https://gis.stackexchange.com/questions/269012/attributeerror-qgsvectorlayer-object-has-no-attribute-pendingfields
                fields = memory_layer_axis_amplied_origin_points.fields()
                fet.setFields(fields, True)
                qgs_point = QgsPointXY(first_coordinate_begin_segment,
                                       second_coordinate_begin_segment)
                fet.setGeometry(QgsGeometry.fromPointXY(qgs_point))
                fet[id_segment_fieldname] = num_segment
                memory_layer_axis_amplied_origin_points.addFeatures([fet])
                if (memory_layer_axis_amplied_origin_points.commitChanges()):
                    memory_layer_axis_amplied_origin_points.reload()
                    memory_layer_axis_amplied_origin_points.startEditing()  # para el siguiente punto

                fet = QgsFeature()
                fields = memory_layer_axis_amplied_end_points.fields()
                fet.setFields(fields, True)
                qgs_point = QgsPointXY(first_coordinate_end_segment, second_coordinate_end_segment)
                fet.setGeometry(QgsGeometry.fromPointXY(qgs_point))
                fet[id_segment_fieldname] = num_segment
                memory_layer_axis_amplied_end_points.addFeatures([fet])
                if (memory_layer_axis_amplied_end_points.commitChanges()):
                    memory_layer_axis_amplied_end_points.reload()
                    memory_layer_axis_amplied_end_points.startEditing()  # para el siguiente punto

                geom_segment_line = QgsGeometry.fromPolylineXY([QgsPointXY(first_coordinate_begin_segment,
                                                                           second_coordinate_begin_segment),
                                                                QgsPointXY(first_coordinate_end_segment,
                                                                           second_coordinate_end_segment)])

                distance_buffer = terrain_transverse_image_size
                # Returns a buffer region around the geometry, with additional style options
                # geom_buffer_segment = geom_segment_line.buffer(distance_buffer, 5, 2, 2, 100)
                geom_buffer_segment = None
                if qgis_version_second_number < qgis_version_second_number_change_buffer_parameters:
                    geom_buffer_segment = geom_segment_line.buffer(terrain_transverse_image_size, 5, 2, 2, 100)
                else:
                    geom_buffer_segment = geom_segment_line.buffer(terrain_transverse_image_size,
                                                              5,
                                                              Qgis.EndCapStyle.Flat,
                                                              Qgis.JoinStyle.Miter,
                                                              100)

                bouding_box_current_segment = geom_buffer_segment.boundingBox()
                # 20180403. En caso de terrenos muy abruptos y ángulos omega grandes, factor de escala 4. Verificar
                scale_bounding_box = 2.0
                bouding_box_current_segment.scale(scale_bounding_box)

                x_minimum_buffer = bouding_box_current_segment.xMinimum()
                y_minimum_buffer = bouding_box_current_segment.yMinimum()
                x_maximum_buffer = bouding_box_current_segment.xMaximum()
                y_maximum_buffer = bouding_box_current_segment.yMaximum()

                int_rlayer_crs_postgisSrid = rlayer.crs().postgisSrid()

                image_mdt_min_height, image_mdt_max_height = \
                    self.q3_api_op.get_domain_values_from_rlayer_zone(rlayer,
                                                                      x_minimum_buffer,
                                                                      y_minimum_buffer,
                                                                      x_maximum_buffer,
                                                                      y_maximum_buffer,
                                                                      self.int_PostgisCrsId_code_pry_mflip,
                                                                      int_rlayer_crs_postgisSrid)

                # toma en consideración también las altitudes del takeoff y lnd
                if z_dtm_lnd_interpolate > image_mdt_max_height:
                    image_mdt_max_height = z_dtm_lnd_interpolate
                    self.msg_file_results = "\t\t- z_dtm_lnd_interpolate > image_mdt_max_height\n"

                if z_dtm_takeoff_interpolate > image_mdt_max_height:
                    image_mdt_max_height = z_dtm_takeoff_interpolate
                    self.msg_file_results = "\t\t- z_dtm_takeoff_interpolate > image_mdt_max_height\n"

                if z_dtm_lnd_interpolate < image_mdt_min_height:
                    image_mdt_min_height = z_dtm_lnd_interpolate
                    self.msg_file_results = "\t\t- z_dtm_lnd_interpolate < image_mdt_max_height\n"

                if z_dtm_takeoff_interpolate < image_mdt_min_height:
                    image_mdt_min_height = z_dtm_takeoff_interpolate
                    self.msg_file_results = "\t\t- z_dtm_takeoff_interpolate < image_mdt_max_height\n"

                #self.file_results.write(self.msg_file_results)

                # impresión de resultados
                self.msg_file_results = "\t\t- Dimension bounding box extended buffer current axis:\n"
                self.msg_file_results += "\t\t\t- x min ............: " + str(x_minimum_buffer) + "\n"
                self.msg_file_results += "\t\t\t- y min ............: " + str(y_minimum_buffer) + "\n"
                self.msg_file_results += "\t\t\t- x max ............: " + str(x_maximum_buffer) + "\n"
                self.msg_file_results += "\t\t\t- y max ............: " + str(y_maximum_buffer) + "\n"
                self.msg_file_results += "\t\t- Altitudes range DTM:\n"
                self.msg_file_results += "\t\t\t- Minimum height .........................................: " \
                                         + str(image_mdt_min_height) + "\n"
                self.msg_file_results += "\t\t\t- Maximum height .........................................: " \
                                         + str(image_mdt_max_height) + "\n"
                self.file_results.writelines(self.msg_file_results)

                # inicializa contadores bucle
                # num_shot = 1

                strip_3d_axis_wkt = "LINESTRINGZ("  # geometría wkt del eje en 3D
                strip_3d_nadir_axis_wkt = "LINESTRINGZ("  # geometría wkt del nadir en 3D
                strip_2d_nadir_axis_wkt = "LINESTRING("  # geometría wkt del nadir en 2D

                control_drawing_geom = True

                ### INICIO PROCESAMIENTO PARA CADA WAYPOINT o SHOT (IMAGES) ... ###
                for waypoint_in_segment in range(len(image_codes_by_strip[strip_codes[current_vertex]])):
                    # Obtención de datos planimétricos y altimétricos necesarios para obtener resultados gráficos
                    num_shot = image_codes_in_strip[waypoint_in_segment]
                    h_fly_current_shot = height_projection_center_image_in_strip[waypoint_in_segment]
                    height_of_flight_current_shot_AGL = height_over_ground_image_in_strip[waypoint_in_segment]
                    height_of_flight_current_shot_TOF = height_over_takeoff_image_in_strip[waypoint_in_segment]
                    x_current_shot = xLs[nis_absolute]
                    y_current_shot = yLs[nis_absolute]
                    zLs_new.append(h_fly_current_shot)
                    dtm_height_current_shot = dtm_height_image_in_axis[nis_absolute]

                    # Se llena lista con WP_ids con problemas de altura AGL
                    if height_of_flight_current_shot_AGL <= self.min_value_ground_collision:
                        str_list_points_ground_collision_risk_AGL += str(num_segment) + "." + str(num_shot) + " "
                        if not control_msg_ground_collision_risk_AGL:
                            control_msg_ground_collision_risk_AGL = True

                    if height_of_flight_current_shot_AGL > self.min_value_ground_collision and height_of_flight_current_shot_AGL < self.max_value_obstacles_collision:
                        str_list_points_obstacles_collision_risk_AGL += str(num_segment) + "." + str(num_shot) + " "
                        if not control_msg_obstacles_collision_risk_AGL:
                            control_msg_obstacles_collision_risk_AGL = True

                    # Se llena lista con WP_ids con problemas de altura respecto a TOF
                    if height_of_flight_current_shot_TOF <= 0:
                        str_list_points_ground_collision_risk_TOF += str(num_segment) + "." + str(num_shot) + " "
                        if not control_msg_ground_collision_risk_TOF:
                            control_msg_ground_collision_risk_TOF = True

                    if height_of_flight_current_shot_TOF > 0 and height_of_flight_current_shot_TOF < self.max_value_obstacles_collision:
                        str_list_points_obstacles_collision_risk_TOF += str(num_segment) + "." + str(num_shot) + " "
                        if not control_msg_obstacles_collision_risk_TOF:
                            control_msg_obstacles_collision_risk_TOF = True

                    # 20190202: Control para no dibujar waypoints en vértices internos de segmento:
                    if num_shot == len(image_codes_by_strip[strip_codes[current_vertex]]):  # Pto final del segmento
                        if current_vertex < (number_vertex_axis - 2):  # Que no sea vértice final de Axis
                            if hold_time == 0:  # Navegación sin parada en vértices internos (implica fitaxis = 1)
                                control_drawing_geom = False

                    # 20190202: Solo si control_drawing_geom = True
                    if control_drawing_geom:
                        strip_3d_axis_wkt += format(x_current_shot, '.3f') + " "
                        strip_3d_axis_wkt += format(y_current_shot, '.3f') + " "
                        strip_3d_axis_wkt += format(h_fly_current_shot, '.3f') + ","

                        strip_3d_nadir_axis_wkt += format(x_current_shot, '.3f') + " "
                        strip_3d_nadir_axis_wkt += format(y_current_shot, '.3f') + " "
                        strip_3d_nadir_axis_wkt += format(dtm_height_current_shot, '.3f') + ","

                        strip_2d_nadir_axis_wkt += format(x_current_shot, '.3f') + " "
                        strip_2d_nadir_axis_wkt += str(y_current_shot) + ","

                        # graba datos en memory layer WAYPOINT
                        fet = QgsFeature()
                        fields = memory_layer_way_points.fields()
                        fet.setFields(fields, True)
                        qgs_point = QgsPointXY(x_current_shot,
                                               y_current_shot)
                        fet.setGeometry(QgsGeometry.fromPointXY(qgs_point))
                        fet[cod_flight_block_fieldname] = self.str_code_flight_block
                        fet[id_axis_fieldname] = int(str_current_id_axis)
                        fet[id_segment_fieldname] = num_segment
                        fet[id_number_shot_fieldname] = num_shot

                        # fet[id_image_fieldname] =  str(num_segment) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + str(num_shot)
                        fet[x_waypoint_fieldname] = format(x_current_shot, formateo)
                        fet[y_waypoint_fieldname] = format(y_current_shot, formateo)
                        fet[dtm_height_fieldname] = format(dtm_height_current_shot, formateo)
                        fet[crs_code_fieldname] = self.str_PostgisCrsId_code_pry_mflip
                        fet[h_fly_fieldname] = format(h_fly_current_shot, formateo)
                        fet[id_shot_fieldname] = int(nis_absolute)
                        memory_layer_way_points.addFeatures([fet])
                        if (memory_layer_way_points.commitChanges()):
                            memory_layer_way_points.reload()
                            memory_layer_way_points.startEditing()  # para el siguiente punto

                        # ... FINISH Calculating images projection centers

                        # Formation of foots against DTM images ...
                        self.str_shape = "POLYGON(("
                        self.str_shape_3d = "POLYGON(("
                        str_g3d_pc = "POINT("
                        str_g3d_ndir = "POINT("

                        x_pc = x_current_shot
                        y_pc = y_current_shot
                        z_nadir = dtm_height_current_shot
                        z_pc = h_fly_current_shot

                        # pitch = 0.0
                        pitch = self.omega_angle * CONST_PI / 180
                        # roll = 0.0
                        roll = self.phi_angle * CONST_PI / 180
                        yaw = 0.0
                        image_azimuth = 0.0
                        h_max = -1000000.0
                        h_min = 1000000.0

                        image_azimuth = segment_azimuth_direct

                        if cam_id_mounting_type == 1:
                            yaw = image_azimuth + CONST_PI / 2.0
                            # yaw = CONST_PI / 2.0 - image_azimuth ; Old
                        # este caso se comenta porque ya no se va a dar
                        # if(cameraAssembly.contains("2"))
                        #    kappa=3.0*pi/2.0-imageAzimuth;
                        if cam_id_mounting_type == 3:
                            yaw = image_azimuth
                            # yaw = 2.0 * CONST_PI - image_azimuth ; Old
                        # este caso se comenta porque ya no se va a dar
                        # if(cameraAssembly.contains("4"))
                        #    kappa=pi-imageAzimuth;

                        matrix = self.get_resection_matrix(pitch,
                                                           roll,
                                                           yaw)
                        z_pc_dtm = z_nadir
                        z_min = image_mdt_min_height + average_height_object
                        z_max = image_mdt_max_height + average_height_object
                        min_x_terrain = 10000000000.0
                        max_x_terrain = -1000000000.0
                        min_y_terrain = 10000000000.0
                        max_y_terrain = -10000000000.0
                        gsd_max = -10000000.0
                        gsd_min = 10000000.0
                        gsd_pc = 0.0
                        zt0 = 0.0

                        # huella teórica
                        self.str_theoretical_shape = "POLYGON(("
                        for i in range(number_of_points):
                            x_terrain = 0.0
                            y_terrain = 0.0
                            x_image = image_x[i]
                            y_image = image_y[i]
                            aux1 = matrix[0][0] * x_image + matrix[0][1] * y_image - matrix[0][2] * self.focal
                            aux2 = matrix[1][0] * x_image + matrix[1][1] * y_image - matrix[1][2] * self.focal
                            aux3 = matrix[2][0] * x_image + matrix[2][1] * y_image - matrix[2][2] * self.focal
                            landa = (z_pc_dtm - z_pc) / aux3
                            x_terrain = x_pc + landa * aux1
                            y_terrain = y_pc + landa * aux2
                            if (i == 0):
                                xt0 = x_terrain
                                yt0 = y_terrain

                            self.str_theoretical_shape += format(x_terrain, formateo) + " "
                            self.str_theoretical_shape += format(y_terrain, formateo) + ","

                        # end bucle - for i in range(number_of_points)

                        self.str_theoretical_shape += format(xt0, formateo) + " "
                        self.str_theoretical_shape += format(yt0, formateo) + "))"

                        gsds = []  # QVector<double>

                        # TODO: NO comprobado lo que va dentro del if porque el ejemplo no se mete ahí.
                        if (fabs(z_min - z_max) < linear_tolerance):
                            # El terreno no tiene desnivel, la altitud es conocida: la media de z_min y z_max
                            # Se obtiene el factor landa para la zTerrain y con el se obtienen las coordenadas xTerrain e yTerrain

                            for i in range(number_of_points):
                                x_terrain = 0.0
                                y_terrain = 0.0
                                z_terrain = (z_min + z_max) / 2.0
                                x_image = image_x[i]
                                y_image = image_y[i]

                                aux1 = matrix[0][0] * x_image + matrix[0][1] * y_image - matrix[0][2] * self.focal
                                aux2 = matrix[1][0] * x_image + matrix[1][1] * y_image - matrix[1][2] * self.focal
                                aux3 = matrix[2][0] * x_image + matrix[2][1] * y_image - matrix[2][2] * self.focal

                                # Calculo del valor de landa para la z-maxima
                                landa = (z_terrain - z_pc) / aux3  # En realidad sera el valor minimo de landa
                                x_terrain = x_pc + landa * aux1
                                y_terrain = y_pc + landa * aux2

                                dist = sqrt(pow(x_terrain - x_pc, 2.0) + pow(y_terrain - y_pc, 2.0) + pow(z_terrain - z_pc, 2.0))
                                dist_image = sqrt(pow(x_image, 2.0) + pow(y_image, 2.0))
                                dist_pc_2_image = sqrt(pow(self.focal, 2.0) + pow(dist_image, 2.0))
                                scale = dist_pc_2_image / dist
                                gsds.append(1.0 / scale * self.geometric_resolution)
                                if (z_terrain > h_max):
                                    h_max = z_terrain
                                if (z_terrain < h_min):
                                    h_min = z_terrain
                                if (i == 0):
                                    xt0 = x_terrain
                                    yt0 = y_terrain
                                    zt0 = z_terrain
                                    gsd_pc = 1.0 / scale * self.geometric_resolution

                                if (i == 1):
                                    xt1 = x_terrain
                                    yt1 = y_terrain
                                    zt1 = z_terrain

                                if (i > 0):
                                    if (x_terrain < min_x_terrain):
                                        min_x_terrain = x_terrain
                                    if (x_terrain > max_x_terrain):
                                        max_x_terrain = x_terrain
                                    if (y_terrain < min_y_terrain):
                                        min_y_terrain = y_terrain
                                    if (y_terrain > max_y_terrain):
                                        max_y_terrain = y_terrain
                                    self.str_shape += format(x_terrain,
                                                             formateo) + " "  # (QString::number(xTerrain,'f',printPrecision)+" ")
                                    self.str_shape += format(y_terrain, formateo) + ","
                                    self.str_shape_3d += format(x_terrain, formateo) + " "
                                    self.str_shape_3d += format(y_terrain, formateo) + " "
                                    self.str_shape_3d += format(z_terrain, formateo) + ","
                                    # end bucle - for i in range(number_of_points):
                        else:
                            for i in range(number_of_points):
                                x_terrain = 0.0
                                y_terrain = 0.0
                                z_terrain = 0.0
                                diff_z = 100000.0
                                x_image = image_x[i]
                                y_image = image_y[i]

                                aux1 = matrix[0][0] * x_image + matrix[0][1] * y_image - matrix[0][2] * self.focal
                                aux2 = matrix[1][0] * x_image + matrix[1][1] * y_image - matrix[1][2] * self.focal
                                aux3 = matrix[2][0] * x_image + matrix[2][1] * y_image - matrix[2][2] * self.focal

                                landa_1 = 1.0
                                v_x = x_pc + landa_1 * aux1
                                v_y = y_pc + landa_1 * aux2
                                v_z = z_pc + landa_1 * aux3

                                str_error, x_t, y_t, z_t = raster_dem.get_vector_intersection(x_pc, y_pc, z_pc,
                                                                                              v_x, v_y, v_z,
                                                                                              average_height_object)
                                if str_error:
                                    str_msg = "Error:\n" + str_error
                                    self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                                        str_msg,
                                                                        Qgis.Info,
                                                                        10)
                                    self.file_results.close()
                                    self.file_results_csv.close()
                                    return False
                                x_terrain = x_t
                                y_terrain = y_t
                                z_terrain = z_t

                                # ret = self.iPyProject.getDemVectorIntersection(str_dtm_path,
                                #                                                average_height_object,
                                #                                                x_pc,y_pc,z_pc,
                                #                                                v_x,v_y,v_z)
                                # if ret[0] == "False":
                                #     str_msg = "Error:\n" + ret[1]
                                #     self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                #                                         str_msg,
                                #                                         Qgis.Info,
                                #                                         10)
                                #     self.file_results.close()
                                #     self.file_results_csv.close()
                                #     return False
                                #
                                # x_terrain = ret[1]
                                # y_terrain = ret[2]
                                # z_terrain = ret[3]

                                dist = sqrt(
                                    pow(x_terrain - x_pc, 2.0) + pow(y_terrain - y_pc, 2.0) + pow(z_terrain - z_pc, 2.0))
                                dist_image = sqrt(pow(x_image, 2.0) + pow(y_image, 2.0))
                                dist_pc_2_image = sqrt(pow(self.focal, 2.0) + pow(dist_image, 2.0))
                                scale = dist_pc_2_image / dist
                                gsds.append(1.0 / scale * self.geometric_resolution)
                                if (z_terrain > h_max):
                                    h_max = z_terrain
                                if (z_terrain < h_min):
                                    h_min = z_terrain
                                if (i == 0):
                                    xt0 = x_terrain
                                    yt0 = y_terrain
                                    zt0 = z_terrain
                                    gsd_pc = 1.0 / scale * self.geometric_resolution

                                if (i == 1):
                                    xt1 = x_terrain
                                    yt1 = y_terrain
                                    zt1 = z_terrain

                                if (i > 0):
                                    if x_terrain < min_x_terrain:
                                        min_x_terrain = x_terrain
                                    if x_terrain > max_x_terrain:
                                        max_x_terrain = x_terrain
                                    if y_terrain < min_y_terrain:
                                        min_y_terrain = y_terrain
                                    if y_terrain > max_y_terrain:
                                        max_y_terrain = y_terrain

                                    self.str_shape += format(x_terrain, formateo) + " "
                                    self.str_shape += format(y_terrain, formateo) + ","
                                    self.str_shape_3d += format(x_terrain, formateo) + " "
                                    self.str_shape_3d += format(y_terrain, formateo) + " "
                                    self.str_shape_3d += format(z_terrain, formateo) + ","

                                    # end bucle - for i in range(number_of_points):

                        self.str_shape += format(xt1, formateo) + " "
                        self.str_shape += format(yt1, formateo) + "))"
                        self.str_shape_3d += format(xt1, formateo) + " "
                        self.str_shape_3d += format(yt1, formateo) + " "
                        self.str_shape_3d += format(zt1, formateo) + "))"

                        str_g3d_pc += format(x_current_shot, formateo) + " "
                        str_g3d_pc += format(y_current_shot, formateo) + " "
                        str_g3d_pc += format(z_pc, formateo) + ")"

                        str_g3d_ndir += format(xt0, formateo) + " "
                        str_g3d_ndir += format(yt0, formateo) + " "
                        str_g3d_ndir += format(zt0, formateo) + ")"

                        gsd_mean = 0.0
                        for i in range(number_of_points):
                            gsd_mean += gsds[i]
                            if (gsds[i] < gsd_min):
                                gsd_min = gsds[i]
                            if (gsds[i] > gsd_max):
                                gsd_max = gsds[i]
                        gsd_mean = gsd_mean / number_of_points
                        gsd_std_mean = 0.0
                        for i in range(number_of_points):
                            gsd_std_mean += pow(gsd_mean - gsds[i], 2.0)
                        gsd_std_mean = sqrt(gsd_std_mean / (number_of_points - 1) / number_of_points)

                        dist_ppa_dtm = sqrt(pow(xt0 - x_pc, 2.0) + pow(yt0 - y_pc, 2.0) + pow(zt0 - z_pc, 2.0))

                        # graba datos en memory layer FOOTPRINTS
                        fet = QgsFeature()
                        fields = memory_layer_footprints.fields()
                        fet.setFields(fields, True)

                        qgs_polygon_current_geometry_2d_footprint = QgsGeometry.fromWkt(self.str_shape)
                        if not qgs_polygon_current_geometry_2d_footprint:
                            #FIXME: msg error?
                            print("error creacion geom desde cadena wkt de poligono")
                            continue
                        else:
                            list_image_geometry_foot_prints_in_segment.append(qgs_polygon_current_geometry_2d_footprint)

                        fet.setGeometry(qgs_polygon_current_geometry_2d_footprint)
                        fet[cod_flight_block_fieldname] = self.str_code_flight_block
                        fet[crs_code_fieldname] = self.str_PostgisCrsId_code_pry_mflip
                        fet[id_axis_fieldname] = int(str_current_id_axis)  # se corresponde con el strip_cd
                        # fet[strip_id_fieldname] = str_current_id_axis
                        fet[id_segment_fieldname] = num_segment
                        fet[id_number_shot_fieldname] = num_shot
                        fet[id_image_fieldname] = str(num_segment) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + str(num_shot)
                        #fet[wkt_footprint_theoretical_fieldname] = self.str_theoretical_shape
                        fet[wkt_footprint_fieldname] = self.str_shape
                        fet[wkt_footprint_3d_fieldname] = self.str_shape_3d
                        fet[wkt_g3d_pc_fieldname] = str_g3d_pc
                        fet[wkt_g3d_ndir_fieldname] = str_g3d_ndir
                        fet[azimuth_fieldname] = format(segment_azimuth_direct * 180 / CONST_PI,  formateo)
                        fet[cam_info_fieldname] = cam_info_value
                        fet[pc_fc_fieldname] = x_current_shot
                        fet[pc_sc_fieldname] = y_current_shot
                        fet[h_pc_fieldname] = format(z_pc, formateo)
                        fet[yaw_fieldname] = format(yaw * 180 / CONST_PI, formateo)
                        fet[roll_fieldname] = format(self.phi_angle, ".2f")
                        fet[pitch_fieldname] = format(self.omega_angle, ".2f")
                        fet[gsd_theo_fieldname] = format(self.list_parameter_db_flight_block[7], formateo)
                        fet[gsd_pc_fieldname] = format(gsd_pc, formateo)
                        fet[gsd_max_fieldname] = format(gsd_max, formateo)
                        fet[gsd_mean_fieldname] = format(gsd_mean, formateo)
                        fet[gsd_min_fieldname] = format(gsd_min, formateo)
                        fet[h_max_fieldname] = format(h_max, ".2f")
                        fet[h_min_fieldname] = format(h_min, ".2f")
                        fet[h_nadir_fieldname] = format(z_nadir, ".2f")
                        fet[ppa_dtm_fc_fieldname] = format(xt0, ".2f")
                        fet[ppa_dtm_sc_fieldname] = format(yt0, ".2f")
                        fet[ppa_dtm_h_fieldname] = format(zt0, ".2f")
                        fet[height_AGL_fieldname] = format(z_pc - z_nadir, ".2f")
                        fet[dist_ppa_dtm_fieldname] = format(dist_ppa_dtm, ".2f")
                        memory_layer_footprints.addFeatures([fet])
                        if (memory_layer_footprints.commitChanges()):
                            memory_layer_footprints.reload()
                            memory_layer_footprints.startEditing()  # para el siguiente punto

                        # ... FINISH Formation of foots against DTM images

                        # Cálculo del recubrimiento longitudinal ...
                        if (num_shot > 1):
                            qgs_polygon_previous_geometry_2d_footprint = list_image_geometry_foot_prints_in_segment[num_shot - 2]
                            if (qgs_polygon_current_geometry_2d_footprint.intersects(qgs_polygon_previous_geometry_2d_footprint)):
                                qgsgeom_intersection = qgs_polygon_current_geometry_2d_footprint.intersection(qgs_polygon_previous_geometry_2d_footprint)
                                if self.qgsgeometry_zone_buffer is not None and not self.qgsgeometry_zone_buffer.intersects(qgsgeom_intersection) and self.is_remove_images_without_stereoscopy:
                                    pass

                                else:
                                    type_of_geometry = qgsgeom_intersection.wkbType()  # OGRwkbGeometryType typeOfGeometry=ptrIntersection->getGeometryType();
                                    exists_stereo_pair = False
                                    if (type_of_geometry == 3 or type_of_geometry == 6):  # 3: wkbPolygon; 6: wkbMultiPolygon
                                        area_intersection = qgsgeom_intersection.area()
                                        area_image = qgs_polygon_current_geometry_2d_footprint.area()
                                        area_image_previous = qgs_polygon_previous_geometry_2d_footprint.area()
                                        rec_long_image = area_intersection / area_image
                                        rec_long_image_previous = area_intersection / area_image_previous
                                        exists_stereo_pair = True
                                        # Se crea e inserta el par estereoscópicio en memory layer STEREOPAIRS
                                        str_stereo_pair_foot_print_2d_wkt = qgsgeom_intersection.asWkt()

                                        fet = QgsFeature()
                                        fields = memory_layer_stereopairs.fields()
                                        fet.setFields(fields, True)

                                        fet.setGeometry(qgsgeom_intersection)
                                        fet[cod_flight_block_fieldname] = self.str_code_flight_block
                                        fet[id_axis_fieldname] = int(str_current_id_axis)
                                        fet[id_segment_fieldname] = int(num_segment)
                                        str_id_img_before = str(num_segment) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + str(num_shot - 1)
                                        fet[id_img_before_fieldname] = str_id_img_before
                                        str_id_img_after = str(num_segment) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + str(num_shot)
                                        fet[id_img_after_fieldname] = str_id_img_after
                                        fet[cd_img_before_fieldname] = num_shot - 1
                                        fet[cd_img_after_fieldname] = num_shot
                                        fet[id_stereopair_fieldname] = str_id_img_before + c.CONST_SEPARATOR_IMAGES_IDS_IN_STEREOPAIR_ID + str_id_img_after
                                        fet[wkt_stereopair_fieldname] = str_stereo_pair_foot_print_2d_wkt
                                        fet[crs_code_fieldname] = self.str_PostgisCrsId_code_pry_mflip
                                        fet[area_intersection_fieldname] = area_intersection
                                        fet[area_image_before_fieldname] = area_image_previous
                                        fet[area_image_after_fieldname] = area_image
                                        fet[rec_long_image_before_fieldname] = rec_long_image_previous
                                        fet[rec_long_image_after_fieldname] = rec_long_image
                                        memory_layer_stereopairs.addFeatures([fet])
                                        if (memory_layer_stereopairs.commitChanges()):
                                            memory_layer_stereopairs.reload()
                                            memory_layer_stereopairs.startEditing()  # para el siguiente punto
                                        if (qgs_polygon_geometry_stereoscopic_zone == None):
                                            qgs_polygon_geometry_stereoscopic_zone = qgsgeom_intersection.combine(qgsgeom_intersection)
                                        else:
                                            qgs_polygon_geometry_stereoscopic_zone = qgs_polygon_geometry_stereoscopic_zone.combine(qgsgeom_intersection)
                                        # images a mantener
                                        if str_id_img_before not in lst_images_to_keep:
                                            lst_images_to_keep.append(str_id_img_before)
                                        if str_id_img_after not in lst_images_to_keep:
                                            lst_images_to_keep.append(str_id_img_after)
                                    else:
                                        """
                                        msg = "Para la zona de código: " + current_id_zone
                                        msg += "\nPara la pasada de código: " + strip_code
                                        msg += "\nPara la imagen de código: " + image_code
                                        """
                                        msg = "La intersección de su huella con la anterior no es de tipo POLYGON o MULTIPOLYGON"
                                        self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                                            msg,
                                                                            Qgis.Critical,
                                                                            10)
                                        # cierre ficheros de resultados .txt y .csv
                                        self.file_results.close()
                                        self.file_results_csv.close()
                                        return False
                            else:
                                """
                                msg = "Para la zona de código: " + current_id_zone
                                msg += "\nPara la pasada de código: " + strip_code
                                msg += "\nPara la imagen de código: " + image_code
                                """
                                msg = "No se ha detectado la intersección de su huella con la anterior"
                                self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                                    msg,
                                                                    Qgis.Critical,
                                                                    10)
                                # cierre ficheros de resultados .txt y .csv
                                self.file_results.close()
                                self.file_results_csv.close()
                                return False
                    # ... FINISH Cálculo del recubrimiento longitudinal

                    nis_absolute += 1  # numero absoluto de posicion en lista

                    # ... FINAL PROCESAMIENTO PARA CADA WAYPOINT o SHOT (IMAGES)

                uav_images_by_segment[str(num_segment)] = image_codes_in_strip

                if num_shot > 1:
                    # se quita última , y se añade )
                    strip_3d_axis_wkt = strip_3d_axis_wkt[:-1]
                    strip_3d_axis_wkt = strip_3d_axis_wkt + ")"

                    strip_3d_nadir_axis_wkt = strip_3d_nadir_axis_wkt[:-1]
                    strip_3d_nadir_axis_wkt = strip_3d_nadir_axis_wkt + ")"

                    # TODO: Si el eje tiene un solo punto casca
                    strip_2d_nadir_axis_wkt = strip_2d_nadir_axis_wkt[:-1]
                    strip_2d_nadir_axis_wkt = strip_2d_nadir_axis_wkt + ")"

                    self.strip_g3d_axis_wkt_m_by_strip.append(strip_3d_axis_wkt)
                    self.strip_g2d_ndax_wkt_by_strip.append(strip_2d_nadir_axis_wkt)
                    self.strip_g3d_ndax_wkt_by_strip.append(strip_3d_nadir_axis_wkt)

                    # graba datos en memory layer STRIPS
                    fet = QgsFeature()
                    fields = memory_layer_strips.fields()
                    fet.setFields(fields, True)
                    geometry_strip_2d_nadir_axis = QgsGeometry.fromWkt(strip_2d_nadir_axis_wkt)
                    fet.setGeometry(geometry_strip_2d_nadir_axis)

                    fet[cod_flight_block_fieldname] = self.str_code_flight_block
                    fet[id_axis_fieldname] = int(str_current_id_axis)
                    fet[id_segment_fieldname] = num_segment
                    """
                    fet[x_waypoint_fieldname] = format(x_current_shot,formateo)
                    fet[y_waypoint_fieldname] = format(y_current_shot,formateo)
                    """

                    fet[crs_code_fieldname] = self.str_PostgisCrsId_code_pry_mflip
                    fet[id_strip_fieldname] = str(num_segment)

                    fet[lenght_fielname] = str(segment_distance)
                    if control_drawing_geom:
                        fet[num_imgs_fieldname] = str(num_shot)
                    else:
                        fet[num_imgs_fieldname] = str(num_shot - 1)
                    fet[azimuth_fieldname] = str(segment_azimuth_direct)

                    memory_layer_strips.addFeatures([fet])
                    if (memory_layer_strips.commitChanges()):
                        memory_layer_strips.reload()
                        memory_layer_strips.startEditing()  # para el siguiente punto

                # quiebros
                num_total_shots = num_total_shots + num_shot
                # pares números WP - acimuth pasada
                lst_jogs_point_azimuth = [num_total_shots, segment_azimuth_geodetic_direct_deg]
                lst_jogs.append(lst_jogs_point_azimuth)

                # progress dialog
                self.progress_dialog.clear_text(1)
                self.progress_dialog.enabled_suprocess(False)
                str_process_text = "... finish processing segment [" + str(num_segment) + "]"
                self.progress_dialog.insert_text(0, str_process_text)
                QCoreApplication.processEvents()
                # ... FINAL PROCESAMIENTO SEGMENTO (STRIP). PARA CADA SEGMENTO (TRAMO DE LINESTRING)

            # salto de pagina final
            self.msg_file_results = "\n"
            self.file_results.write(self.msg_file_results)

        if control_msg_ground_collision_risk_AGL:
            str_msg_ground_collision_risk = "Height of waypoint/s num. ( "
            str_msg_ground_collision_risk += str_list_points_ground_collision_risk_AGL
            str_msg_ground_collision_risk += ") At Ground level!!" + "\n"
            str_msg_ground_collision_risk += "Risk of collision with ground"

            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("  Height above ground: ALERT !!    ")
            msg.setInformativeText("  Check the mission viability  ")
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText(str_msg_ground_collision_risk)
            msg.exec_()

        if control_msg_obstacles_collision_risk_AGL:
            str_msg_obstacles_collision_risk = "Height of waypoint/s num. ( "
            str_msg_obstacles_collision_risk += str_list_points_obstacles_collision_risk_AGL
            str_msg_obstacles_collision_risk += ") below the Safety Height" + "\n"
            str_msg_obstacles_collision_risk += "Risk of collision with vertical obstacles"

            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("  Height above ground: Warning !!    ")
            msg.setInformativeText("  Check the mission viability  ")
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText(str_msg_obstacles_collision_risk)
            msg.exec_()

        if control_msg_ground_collision_risk_TOF:
            str_msg_ground_collision_risk = "Altitude of waypoint/s No. ( "
            str_msg_ground_collision_risk += str_list_points_ground_collision_risk_TOF
            str_msg_ground_collision_risk += ") below the Takeoff altitude" + "\n"
            str_msg_ground_collision_risk += "Risk of collision with ground"

            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("  Height above take-off: ALERT !!    ")
            msg.setInformativeText("  Check the mission viability  ")
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText(str_msg_ground_collision_risk)
            msg.exec_()

        if control_msg_obstacles_collision_risk_TOF:
            str_msg_obstacles_collision_risk = "Altitude of waypoint/s No. ( "
            str_msg_obstacles_collision_risk += str_list_points_obstacles_collision_risk_TOF
            str_msg_obstacles_collision_risk += ") below the Safety Height relative to Takeoff" + "\n"
            str_msg_obstacles_collision_risk += "Risk of collision with vertical obstacles"

            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("  Height above take-off: Warning !!    ")
            msg.setInformativeText("  Check the mission viability  ")
            msg.setWindowTitle(c.CONST_PFLIPUAV_TITLE)
            msg.setDetailedText(str_msg_obstacles_collision_risk)
            msg.exec_()

        # CÁLCULO DEL SCRIPT DE NAVEGACIÓN
        self.progress_dialog.enabled_suprocess(False)
        str_process_text = "Generating script navigation ..."
        self.progress_dialog.insert_text(0, str_process_text)
        QCoreApplication.processEvents()

        # Vuelo en sentido directo
        path_uav_navigation_file_name_dir = self.path_uav_navigation_file_name + ".txt"
        path_uav_navigation_time_file_name_dir = self.path_uav_navigation_file_name + "_time.txt"

        int_PostgisCrsId_code_pry_mflip = int(self.str_PostgisCrsId_code_pry_mflip)
        str_mission_type = "lineal"

        # self.instaceDatabase.control_roof_height(zLs). 20180321 Ahora se calcula en carabo_waypoint_library
        # stop_calculation = 0 / 0

        # commit & unselect(20190205) de todas las memory layers
        memory_layer_way_points.commitChanges()
        memory_layer_way_points.updateExtents()
        memory_layer_way_points.selectByIds([])
        memory_layer_strips.commitChanges()
        memory_layer_strips.updateExtents()
        memory_layer_strips.selectByIds([])
        memory_layer_footprints.commitChanges()
        memory_layer_footprints.updateExtents()
        memory_layer_footprints.selectByIds([])
        memory_layer_stereopairs.commitChanges()
        memory_layer_stereopairs.updateExtents()
        memory_layer_stereopairs.selectByIds([])
        memory_layer_axis_amplied_origin_points.commitChanges()
        memory_layer_axis_amplied_origin_points.updateExtents()
        memory_layer_axis_amplied_origin_points.selectByIds([])
        memory_layer_axis_amplied_end_points.commitChanges()
        memory_layer_axis_amplied_end_points.updateExtents()
        memory_layer_axis_amplied_end_points.selectByIds([])

        # eliminacion way_points que no intersectan con zone
        if self.is_remove_images_without_stereoscopy:
            list_id_shots_to_remove = []
            memory_layer_way_points.startEditing()
            for feature in memory_layer_way_points.getFeatures():
                current_id_segment = feature['id_segment']
                current_id_number_shot = feature['number_shot']
                current_id_shot = feature['id_shot']
                current_str_id_img = str(current_id_segment) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + str(current_id_number_shot)
                if current_str_id_img not in lst_images_to_keep:
                    list_id_shots_to_remove.append(current_id_shot)
                    memory_layer_way_points.deleteFeature(feature.id())
            memory_layer_way_points.commitChanges()
            memory_layer_way_points.updateExtents()

            # eliminacion images que no intersectan con zone
            memory_layer_footprints.startEditing()
            for feature in memory_layer_footprints.getFeatures():
                current_id_segment = feature['id_segment']
                current_id_number_shot = feature['number_shot']
                current_str_id_img = str(current_id_segment) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + str(current_id_number_shot)
                if current_str_id_img not in lst_images_to_keep:
                    memory_layer_footprints.deleteFeature(feature.id())
            memory_layer_footprints.commitChanges()
            memory_layer_footprints.updateExtents()

            for index in sorted(list_id_shots_to_remove, reverse=True):
                del xLs[index]
                del yLs[index]
                del zLs_new[index]

            # reconstruye diccionario uav_images_by_segment sin imagenes que no intersectan y lst jogs *****************
            request = QgsFeatureRequest()
            # set order by field
            clause = QgsFeatureRequest.OrderByClause('id_shot', ascending=True)
            orderby = QgsFeatureRequest.OrderBy([clause])
            request.setOrderBy(orderby)
            features = memory_layer_way_points.getFeatures(request)

            uav_images_by_segment = {}
            image_codes_in_strip = []
            lst_jogs = []
            num_total_shots = -1

            str_next_segment = '1'
            for feature in features:
                num_total_shots += 1
                current_num_segment = str(feature['id_segment'])
                if current_num_segment == str_next_segment:
                    int_num_shot = int(feature['number_shot'])
                    image_codes_in_strip.append(int_num_shot)
                    image_codes_in_last_strip = image_codes_in_strip
                else:
                    segment_azimuth_geodetic_direct_deg = 0
                    lst_jogs_point_azimuth = [num_total_shots, segment_azimuth_geodetic_direct_deg]
                    lst_jogs.append(lst_jogs_point_azimuth)
                    uav_images_by_segment[str(str_next_segment)] = image_codes_in_strip
                    str_next_segment = current_num_segment
                    image_codes_in_strip = []
            # ultima pasada
            uav_images_by_segment[str(str_next_segment)] = image_codes_in_last_strip

        if (self.str_firmware == c.CONST_CARABO_S3_AC_030406 and not self.is_remove_images_without_stereoscopy):
            self.instanceCaraboWayPointLibrary = CaraboWayPointLibrary(self.iface,
                                                                       int_PostgisCrsId_code_pry_mflip,
                                                                       path_uav_navigation_file_name_dir,
                                                                       path_uav_navigation_time_file_name_dir,
                                                                       angle_advanced_columns_to_axis_flight,
                                                                       x_takeoff,
                                                                       y_takeoff,
                                                                       z_dtm_takeoff_interpolate,
                                                                       x_landing,
                                                                       y_landing,
                                                                       z_dtm_lnd_interpolate,
                                                                       xLs,
                                                                       yLs,
                                                                       zLs_new,
                                                                       uav_images_by_segment,
                                                                       self.list_parameter_db_flight_block,
                                                                       self.path_db_project,
                                                                       self.str_firmware,
                                                                       str_mission_type,
                                                                       lst_jogs,
                                                                       theoretical_base_length,
                                                                       self.path_plugin)
        else:
            pass

        # progress bar
        time.sleep(0.2)
        percent = 80 + 20
        progress.setValue(percent)

        str_process_text = "... Finish calculating the flight script"
        self.progress_dialog.insert_text(0, str_process_text)
        QCoreApplication.processEvents()
        self.progress_dialog.close()

        # para el métodos storages
        self.memory_layer_way_points = memory_layer_way_points
        self.memory_layer_footprints = memory_layer_footprints
        self.memory_layer_stereopairs = memory_layer_stereopairs
        self.memory_layer_strips = memory_layer_strips

        if not self.is_remove_images_without_stereoscopy:
            str_msg_table, str_msg_table_csv = self.print_table_in_report()
            self.file_results.writelines(str_msg_table)
            self.file_results_csv.writelines(str_msg_table_csv)

        # cierre de los ficheros
        self.file_results.close()
        self.file_results_csv.close()
        # ... FINAL PROCESAMIENTO AXIS. PARA CADA EJE

        return True

    def print_table_in_report(self):
        """
        """
        precision = 3
        formateo = '.' + str(precision) + 'f'
        if (self.str_firmware == c.CONST_CARABO_S3_AC_030406):
            x_takeoff = self.instanceCaraboWayPointLibrary.x_takeoff
            y_takeoff = self.instanceCaraboWayPointLibrary.y_takeoff
            z_dtm_takeoff_interpolate = self.instanceCaraboWayPointLibrary.z_dtm_takeoff_interpolate
            x_landing = self.instanceCaraboWayPointLibrary.x_landing
            y_landing = self.instanceCaraboWayPointLibrary.y_landing
            z_dtm_lnd_interpolate = self.instanceCaraboWayPointLibrary.z_dtm_lnd_interpolate
        else:
            pass

        id_lnd = self.list_parameter_db_flight_block[4]  # landing type (-1 - toff point; > 0 - id del punto digitalizado
        takeoff_height = self.list_parameter_db_flight_block[20]
        z_takeoff = z_dtm_takeoff_interpolate + takeoff_height
        landing_height = self.list_parameter_db_flight_block[22]
        height_before_landing = self.list_parameter_db_flight_block[24]
        str_msg_table = "                                                Absolute Altitude(ASL)                 Relat.Height\n"
        str_msg_table += "n_Strip    n_Image    Coor.X.      Coor.Y.      Z.Ground     Z.Sensor     AGL_Height   to Take-off      ****  Alert Information  **** \n"
        str_msg_table += "  Takeoff point" + format(x_takeoff, formateo).rjust(15, ' ') \
                                           + format(y_takeoff, formateo).rjust(14, ' ') \
                                           + format(z_dtm_takeoff_interpolate, formateo).rjust(12, ' ') \
                                           + format(z_takeoff, formateo).rjust(13, ' ') \
                                           + format(takeoff_height, formateo).rjust(13, ' ') + "\n"

        # initial takeoff height information line. 20170427
        str_msg_table += " Initial height" + format(x_takeoff, formateo).rjust(15, ' ') \
                                           + format(y_takeoff, formateo).rjust(14, ' ') \
                                           + format(z_dtm_takeoff_interpolate, formateo).rjust(12, ' ') \
                                           + format(z_takeoff + self.initial_height, formateo).rjust(13, ' ') \
                                           + format(z_takeoff + self.initial_height - z_dtm_takeoff_interpolate, formateo).rjust(13, ' ') \
                                           + format(self.initial_height, formateo).rjust(13, ' ') + "\n"

        str_msg_table_csv = "n_Strip;n_Image;Coor.X.;Coor.Y.;ASL.Z.Ground;ASL.Z.Sensor;AGL_Height;Take_off_relat.Height\n"
        str_msg_table_csv += ";Takeoff point;"
        str_msg_table_csv += format(x_takeoff, formateo) + ";"  # QString::number(xTakeoff,'f',precision)<<";";
        str_msg_table_csv += format(y_takeoff, formateo) + ";"  # QString::number(yTakeoff,'f',precision)<<";";
        str_msg_table_csv += format(z_dtm_takeoff_interpolate, formateo) + ";"  # QString::number(zDtmTakeoff,'f',precision)<<";";
        str_msg_table_csv += format(z_takeoff, formateo) + ";"  # QString::number(0.0,'f',precision);
        str_msg_table_csv += format(takeoff_height, formateo) + ";"  # QString::number(0.0,'f',precision);
        str_msg_table_csv += "\n";

        # initial takeoff height information line. 20170427
        str_msg_table_csv += ";Initial height;"
        str_msg_table_csv += format(x_takeoff, formateo) + ";"
        str_msg_table_csv += format(y_takeoff, formateo) + ";"
        str_msg_table_csv += format(z_dtm_takeoff_interpolate, formateo) + ";"
        str_msg_table_csv += format(z_takeoff + self.initial_height, formateo) + ";"
        str_msg_table_csv += format(z_takeoff + self.initial_height - z_dtm_takeoff_interpolate, formateo) + ";"
        str_msg_table_csv += format(self.initial_height, formateo) + ";"
        str_msg_table_csv += "\n";
        
        for feat in self.memory_layer_footprints.getFeatures():

            idx_strip_cd = self.memory_layer_footprints.fields().indexFromName('id_segment')
            strip_cd_value = str(feat.attributes()[idx_strip_cd])

            idx_code_image = self.memory_layer_footprints.fields().indexFromName('number_shot')
            code_image_value = str(feat.attributes()[idx_code_image])

            idx_pc_fc = self.memory_layer_footprints.fields().indexFromName('pc_fc')
            pc_fc_value = feat.attributes()[idx_pc_fc]

            idx_pc_sc = self.memory_layer_footprints.fields().indexFromName('pc_sc')
            pc_sc_value = feat.attributes()[idx_pc_sc]

            idx_h_pc = self.memory_layer_footprints.fields().indexFromName('pc_H')
            h_pc_value = feat.attributes()[idx_h_pc]
            float_h_pc_value = float(h_pc_value)

            idx_h_nadir = self.memory_layer_footprints.fields().indexFromName('H_nadir')
            h_nadir_value = feat.attributes()[idx_h_nadir]
            float_h_nadir_value = float(h_nadir_value)

            AGL_height = float_h_pc_value - float_h_nadir_value

            height_fromTOF = float_h_pc_value - (z_dtm_takeoff_interpolate + takeoff_height)

            # para el .txt
            str_msg_table += strip_cd_value.rjust(5, ' ')
            str_msg_table += code_image_value.rjust(10, ' ')
            str_msg_table += format(pc_fc_value, formateo).rjust(15, ' ')
            str_msg_table += format(pc_sc_value, formateo).rjust(14, ' ')
            str_msg_table += format(float_h_nadir_value, formateo).rjust(12, ' ')
            str_msg_table += format(float_h_pc_value, formateo).rjust(13, ' ')
            str_msg_table += format(AGL_height, formateo).rjust(13, ' ')
            str_alert = ""
            str_AGL_alert = "   "
            str_TOF_alert = "   "
            if (height_fromTOF > 0 and height_fromTOF < self.max_value_obstacles_collision):
                str_alert = "      Warning!! Check the WP Height"
                str_TOF_alert = " * "
            if (AGL_height > self.min_value_ground_collision and AGL_height < self.max_value_obstacles_collision):
                str_alert = "      Warning!! Check the WP Height"
                str_AGL_alert = " * "
            if height_fromTOF <= 0:
                str_alert = "      ## ALERT!! Check the WP Height"
                str_TOF_alert = " ##"
            if (AGL_height <= self.min_value_ground_collision):
                str_alert = "      ## ALERT!! Check the WP Height"
                str_AGL_alert = " ##"
            str_msg_table += str_AGL_alert
            str_msg_table += format(height_fromTOF, formateo).rjust(10, ' ')
            str_msg_table += str_TOF_alert
            str_msg_table += str_alert
            str_msg_table += '\n'

            # para el .csv
            str_msg_table_csv += strip_cd_value + ';'
            str_msg_table_csv += code_image_value + ';'
            str_msg_table_csv += format(pc_fc_value, formateo) + ';'
            str_msg_table_csv += format(pc_sc_value, formateo) + ';'
            str_msg_table_csv += format(float_h_nadir_value, formateo) + ';'
            str_msg_table_csv += format(float_h_pc_value, formateo) + ';'
            str_msg_table_csv += format(AGL_height, formateo) + ';'
            str_msg_table_csv += format(height_fromTOF, formateo) + ';'
            str_msg_table_csv += '\n'

        if id_lnd == -1:  # Landing point = Takeoff point
            z_landing = z_dtm_lnd_interpolate + takeoff_height
        else:
            z_landing = z_dtm_lnd_interpolate

        if height_before_landing == -1:  # -> #HBL: Checked -> The same as the final WP
            z_pc_landing = float_h_pc_value
            increment_height = (z_landing + landing_height) - z_pc_landing
            if increment_height > 0:  # si z landing point > z last point
                z_pc_landing = z_landing + landing_height
        else:  # -> #HBL: Unchecked
            z_pc_landing = z_landing + height_before_landing

        final_vertical_height = (z_landing + landing_height) - z_pc_landing
        landing_height_fromTOF = z_pc_landing - z_takeoff

        str_msg_table += " Landing Waypoint" \
                         + format(x_landing, formateo).rjust(13, ' ') \
                         + format(y_landing, formateo).rjust(14, ' ') \
                         + format(z_dtm_lnd_interpolate, formateo).rjust(12, ' ') \
                         + format(z_pc_landing, formateo).rjust(13, ' ') \
                         + format(z_pc_landing - z_dtm_lnd_interpolate, formateo).rjust(13, ' ') \
                         + format(landing_height_fromTOF, formateo).rjust(13, ' ') + "\n"
        str_msg_table_csv += "Landing Waypoint;;"
        str_msg_table_csv += format(x_landing, formateo) + ";"  # QString::number(xLanding,'f',precision)<<";";
        str_msg_table_csv += format(y_landing, formateo) + ";"  # QString::number(yLanding,'f',precision)<<";";
        str_msg_table_csv += format(z_dtm_lnd_interpolate, formateo) + ";"  # QString::number(zDtmLanding,'f',precision)<<";";
        str_msg_table_csv += format(z_pc_landing, formateo) + ";"  # QString::number(zDtmLanding,'f',precision)<<";";
        str_msg_table_csv += format(z_pc_landing - z_dtm_lnd_interpolate, formateo) + ";"  # QString::number(0.0,'f',precision);
        str_msg_table_csv += format(landing_height_fromTOF, formateo) + ";"  # QString::number(0.0,'f',precision);
        str_msg_table_csv += "\n"

        # if not height_before_landing == landing_height:  # solo si HBL != height_over_landing
        if not final_vertical_height == 0:  # solo si HBL != height_over_landing
            z_pc_end_landing = z_pc_landing + final_vertical_height
            landing_end_height_fromTOF = z_pc_end_landing - z_takeoff
            str_msg_table += " Ending Height   " \
                             + format(x_landing, formateo).rjust(13, ' ') \
                             + format(y_landing, formateo).rjust(14, ' ') \
                             + format(z_dtm_lnd_interpolate, formateo).rjust(12, ' ') \
                             + format(z_pc_end_landing, formateo).rjust(13, ' ') \
                             + format(z_pc_end_landing - z_dtm_lnd_interpolate, formateo).rjust(13, ' ') \
                             + format(landing_end_height_fromTOF, formateo).rjust(13, ' ') + "\n"
            str_msg_table_csv += "Ending Height;;"
            str_msg_table_csv += format(x_landing, formateo) + ";"  # QString::number(xLanding,'f',precision)<<";";
            str_msg_table_csv += format(y_landing, formateo) + ";"  # QString::number(yLanding,'f',precision)<<";";
            str_msg_table_csv += format(z_dtm_lnd_interpolate, formateo) + ";"  # QString::number(zDtmLanding,'f',precision)<<";";
            str_msg_table_csv += format(z_pc_end_landing, formateo) + ";"  # QString::number(zDtmLanding,'f',precision)<<";";
            str_msg_table_csv += format(z_pc_end_landing - z_dtm_lnd_interpolate, formateo) + ";"  # QString::number(0.0,'f',precision);
            str_msg_table_csv += format(landing_end_height_fromTOF, formateo) + ";"  # QString::number(0.0,'f',precision);
            str_msg_table_csv += "\n"

        return str_msg_table, str_msg_table_csv

    def store_images(self):
        """
        Brief: método para el almacenamiento de las imagenes en la BD
        """
        # obtiene valor del último valor del rowid grabado en la tabla
        fieldname = "rowid"
        number_of_images_stored = self.db_op.get_max_value_field_from_table_db(self.path_db_project,
                                                                               fieldname,
                                                                               c.CONST_PFLIPUAV_LAYER_IMAGES)
        if number_of_images_stored < 0:
            str_msg = "Error en el cálculo del valor máximo de rowid en store_images"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            self.file_results.close()
            self.file_results_csv.close()
            return False
        else:
            number_of_images_stored = number_of_images_stored + 1

        for feat in self.memory_layer_footprints.getFeatures():
            cod_flight_block_value = feat['cod_flight_block']
            code_image_value = feat['number_shot']
            id_image_value = feat['id_image']
            strip_cd_value = feat['id_segment']
            strip_cd_axis = feat['id_axis']
            crs_value = feat['crs_code']
            wkt_footprint_value = feat['wkt_footprint']
            wkt_footprint_3d_value = feat['wkt_footprint_3D']
            wkt_g3d_pc_value = feat['wkt_g3d_pc']
            wkt_g3d_ppa_dtm_value = feat['wkt_g3d_ppa_dtm']
            yaw_value = feat['yaw'] # en deg
            pitch_value = feat['pitch']
            roll_value = feat['roll']
            cam_attitude_value = "Yaw: %s; Pitch: %s; Roll: %s  //" % (str(yaw_value), str(pitch_value), str(roll_value))
            cam_info_value = feat['sensor_info']
            azimuth_value =feat['azimuth'] # En deg
            pc_fc_value = feat['pc_fc']
            pc_sc_value = feat['pc_sc']
            pc_h_value = feat['pc_H']
            h_nadir_max = feat['H_max']
            h_nadir_min = feat['H_min']
            h_nadir_value = feat['H_nadir']
            gsd_max_value = feat['gsd_max']
            gsd_mean_value = feat['gsd_mean']
            gsd_min_value = feat['gsd_min']
            gsd_pc_value = feat['gsd_pc']
            gsd_theo_value = feat['gsd_theo']

            # consulta INSERT
            str_sql = "INSERT INTO " + c.CONST_PFLIPUAV_LAYER_IMAGES + " ("
            str_sql += "azi_fly," # Segment navigation azimuth
            str_sql += "azimuth," # Yaw camera value
            str_sql += "cod_flight_block,"
            str_sql += "code_image,"
            str_sql += "crs,"
            str_sql += "g2d_fp_wkt_m,"
            str_sql += "g3d_fp_wkt,"
            str_sql += "g3d_pc_wkt,"
            str_sql += "g3d_ndir_wkt,"
            str_sql += "id_image,"
            str_sql += "rowid,"
            str_sql += "strip_cd,"
            str_sql += "strip_id,"
            str_sql += "pc_fc,"
            str_sql += "pc_sc,"
            str_sql += "H_pc,"
            str_sql += "H_max,"
            str_sql += "H_min,"
            str_sql += "H_nadir,"
            str_sql += "gsd_max,"
            str_sql += "gsd_mean,"
            str_sql += "gsd_min,"
            str_sql += "gsd_pc,"
            str_sql += "gsd_theo,"
            str_sql += "sensor_cd_OBSOLETO,"
            str_sql += "geom_2d_fp_m"  # campo geom

            str_sql += ") VALUES ("
            str_sql += str(azimuth_value) + ","
            str_sql += str(yaw_value) + ","
            str_sql += "'" + str(cod_flight_block_value) + "',"
            str_sql += "'" + str(code_image_value) + "',"
            str_sql += "'" + str(crs_value) + "',"
            str_sql += "'" + wkt_footprint_value + "',"
            str_sql += "'" + wkt_footprint_3d_value + "',"
            str_sql += "'" + wkt_g3d_pc_value + "',"
            str_sql += "'" + wkt_g3d_ppa_dtm_value + "',"
            str_sql += "'" + str(id_image_value) + "',"
            str_sql += str(number_of_images_stored) + ","
            str_sql += "'" + str(strip_cd_value) + "',"
            str_sql += "'" + str(strip_cd_axis) + "',"
            str_sql += str(pc_fc_value) + ","
            str_sql += str(pc_sc_value) + ","
            str_sql += str(pc_h_value) + ","
            str_sql += str(h_nadir_max) + ","
            str_sql += str(h_nadir_min) + ","
            str_sql += str(h_nadir_value) + ","
            str_sql += str(gsd_max_value) + ","
            str_sql += str(gsd_mean_value) + ","
            str_sql += str(gsd_min_value) + ","
            str_sql += str(gsd_pc_value) + ","
            str_sql += str(gsd_theo_value) + ","
            str_sql += "'" + str(cam_attitude_value) + str(cam_info_value) + "',"
            # carga geometría desde wkt con el crs del proyecto PLIPUAV
            geom = feat.geometry()
            wkt = geom.asWkt()
            str_sql += "(SELECT PolyFromText ('"
            str_sql += wkt
            str_sql += "'," + self.str_PostgisCrsId_code_pry_mflip + ")));"

            self.db_op.execute_query_old(self.path_db_project,
                                         str_sql)

            number_of_images_stored = number_of_images_stored + 1  # se aumenta el contador

        return True

    def store_stereo_pairs(self):
        """
        Brief:
        """
        # obtiene valor del último valor del rowid grabado en la tabla
        fieldname = "rowid"
        number_of_stereo_pairs_stored = self.db_op.get_max_value_field_from_table_db(self.path_db_project,
                                                                                     fieldname,
                                                                                     c.CONST_PFLIPUAV_LAYER_STEREO_PAIRS)
        if (number_of_stereo_pairs_stored < 0):
            str_msg = "Error en el cálculo del valor máximo de rowid en store stereo pairs"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            self.file_results.close()
            self.file_results_csv.close()
            return False
        else:
            number_of_stereo_pairs_stored = number_of_stereo_pairs_stored + 1

        for feat in self.memory_layer_stereopairs.getFeatures():

            # obtención de los valores de la memory layer
            id_stereopair_value = feat['id_stereopair']
            cd_img_after_value = feat['cd_img_after']
            id_img_after_value = feat['id_img_after']
            cd_img_before_value = feat['cd_img_before']
            id_img_before_value = feat['id_img_before']
            cod_flight_block_value = feat['cod_flight_block']
            crs_value = feat['crs_code']
            g2d_fp_wkt_m_value = feat['g2d_fp_wkt_m']
            strip_id_value = feat['id_segment']

            # consulta INSERT 
            str_sql = "INSERT INTO " + c.CONST_PFLIPUAV_LAYER_STEREO_PAIRS + " ("
            str_sql += "cod_flight_block,"
            str_sql += "crs,"
            str_sql += "g2d_fp_wkt_m,"
            str_sql += "id_stereo_pairs,"
            str_sql += "img_a_cd,"
            str_sql += "img_a_id,"
            str_sql += "img_b_cd,"
            str_sql += "img_b_id,"
            str_sql += "rowid,"
            str_sql += "strip_cd,"
            str_sql += "strip_id,"
            str_sql += "geom_2d_fp_m"  # campo geom

            str_sql += ") VALUES ("
            str_sql += "'" + str(cod_flight_block_value) + "',"
            str_sql += str(crs_value) + ","
            str_sql += "'" + str(g2d_fp_wkt_m_value) + "',"
            str_sql += "'" + str(id_stereopair_value) + "',"
            str_sql += "'" + str(cd_img_after_value) + "',"
            str_sql += "'" + str(id_img_after_value) + "',"
            str_sql += "'" + str(cd_img_before_value) + "',"
            str_sql += "'" + str(id_img_before_value) + "',"
            str_sql += str(number_of_stereo_pairs_stored) + ","
            str_sql += str(strip_id_value) + ","
            str_sql += "'" + str(strip_id_value) + "',"
            # carga geometría desde wkt con el crs del proyecto
            geom = feat.geometry()
            wkt = geom.asWkt()
            str_sql += "(SELECT PolyFromText ('"
            str_sql += wkt
            str_sql += "'," + self.str_PostgisCrsId_code_pry_mflip + ")));"

            self.db_op.execute_query_old(self.path_db_project, str_sql)

            number_of_stereo_pairs_stored = number_of_stereo_pairs_stored + 1  # se aumenta el contador

        return True

    def store_strips(self):
        """
        Brief: 
        """
        fieldname = "rowid"
        number_of_strips_stored = self.db_op.get_max_value_field_from_table_db(self.path_db_project,
                                                                               fieldname,
                                                                               c.CONST_PFLIPUAV_LAYER_STRIPS)
        if (number_of_strips_stored < 0):
            str_msg = "Error en el cálculo del valor máximo de rowid en store_strips"
            self.iface.messageBar().pushMessage(c.CONST_PFLIPUAV_TITLE,
                                                str_msg,
                                                Qgis.Critical,
                                                10)
            self.file_results.close()
            self.file_results_csv.close()
            return False
        else:
            number_of_strips_stored = number_of_strips_stored + 1

        num_strip = 0
        for feat in self.memory_layer_strips.getFeatures():
            azimuth_value = feat['azimuth']

            strip_azimuth = float(azimuth_value) * 180.0 / CONST_PI
            str_type_strip = self.get_strip_type(strip_azimuth)

            cod_flight_block_value = feat['cod_flight_block']
            crs_value = feat['crs_code']
            id_strip_value = feat['id_segment']
            lenght_value = feat['lenght']
            num_imgs_value = feat['num_imgs']

            str_img_fst = str(id_strip_value) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + "1"
            str_img_lst = str(id_strip_value) + c.CONST_PHOTOGRAMMETRY_STRING_SEPARATOR + str(num_imgs_value)

            # consulta INSERT      
            str_sql = "INSERT INTO " + c.CONST_PFLIPUAV_LAYER_STRIPS + " ("
            str_sql += "azimuth,"
            str_sql += "cod_flight_block,"
            str_sql += "code_strip,"
            str_sql += "crs,"
            str_sql += "g2d_ndax_wkt,"
            str_sql += "g3d_ndax_wkt,"
            str_sql += "g3d_axis_wkt_m,"
            str_sql += "id_strips,"
            str_sql += "img_fst,"
            str_sql += "img_lst,"
            str_sql += "length,"
            str_sql += "num_imgs,"
            str_sql += "rowid,"
            str_sql += "type,"
            str_sql += "geom_3d_axis_m"  # campo geom

            str_sql += ") VALUES ("
            str_sql += str(strip_azimuth) + ","
            str_sql += "'" + str(cod_flight_block_value) + "',"
            str_sql += "'" + str(id_strip_value) + "',"
            str_sql += str(crs_value) + ","
            str_sql += "'" + self.strip_g2d_ndax_wkt_by_strip[num_strip] + "',"
            str_sql += "'" + self.strip_g3d_ndax_wkt_by_strip[num_strip] + "',"
            str_sql += "'" + self.strip_g3d_axis_wkt_m_by_strip[num_strip] + "',"
            str_sql += "'" + str(num_imgs_value) + "',"
            str_sql += "'" + str_img_fst + "',"
            str_sql += "'" + str_img_lst + "',"
            str_sql += str(lenght_value) + ","
            str_sql += str(num_imgs_value) + ","
            str_sql += str(number_of_strips_stored) + ","
            str_sql += "'" + str(str_type_strip) + "',"

            # carga geometría desde wkt con el crs del proyecto MFLiP
            # ojo cargar la z
            # geom = feat.geometry()
            # wkt = geom.asWkt()

            str_sql += "(SELECT LineStringFromText('"
            str_sql += self.strip_g3d_axis_wkt_m_by_strip[num_strip]
            str_sql += "'," + self.str_PostgisCrsId_code_pry_mflip + ")));"

            self.db_op.execute_query_old(self.path_db_project,
                                         str_sql)

            number_of_strips_stored = number_of_strips_stored + 1  # aumenta el contador
            num_strip = num_strip + 1  # contador de la lista que contiene los wkt en 3D

        return True