# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PflipUav3
                                 A QGIS plugin
 Photogrammetric and Remote Sensing Flight Planning for unmanned aerial vehicle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-08-23
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernández López, PAFYC-UCLM
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
from osgeo import gdal, osr, ogr, gdalconst
import os
import shutil
from os.path import exists
import datetime
from math import floor, ceil, sqrt, isnan, modf, trunc
import math
from pathlib import Path

RASTERDEM_EPSG_CODE_NULL_VALUE = -1
RASTERDEM_NO_VALUE = -999

class RasterDEM:
    def __init__(self,
                 number_of_decimals):
        self.ds = None
        self.rb = None
        self.number_of_decimals = number_of_decimals
        self.double_to_integer_factor = pow(10.0, self.number_of_decimals)
        self.integer_to_double_factor = 1.0 / self.double_to_integer_factor
        self.crs_epsg_code = RASTERDEM_EPSG_CODE_NULL_VALUE
        self.exists_no_data_value = False
        self.no_data_value = None
        # self.data_uint16 = None
        # self.data_uint32 = None
        self.data = None
        self.check_domain = False
        self.file_name = None
        self.georef = None
        self.columns = None
        self.rows = None
        self.size_fc = None
        self.size_sc = None
        self.grid_size = None
        self.nw_fc = None
        self.nw_sc = None
        self.ne_fc = None
        self.ne_sc = None
        self.sw_fc = None
        self.sw_sc = None
        self.se_fc = None
        self.se_sc = None
        self.min_elevation = None
        self.max_elevation = None
        self.crs = None
        self.data_masked = False

    def bilinear_interpolation(self, inc_column, inc_row, values):
        str_error = ''
        elevation = RASTERDEM_NO_VALUE
        ul_value = values[0]
        ur_value = values[1]
        ll_value = values[2]
        lr_value = values[3]
        if (ul_value != RASTERDEM_NO_VALUE and ur_value != RASTERDEM_NO_VALUE
                and ll_value != RASTERDEM_NO_VALUE and lr_value != RASTERDEM_NO_VALUE):
            elevation = (1.0 - inc_row) * (1.0 - inc_column) * float(ul_value)
            elevation += inc_column * (1.0 - inc_row) * float(ur_value)
            elevation += (1.0 - inc_column) * inc_row * float(ll_value)
            elevation += inc_column * inc_row * float(lr_value)
            elevation = elevation * self.integer_to_double_factor
        elif (ul_value != RASTERDEM_NO_VALUE or ur_value != RASTERDEM_NO_VALUE
                or ll_value != RASTERDEM_NO_VALUE or lr_value != RASTERDEM_NO_VALUE):
            elevation = 0.
            sumWeights = 0.
            if ul_value != RASTERDEM_NO_VALUE:
                distance = math.sqrt(inc_row * inc_row + inc_column * inc_column)
                weight = 1.0 / pow(distance, 2.0)
                elevation += (weight * float(ul_value) * self.integer_to_double_factor)
                sumWeights += weight
            if ur_value != RASTERDEM_NO_VALUE:
                distance = math.sqrt(inc_row * inc_row + (1. - inc_column) * (1. - inc_column))
                weight = 1.0 / pow(distance, 2.0)
                elevation += (weight * float(ur_value) * self.integer_to_double_factor)
                sumWeights += weight
            if ll_value != RASTERDEM_NO_VALUE:
                distance = math.sqrt((1. - inc_row) * (1. - inc_row) + inc_column * inc_column)
                weight = 1.0 / pow(distance, 2.0)
                elevation += (weight * float(ll_value) * self.integer_to_double_factor)
                sumWeights += weight
            if lr_value != RASTERDEM_NO_VALUE:
                distance = math.sqrt((1. - inc_row) * (1. - inc_row) + (1. - inc_column) * (1. - inc_column))
                weight = 1.0 / pow(distance, 2.0)
                elevation += (weight * float(lr_value) * self.integer_to_double_factor)
                sumWeights += weight
            elevation = elevation / sumWeights
        return str_error, elevation

    def get_elevation(self, fc, sc):
        str_error = ''
        elevation = RASTERDEM_NO_VALUE
        pointOutEdge = fc < self.nw_fc or fc > self.ne_fc or sc < self.sw_sc or sc > self.nw_sc
        if self.check_domain and pointOutEdge:
            str_error = RasterDEM.__name__ + "." + self.get_elevation.__name__
            str_error += ("\nPoint out of DEM:\n{}").format(self.file_name)
            return str_error, elevation
        dbl_column = (fc - self.nw_fc) / self.size_fc
        dbl_row = (sc - self.nw_sc) / self.size_sc
        column = math.floor(dbl_column)
        row = math.floor(dbl_row)
        if (pointOutEdge):
            str_aux_error, elevation = self.get_elevation_for_no_data_point(column, row)
            return str_aux_error, elevation
        if column == -1:
            column = 0
        if row == -1:
            row = 0
        if column > (self.columns - 2):
            column = self.columns - 2
        if row > (self.rows - 2):
            row = self.rows - 2
        inc_column = dbl_column - column
        inc_row = dbl_row - row
        value_ul = RASTERDEM_NO_VALUE
        value_ur = RASTERDEM_NO_VALUE
        value_ll = RASTERDEM_NO_VALUE
        value_lr = RASTERDEM_NO_VALUE
        if column >= 0 and column < self.columns and row >= 0 and row < self.rows:
            if self.data_masked:
                if not self.data.mask[row][column]:
                    value_ul = self.data[row][column]
            else:
                value_ul = self.data[row][column]
        if (column + 1) >= 0 and (column + 1) < self.columns and row >= 0 and row < self.rows:
            if self.data_masked:
                if not self.data.mask[row][(column + 1)]:
                    value_ur = self.data[row][(column + 1)]
            else:
                value_ur = self.data[row][(column + 1)]
        if column >= 0 and column < self.columns and (row + 1) >= 0 and (row + 1) < self.rows:
            if self.data_masked:
                if not self.data.mask[(row + 1)][column]:
                    value_ll = self.data[(row + 1)][column]
            else:
                value_ll = self.data[(row + 1)][column]
        if (column + 1) >= 0 and (column + 1) < self.columns and (row + 1) >= 0 and (row + 1) < self.rows:
            if self.data_masked:
                if not self.data.mask[(row + 1)][(column + 1)]:
                    value_lr = self.data[(row + 1)][(column + 1)]
            else:
                value_lr = self.data[(row + 1)][(column + 1)]
        values = []
        values.append(value_ul)
        values.append(value_ur)
        values.append(value_ll)
        values.append(value_lr)
        str_aux_error, elevation = self.bilinear_interpolation(inc_column, inc_row, values)
        return str_error, elevation

    def get_elevation_for_no_data_point(self, column, row):
        str_error = ''
        elevation = RASTERDEM_NO_VALUE
        initial_column = column
        if initial_column > self.columns:
            initial_column = self.columns - 1
        elif initial_column < 0:
            initial_column = 0
        initial_row = row
        if initial_row > self.rows:
            initial_row = self.rows - 1
        elif initial_row < 0:
            initial_row = 0
        mean_value = 0
        dis = 1
        control = True
        while(control):
            values = []
            c = initial_column - dis
            if c >= 0:
                for r in range(initial_row - dis, initial_row + dis + 1):
                    if r < 0 or r > self.rows:
                        continue
                    if self.data_masked:
                        if self.data.mask[r][c]:
                            continue
                    values.append(self.data[r][c])
            c = initial_column + dis
            if c < self.columns:
                for r in range(initial_row - dis, initial_row + dis + 1):
                    if r < 0 or r > self.rows:
                        continue
                    if self.data_masked:
                        if self.data.mask[r][c]:
                            continue
                    values.append(self.data[r][c])
            r = initial_row - dis
            if r >= 0:
                for c in range(initial_column - dis, initial_column + dis + 1):
                    if c < 0 or c > self.columns:
                        continue
                    if self.data_masked:
                        if self.data.mask[r][c]:
                            continue
                    values.append(self.data[r][c])
            r = initial_row + dis
            if r < self.rows:
                for c in range(initial_column - dis, initial_column + dis + 1):
                    if c < 0 or c > self.columns:
                        continue
                    if self.data_masked:
                        if self.data.mask[r][c]:
                            continue
                    values.append(self.data[r][c])
            if len(values) > 0:
                mean_value = 0
                for i in range(len(values)):
                    mean_value += values[i]
                mean_value = float(mean_value/float(len(values)))
                control = False
            else:
                dis = dis + 1
        elevation = mean_value * self.integer_to_double_factor
        return str_error, elevation

    def get_vector_intersection(self, vFpFc, vFpSc, vFpTc,
                                vSpFc, vSpSc, vSpTc,
                                offsetOverDem):
        str_error = ''
        fc = RASTERDEM_NO_VALUE
        sc = RASTERDEM_NO_VALUE
        tc = RASTERDEM_NO_VALUE
        if vSpTc > vFpTc:
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_error += ("\nSecond points is above first point")
            return str_error, fc, sc, tc
        fpElevation = RASTERDEM_NO_VALUE
        str_aux_error, fpElevation = self.get_elevation(vFpFc, vFpSc)
        if str_aux_error:
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_p = ("[{:.3f}, {:.3f}]").format(vFpFc, vFpSc)
            str_error += ("\nGettir elevation for first point {}, error:\n{}").format(str_p, str_aux_error)
            return str_error, fc, sc, tc
        if abs(vSpFc - vFpFc) < 0.001 and abs(vSpSc - vFpSc) < 0.001: # nadir
            fc = vFpFc
            sc = vFpSc
            tc = fpElevation
            return str_error, fc, sc, tc
        spElevation = RASTERDEM_NO_VALUE
        str_aux_error, spElevation = self.get_elevation(vSpFc, vSpSc)
        if str_aux_error:
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_p = ("[{:.3f}, {:.3f}]").format(vSpFc, vSpSc)
            str_error += ("\nGettir elevation for second point {}, error:\n{}").format(str_p, str_aux_error)
            return str_error, fc, sc, tc
        spElevation = spElevation + offsetOverDem
        azimuth = math.atan2(vSpFc - vFpFc, vSpSc - vFpSc)
        if azimuth < 0.0:
            azimuth = azimuth + 2.0 * math.pi
        tolerance = self.grid_size / 2.0
        vDistance2d = math.sqrt(pow(vSpFc - vFpFc, 2.0) + pow(vSpSc - vFpSc, 2.0))
        vSlope = (vSpTc - vFpTc) / vDistance2d
        minSlope = (fpElevation - vFpTc) / self.grid_size
        if vSlope < minSlope:
            nadirAngle = math.atan(vDistance2d / (vFpTc - vSpTc))
            distanceInGrid = (vFpTc - fpElevation) * math.tan(nadirAngle)
            fc = vFpFc + distanceInGrid * math.sin(azimuth)
            sc = vFpSc + distanceInGrid * math.cos(azimuth)
            tc = fpElevation
            return str_error, fc, sc, tc
        previousElevation = -1.
        previousFc = -1.
        previousSc = -1.
        distance = self.grid_size
        if vFpTc > self.max_elevation:
            distance = (self.max_elevation + offsetOverDem - vFpTc) / vSlope  # ambos negativos
        control = True
        while True:
            fc = vFpFc + distance * math.sin(azimuth)
            sc = vFpSc + distance * math.cos(azimuth)
            vpTc = vFpTc + distance * vSlope
            pElevation = RASTERDEM_NO_VALUE
            str_aux_error, pElevation = self.get_elevation(fc, sc)
            if str_aux_error or (abs(pElevation - self.no_data_value) < 0.001 and abs(self.no_data_value) > 1):
                if previousFc > 0. and previousSc > 0.:
                    fc = previousFc
                    sc = previousSc
                    tc = previousElevation
                    break
                else: # cuando el primer calculo cae fuera
                    distance = distance + self.grid_size
                    continue
            pElevation = pElevation + offsetOverDem
            tc = pElevation
            heightDifference = vpTc - pElevation
            if abs(heightDifference) < tolerance or vpTc < pElevation:
                break
            else:
                previousElevation = pElevation
                previousFc = fc
                previousSc = sc
                distance = distance + self.grid_size
        return str_error, fc, sc, tc

    def set_from_file(self,
                      file_name,
                      epsg_code,
                      load_in_memory):
        str_error = ''
        if not exists(file_name):
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_error += ("\nNot exists file: {}").format(file_name)
            return str_error
        try:
            self.ds = gdal.Open(file_name)
        except ValueError:
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_error += ("\nError opening dataset file:\n{}").format(file_name)
            return str_error
        try:
            self.rb = self.ds.GetRasterBand(1)
        except ValueError:
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_error += ("\nError getting raster band from file:\n{}").format(file_name)
            return str_error
        crs_from_epsg_code = osr.SpatialReference()
        crs_from_epsg_code.ImportFromEPSG(epsg_code)
        self.crs = osr.SpatialReference()
        self.crs.ImportFromWkt(self.ds.GetProjectionRef())
        self.crs.SetAxisMappingStrategy(osr.OAMS_TRADITIONAL_GIS_ORDER)
        crs_comparison = crs_from_epsg_code.IsSame(self.crs)
        if crs_comparison == 0:
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_error += ("\nCRS of the DEM must be equal to CRS of the project")
            return str_error
        dsm_crs_wkt = self.crs.ExportToWkt()
        self.columns = self.ds.RasterXSize
        self.rows = self.ds.RasterYSize
        self.georef = self.ds.GetGeoTransform()
        self.size_fc = self.georef[1]
        self.grid_size = abs(self.size_fc)
        self.size_sc = self.georef[5] # negative
        self.nw_fc = self.georef[0]
        self.nw_sc = self.georef[3]
        self.ne_fc = self.nw_fc + self.columns * self.size_fc
        self.ne_sc = self.nw_sc
        self.se_fc = self.ne_fc
        self.se_sc = self.ne_sc + self.rows * self.size_sc
        self.sw_fc = self.nw_fc
        self.sw_sc = self.se_sc
        # dsm_ulx, dsm_xres, dsm_xskew, dsm_uly, dsm_yskew, dsm_yres = dsm_ds.GetGeoTransform()
        data_type = self.rb.DataType
        dem_data = self.rb.ReadAsArray()
        no_data_value = self.rb.GetNoDataValue()
        if no_data_value:
            self.exists_no_data_value = True
            self.no_data_value = no_data_value
            if abs(no_data_value) < 0.1:
                self.exists_no_data_value = False
                self.no_data_value = 0.0
        if self.exists_no_data_value:
            dem_data = np.ma.masked_equal(dem_data, no_data_value)
            if hasattr(dem_data, 'mask'):
                mask_shape = dem_data.mask.shape
                if len(mask_shape) > 0:
                    self.data_masked = True
        min_value = dem_data.min()
        max_value = dem_data.max()
        # min_value, max_value = self.rb.ComputeRasterMinMax(False, False) # all values, if not-> NaN, NaN
        if math.isnan(min_value) or math.isnan(max_value):
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_error += ("\nError reading min/max values from file:\n{}").format(file_name)
            return str_error
        self.min_elevation = min_value
        self.max_elevation = max_value
        if data_type == gdalconst.GDT_UInt16:
            self.number_of_decimals = 0
            self.double_to_integer_factor = pow(10.0, self.number_of_decimals)
            self.integer_to_double_factor = 1.0 / self.double_to_integer_factor
            self.data = dem_data
            # self.data_uint16 = dem_data
        elif (data_type == gdalconst.GDT_Int16 or data_type == gdalconst.GDT_UInt32
              or data_type == gdalconst.GDT_Int32 or data_type == gdalconst.GDT_UInt64
              or data_type == gdalconst.GDT_Int64):
            self.number_of_decimals = 0
            self.double_to_integer_factor = pow(10.0, self.number_of_decimals)
            self.integer_to_double_factor = 1.0 / self.double_to_integer_factor
            self.data = dem_data.astype('uint16')
            # self.data_uint16 = dem_data.astype('uint16')
        elif data_type == gdalconst.GDT_Float32 or data_type == gdalconst.GDT_Float64:
            dem_data = dem_data * self.double_to_integer_factor
            if self.number_of_decimals < 2: #[0, 6500] * 10 in 16 bits range
                self.data = dem_data.astype('uint16')
                # self.data_uint16 = dem_data.astype('uint16')
            else:
                self.data = dem_data.astype('uint32')
                # self.data_uint32 = dem_data.astype('uint32')
        else:
            str_error = RasterDEM.__name__ + "." + self.set_from_file.__name__
            str_error += ("\nInvalid data type in raster DEM from file:\n{}").format(file_name)
            return str_error

        return str_error
